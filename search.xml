<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[顺序表]]></title>
    <url>%2F%E9%A1%BA%E5%BA%8F%E8%A1%A8.html</url>
    <content type="text"><![CDATA[定义 线性表L是n个元素e1,e2,e3, …en,组成的有限序列，记作L = (e1,e2,e3, …en),其中n(n&gt;=0)为表长度；当n = 0时，记做L=()。 非空线性表的特点: 有一个唯一的“第一个”数据元素。 有一个唯一的“最后一个”数据元素。 除头元素外，表中其他元素有且只有一个直接前驱。 除尾元素外，表中其他元素有且只有一个直接后继。 顺序表 附一个typedef用法的博客：传送门，下面开始正式说明。 顺序表定义顺序存储方式： 假设在计算机中有一个足够大的连续的存储空间，则可将表中元素按照其逻辑次序依次存储到这一存储区，由此而得到的线性表称为 顺序表。 具体实现:使用数组来对应连续的存储空间，如data[MAXLEN],另外用一个int类的变量来记录表的长度，和作为“路标”操作数组里的元素。 C语言实现:1234567#define MAXLEN 100 //最大长度设置struct sList&#123; elementType data[MAXLEN]; int listLen;&#125;;typedef struct sList seqList; //起别名，具体看上面传送门 C++语言实现:1234567#define MAXLEN 100 //最大长度设置class seqList&#123;public: elementType data[MAXLEN]; int listLen;&#125;; 说明: 代码中的elementType在使用时可用tepedef来指定为你所需要的类型。比如你想要一个double类型的数组，用来存放学生的成绩，可以用typedef double elementType。这样做的目的就是使更加模板化，使用起来更加方便。 常用基本运算 学会了常用的几个基本运算，再进行融会贯通即可。 初始化运算的实现说起初始化，可能大家的思路就是把数组清空，然后lis tLen = 0;才可以，其实并不需要。设想一下，原来我们选择的存储空间内就是有“无效数据”的，无论用没有用到，它都会有一些数据，只是没用到的那些数据对我们无效罢了。所以，我们在初始化的时候，就只需要将listLen初始化为0即可，然后以前的数据都自动看做“无效数据”，下次进行运算时插入覆盖掉就好了。代码如下:1234void initialList(seqList *L)&#123; L-&gt;listLen = 0; //使用引用也可以的&#125; 求表长度的实现其实求表长度几乎不需要什么操作，就是为了方便起见，写了一个返回函数。1234int listLength(seqList L)&#123; return L.listLen; //为什么没有求长度的操作？&#125; 回答上面的问题: 因listLen在其他的所有操作中都是相当于在数组的最后，也就是在所有的操作下，listLen时刻 代表着这个表的长度，所以当我们需要的时候直接来取即可。 按序号求元素顺序表L的序号为i的元素存放在下标为i-1的数组单元中，因此，直接从该数组单元中去值即可。下面给出一种实现:12345678910int getElement(seqList L,int i,elementType &amp;x)&#123; if(i&lt;1||i&gt;L.listLen) return 0; //取值失败 else &#123; x = L.data[i-1]; return 1; //取值成功 &#125;&#125; 查找元素的实现即确定元素x是否在顺序表L中，以及在L中的位置。需要依次比较各元素，所以得使用循环搜索。12345678int listLocate(seqList L, elementType x)&#123; for(int i=0;i&lt;L.length;i++)&#123; if(x==L.data[i]); return i+1; //返回序号 &#125; return 0; //没有找到，返回0&#125; 插入元素的实现这个可以说是比较麻烦的一项操作了，因为在顺序表插入一个值，插入值后面的所有值都得向后移动一个位置。下面给出一种代码示例:12345678910111213141516int listInsert(seqList &amp;L,elementType x,int i)&#123; if(L.listLen == MAXLEN)&#123; return 0; &#125; else if(i&lt;1||i&gt;L.listLen+1) return 1; else&#123; for(int j=L.listLen-1;j&gt;=i-1;j--)&#123; L.data[j+1] = L.data[j]; &#125; L.data[i-1] = x; L.listLen++; return 2; &#125;&#125; 删除算法实现删除的过程也是覆盖的过程，只需将要删除的元素后的所有元素都向前一位即可。对了，要记得listLen--操作。下面给出一种代码示例:12345678910111213141516int listDelete(seqlist *L,int i)&#123; if(L-&gt;listLen&lt;=0) return 0; //空表不能删除元素 else if(i&lt;1||i&gt;L-&gt;listLen) return 1; //删除元素不存在 else &#123; for(int j = i-1;j&lt;L.listlen;j++) &#123; L.data[j] = L.data[j+1]; &#125; L.listLen--; return 2; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp多态篇]]></title>
    <url>%2Fcpp%E5%A4%9A%E6%80%81%E7%AF%87.html</url>
    <content type="text"><![CDATA[多态概述 什么是多态？ 所谓多态，就是当发出一条命令的时候，不同的对象接收到同样的命令之后所做出的动作是不同的。用比较官方的话来讲，就是指相同对象收到不同消息或不同对象收到相同消息时产生不同的动作。 虚函数及实现原理虚函数 由virtual关键字修饰的函数称之为虚函数。 1.静态多态(早绑定)123456class Rect&#123;public: int calcArea(int width); int calcArea(int width,int height);&#125;; 程序在运行之前，在编译阶段就已经确定下来到底要使用哪个函数了。可见，很早的就已经将函数编译进去了，那么，我们就把这种情况叫做早绑定。 2.动态多态(晚绑定)动态多态必须以封装和继承为基础。 在定义成员函数的时候就把我们想要实现多态的成员函数前面加virtual关键字使其成为虚函数。然后在定义子类的时候，给相同的函数也加上virtual关键字，当然，这并不是必须的，如果你不加，系统会自动为你加上。如果加上了，我们会在后续的使用当中看的更加明显，所以推荐大家在子类的定义当中也加上virtual，避免出错。下面举个例子给大家: Shape.h 123456789101112131415161718192021#ifndef SHAPE_H#define SHAPE_H#include &lt;iostream&gt;using namespace std;class Shape&#123; public: virtual double calcArea() &#123; cout&lt;&lt;"calcArea"&lt;&lt;endl; return 0; &#125; Shape()&#123; cout&lt;&lt;"Shape()"&lt;&lt;endl; &#125; ~Shape()&#123; cout&lt;&lt;"~Shape()"&lt;&lt;endl; &#125;&#125;;#endif Rect.h 123456789101112131415161718192021222324252627#ifndef RECT_H#define RECT_H#include "Shape.h"class Rect:public Shape&#123; public: virtual double calcArea() &#123; cout&lt;&lt;"Rect--&gt;caleArea()"&lt;&lt;endl; return m_dWidth*m_dHeight; &#125; Rect(double width,double height) &#123; m_dWidth = width; m_dHeight = height; cout&lt;&lt;"Rect()"&lt;&lt;endl; &#125; ~Rect() &#123; cout&lt;&lt;"~Rect()"&lt;&lt;endl; &#125; protected: double m_dWidth; double m_dHeight;&#125;;#endif Circle.h 123456789101112131415161718192021222324#ifndef CIRCLE_H#define CIRCLE_H#include "Shape.h"class Circle:public Shape&#123; public: virtual double calcArea() &#123; cout&lt;&lt;"Circle--&gt;calcArea()"&lt;&lt;endl; return 3.14*m_dR*m_dR; &#125; Circle(double r)&#123; m_dR = r; cout&lt;&lt;"Circle()"&lt;&lt;endl; &#125; ~Circle() &#123; cout&lt;&lt;"~Circle()"&lt;&lt;endl; &#125; protected: double m_dR;&#125;;#endif demo.h 1234567891011121314151617#include "Circle.h"#include "Rect.h"int main(void)&#123; Shape *s1 = new Rect(3,6); Shape *s2 = new Circle(5); s1-&gt;calcArea(); s2-&gt;calcArea(); delete s1; delete s2; s1 = NULL; s2 = NULL; return 0;&#125; 运行结果如下，请自行体会(代码可复制试验)12345678910x1aolin@x1aolin-E402NA:~/桌面/虚函数$ g++ demo.cpp Circle.h Rect.h Shape.h -o ox1aolin@x1aolin-E402NA:~/桌面/虚函数$ ./oShape()Rect()Shape()Circle()Rect--&gt;caleArea()Circle--&gt;calcArea()~Shape()~Shape() 虚析构函数在上面的代码中……]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>cpp多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp继承篇]]></title>
    <url>%2Fcpp%E7%BB%A7%E6%89%BF%E7%AF%87.html</url>
    <content type="text"><![CDATA[继承 视频链接:https://www.imooc.com/video/8701 定义通过继承机制，可以利用已有的数据类型来定义新的数据类型。所定义的新的数据类型不仅拥有新定义的成员，而且还同时拥有旧的成员。我们称已存在的用来派生新类的类为基类，又称为父类。由已存在的类派生出的新类称为派生类，又称为子类。 为什么要使用继承?1、继承可以减少重复的代码。比如父类已经提供的方法，子类可以直接使用，不必再去实现。2、继承是多态性的前提。当然使用继承的同时也提高了类的耦合度。 代码演示123456789#include "Person.h"class Worker: public Person //公有继承&#123;public: Worker(); ~Worker(); int m_iSalary; void work();&#125;; 继承方式 视频链接:https://www.imooc.com/video/8703 公有继承 class A:public B 保护继承 class A:protected B 私有继承 class A:private B 公有继承 public子类可以继承父类public下的所有数据成员和成员函数，并且在子类中的访问权限也是public,子类可以直接用.或者-&gt;符号直接访问父类中的数据成员和成员函数。 protected子类继承父类所有的protected下的所有数据成员和成员函数，并且在子类中的访问权限为protected,子类不可以直接用.或者-&gt;符号直接访问父类中的数据成员和成员函数。 private子类继承父类所有的private下的所有数据成员和成员函数到不可见位置。换句话说，子类无法访问父类的private成员。 下面给出一个例子来加深一下理解：123456789class Person&#123;public: void eat();protected: int m_iAge;private: string m_strName;&#125;; 经过继承之后，相当于下面的代码:(下面备注继承过来的的代码实际运用中不可见，与下面“隐藏”相区别)1234567891011class Worker: public Person&#123;public: void eat(); //**继承过来的**，可在任意位置使用 void work();protected: int m_iAge; //**继承过来的**，可在类内使用 int m_iSalary;private: int h; //m_strName继承不可见，也无法使用&#125;; 最后用一个表格总结一下: 基类成员访问属型 继承方式 派生类成员访问属型 private成员 public 无法访问 protected成员 public protected public成员 public public 保护继承 基类成员访问属型 继承方式 派生类成员访问属型 private成员 protected 无法访问 protected成员 protected protected public成员 protected protected 私有继承 基类成员访问属型 继承方式 派生类成员访问属型 private成员 private 无法访问 protected成员 private private public成员 private private 继承中的特殊关系 视频链接:https://www.imooc.com/video/8708 隐藏如果子类中有与父类同名的数据成员和成员函数，那么用子类实例化一个对象后，这个对象通过一般手段只能调用子类中的数据成员和成员函数。总结为三个关键字：父子关系 成员同名 隐藏 除此之外，如果子类父类中成员函数名字相同，但是参数不同，也是能形成隐藏的。 子类和父类之间无法形成重载，只能形成隐藏。 如果想要调用父类的同名成员函数，仍需要用到命名空间，具体看下面的代码。 下面给出一个例子:1234567class Person //父类&#123;public: void play();protected: string m_strName;&#125;; 12345678class Soldier:public Person //子类&#123;public: void play(); //同名成员函数,内容不同 void work();protected: int m_iCode;&#125;; 1234567int main(void)&#123; Soldier soldier; soldier.play(); //调用子类中的play函数 soldier.Person::play(); //调用父类Person中的成员函数 return 0;&#125; 虽然这是语法规定，但是我们为了避免混淆，一般不会用到同名的成员变量和成员函数，所以尽量不要让子类和父类的成员变量和成员函数同名，这是一种好的编程习惯。 IS A类似于Java当中的上转型对象，在C++当中，派生类的对象也可以赋值给基类。当然，基类的指针也可以指向派生类的对象。1234567891011//基于上面的代码,Person类是Soldier的父类。int main(void)&#123; Soldier s1; Person p1 = s1; //True Person *p2 = &amp;s1; //True s1 = p1; Soldier *s2 = &amp;p1; //False return 0;&#125; 当我们用子类的对象向父类的对象赋值时，其本质就是将子类当中从父类继承下来的数据成员赋值给父类的对象，子类当中的其他的数据此时就会被截断。其中，实例化对象能够调用的成员函数依旧是父类当中的成员函数。 虚的析构函数 ： 写成virtual ~Person()，这样在释放基类的指针时就会先执行子类的析构函数，避免内存泄漏。 想要了解更详细的内容，请看博客cpp多态篇 多继承与多重继承 视频链接:https://www.imooc.com/video/8716 多重继承 举个栗子: 人类－－士兵类－－步兵类123456789class Person&#123;&#125;;class Soldier:public Person&#123;&#125;;class Infantryman:public Soldier&#123;&#125;; 多继承多继承，也就是一个子类有多个父类。具体到代码层面:123456789class Worker&#123;&#125;;class Farmer&#123;&#125;;class MigrantWorker:public Worker,public Farmer//不写public默认私有继承&#123;&#125;; 结论: 无论继承的层级有多少层，只要保持着直接或者间接的继承关系，那么子类都可以与自己的直接父类或者是间接父类称之为是一个的关系，并且能够对父类的指针对直接子类或间接子类的对象进行相应的操作。 虚继承 视频链接:https://www.imooc.com/video/8719 最典型的“菱形继承”既有多继承，也会有多重继承。图片我就不放了，请大家自行点击传送门进行了解。 如何处理其中带来的数据冗余问题呢？就需要这节题目所带来的“虚继承”了。下面说一下什么是虚继承: 虚继承是继承的一种方式，其定义关键字是virtual。下面给出示例说明使用方法。123class Worker: virtual public Person //virtual 和 public 前后位置随意&#123;&#125;; 使用虚继承后，菱形继承最顶层的父类，并没有进行参数的传递，也就是说参数只使用了顶层父类的默认参数，而无法从子类当中获得传入的参数。 下面给出一个简单例题:12345678910111213定义Person人类，worker工人类及children儿童类，worker类中定义数据成员m_strName姓名，children类中定义成员m_iAge年龄，worker类及children类均虚公有继承Person类，定义ChildLabourer童工类，公有继承工人类和儿童类，从而形成菱形继承关系。在main函数中通过new实例化ChildLabourer类的对象，并通过该对象调用Person，Worker及Children类中的成员函数，最后销毁该对象，掌握多重继承，多继承，虚继承的定义方法。]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>cpp继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java访问权限]]></title>
    <url>%2FJava%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.html</url>
    <content type="text"><![CDATA[和C++一样，Java中对象操作自己的变量和使用类中的方法是有一定的限制的，即所谓的访问权限。 所谓访问权限，是指对象是否可以通过.运算符操作自己的变量或者使用类中的方法，访问限制修饰符有private,protected,public，下面会对其分别进行介绍。]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java包和import语句]]></title>
    <url>%2FJava%E5%8C%85%E5%92%8Cimport%E8%AF%AD%E5%8F%A5.html</url>
    <content type="text"><![CDATA[包包是Java语言中有效的管理类的一个机制。不同Java源文件中可能出现名字相同的类，如果想区分这些类，就需要使用包名。使用包名的目的是有效的区分名字相同的类。 1.包语句通过关键词package声明包语句。package语句需要放在Java源文件的第一条语句，指明该源文件定义的类所在的包，即为该源文件中声明的类指定包名。一般格式:1package 包名;//包名是一个合法的标识符或者若干个标识符加“.”分隔而成 有的小伙伴可能会有疑问了，在这篇blog之前的blog中的Java代码都没有加上述语句，为什么还能运行？那是因为我们省略了package语句。如果省略了该语句，源文件中所定义命名的类被隐含地认为是无名包的一部分，只要这些类的字节码被存放在相同的目录中，那么他们就属于同一个包，只是没有包名罢了。 2.有包名的类的储存如果我们显式地定义了包名，就不能再像之前那样在随意的位置存放了，需要遵守一定的规则，否则虚拟机将无法加载这样的类。程序如果使用了包语句，例如：1package x1ao.lin; 那么在存储文件的目录结构中必须包含如下结构: .../x1ao/lin（Windows下是\斜杠），并且要将源文件编译文件得到的字节码文件保存到该目录(源文件位置可任意)。 3.运行有包名的主类如果主类的包名是x1ao.lin，那么主类的字节码一定一定要存放在.../x1ao/lin目录中，因此必须到x1ao/lin的上一层(即x1ao的父目录)目录中运行主类。举个栗子:1x1aolin@x1aolin-E402NA:~/projects$ java x1ao.lin.主类名 Notice: 运行时，必须写主类的全名。使用包名后主类的全名为“包名.主类名”。 举个栗子:xueHao.java : 放在~/projects/x1ao/lin文件夹下(ubuntu系统)1234567891011package x1ao.lin;public class xueHao&#123; long xuehao; xueHao(long xuehao)&#123; this.xuehao = xuehao; &#125; void print()&#123; System.out.print("学号为: "+xuehao); System.out.print(" xueHao类: package x1ao.lin"); &#125; &#125; Exam2.java : 放在~/projects/x1ao/lin文件夹下(ubuntu系统)12345678package x1ao.lin;public class Exam2&#123; public static void main(String args[])&#123; xueHao number = new xueHao(2018061366); number.print(); System.out.println("主类: package x1ao.lin"); &#125;&#125; 编译。将这两个文件放入上面所述的位置后(这只是提供一种可能)，然后进入到/x1ao/lin的上一层目录projects中编译两个源文件。如下图: 1234//其实只需要运行第一条命令即可,因为他们的源文件都放在同一目录中.//只需编译主类的源文件，Java系统会自动地编译其他的源文件。x1aolin@x1aolin-E402NA:~/projects$ javac x1ao/lin/Exam2.java x1aolin@x1aolin-E402NA:~/projects$ javac x1ao/lin/xueHao.java 运行。在x1ao/的上一层目录运行 123x1aolin@x1aolin-E402NA:~/projects$ java x1ao.lin.Exam2 //运行命令学号为: 2018061366 xueHao类: package x1ao.lin //运行结果主类: package x1ao.lin 注：java语言不允许用户使用java作为包名或者作为包名的一部分。 import语句一个类可能需要另一个类声明的对象作为自己的成员或者作为方法中的局部变量。如果这两个类在同一个包中没问题，但是如果不再同一个包中，就需要import语句来进行引入了。 1.引入类库中的类在编写源文件的时候，用户除了自己编写类外，经常使用Java提供的许多类，这些类可能在不同的包中。为了使用Java提供的类，可以使用import语句引入包中类。import语句可以有多个，位置需要放在package语句(可省略)和源文件类的定义中间。 如果要引入一个包中的所有类，可以用通配符“ * ”来代替。例如: 1import java.util.*; 如果只是使用一个包中的某个类，就可以直接写明就可以了。例如: 1import java.util.Scanner; //用于用户从控制台输入数据 举个详细的栗子给大家:12345678import java.util.Date;public class Exam3&#123; public static void main(String args[])&#123; Date date = new Date();//这是Data类的构造函数 System.out.print("本地机器时间为:"); //不带空格 System.out.println(date); &#125;&#125; 运行结果如下，请大家自行体会:12x1aolin@x1aolin-E402NA:~/桌面/javaExample$ java Exam3本地机器时间为:Wed Jun 13 13:00:24 CST 2018 下面给出两点说明: java.lang包是Java语言的核心类库，其中包含了运行Java程序必不可少的系统类，系统会自动引入，不需要再使用import语句。 如果使用import语句引入了整个包中的类，可能会增加编译时间，但是不会影响程序运行时的性能,因为运行和之和字节码有关。 2.引入自定义包中的类方法一: 修改更新classpath，不推荐，此处也不再介绍，对此有兴趣的童鞋可自行百度。 方法二: 在用户程序所在的目录下建立和包相对应的子目录结构。 方法二该怎样理解呢？举个栗子，假定用户程序的某个类所在目录为~/java，该类想使用import语句x1ao.lin包中的类，那么根据包名建立如下目录结构： ~/java/x1ao/lin即可。emmmm…我个人的理解就是你可以自定义一个目录，然后一切活动都在这个目录下进行。如果定义一个包，就将包名形成的目录放在这个目录下按照一定的规则进行编译运行，不太会表达，大家可忽略这句话。 3.使用无包名的类如果一个类想使用没有包名的类，只需要将这个无名包的类的字节码和当前类保存在同一目录下即可。(以前我们也是这么做的，有没有想起来呢^_^)。 4.避免类名混淆 如果一个源文件使用了一个无名包中的A类，同时又用import语句引入了某个有包名的同名类，比如x1ao.lin中的A类，这时候就会产生类名的混淆。 如果源文件明确引用该类: 1import x1ao.lin.A; 当使用A类时，如果省略包名，那么源文件使用的是x1ao.lin包中的A类，也就是说源文件无法使用无名包中的A类。如果想要同时使用，就不能省略包名了。系统会自动检测，如果检测到包名，就会自动判定省略包名的代码是使用的无名包。举个栗子: 12A x1 = new A(); //无名包创建的对象x1ao.lin.A x2 = new x1ao.lin.A(); //指定包创建的对象 如果源文件不明确引用该类: 1import x1ao.lin.*; 当使用A类时，如果省略包名，那么源文件使用的是无名包中的A类，而无法使用指定包中的A类。如果想要同时使用，就不应该省略。 如果一个源文件引入了两个包中同名的类，那么在使用类时，不允许 省略包名。]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之this关键字]]></title>
    <url>%2FJava%E4%B9%8Bthis%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[我以前写过C++的this指针，和Java的没有太大区别，大家可以点进去看看。 this是Java的一个关键字，表示某个对象。this可以出现在实例方法和构造方法中，不可出现在类方法中^1。(大家看看上篇博客实例方法与类方法的区别应该能体会出来原因)。 在构造方法中使用this在构造方法中代表使用该构造方法所创建的对象。听起来有点绕，说白了就是代表哪个对象调用，this就代表谁，改变的数据也是当前对象所“拥有统领”的变量。 如果没有要求就不给例子了哈。^_^ 在实例方法中使用this实例方法只能通过对象来调用，所以，当this关键字出现在实例方法中时，代表正在调用该方法的当前对象。 1.当实例成员变量在实例方法中出现时，默认格式如下:1this.成员变量 //通常情况下this可省略 2.当static成员变量在实例方法中出现时，默认格式如下:1类名.成员变量 //通常情况下类名可省略 不通常情况 : 当实例成员变量的名字和局部变量的名字相同时就不可省略了。 3.类的实例方法可以调用类的其他方法1this.方法 //通常情况下this可省略 4.对于类方法调用的默认格式如下:1类名.方法 //通常情况下类名可省略 举个栗子(代码不可单独运行)：123456789101112131415161718class A&#123; int x; static int y; void a()&#123; this.x = 100; //this可省略 A.y = 200; //A可省略 &#125; void b()&#123; this.c(); //this可省略 A.d(); //A可省略 &#125; void c()&#123; System.out.println("c"); &#125; static void d()&#123; System.out.println("d"); &#125;&#125;]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之static关键字]]></title>
    <url>%2FJava%E4%B9%8Bstatic%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[类体的定义 –&gt; 成员变量的定义 + 方法的定义。成员变量 –&gt; 实例变量 + 类变量(static) 。方法 –&gt; 构造方法 + 类方法(static) + 实例方法。类方法只能调用类方法，实例方法可调用类中的实例方法和类方法。 实例变量和类变量的区别 一个类通过使用new运算符可以创建多个不同的对象，这些对象将被分配不同的内存空间。更准确的是，不同对象的实例变量将被分配不同的内存空间，但是所有对象的这个类变量都分配给相同的一处内存，改变其中一个对象的这个类变量会影响其他对象的这个类变量,即对象共享类变量 当Java程序执行时，类的字节码文件被加载到内存，如果该类没有创建对象，类中的实例变量不会被分配到内存。但是类中的类变量是该类被加载到内存时，就分配了相应的内存空间。 如果该类创建对象，那么不同对象的实例变量互不相同，即分配不同的内存空间，而类变量不再重新分配内存，所有对象共享类变量，即所有对象的类变量是相同的一处内存空间，类变量的内存空间直到程序退出运行，才释放所占有的内存。 因为类变量的特殊性，它既可以通过某个对象访问，也可以直接通过类名访问；而实例变量只能通过对象访问。 道理比较浅显，我就不举例子啦。^_^ 实例方法和类方法的区别 方法的入口地址只分配一次，被所有对象共享，当所有的对象都不存在时，方法的入口地址才会取消。 当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址，在该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用。 对于类中的类方法，在该类被加载到内存时，就分配了相应的入口地址，所以类方法不仅可以被类创建的任何对象调用，也可以直接通过类名调用。类方法的入口地址直到程序退出才会被取消。 实例方法既能对类变量操作也能对实例变量进行操作，而类方法只能对类变量进行操作 由于类方法的特性，如果一个方法不需要操作实例变量就可以实现某种功能，就优先考虑声明为类方法,这样可以节省空间。 这此给大家举个栗子:(包含许多以前学过的知识)1234567891011121314class Sum&#123; static int sum = 0; static void getResult(int ... x)&#123;//详情请看上篇blog可变参数部分 for(int i:x)&#123; sum+=i; &#125; &#125;&#125;public class Exam1&#123; public static void main(String args[])&#123; Sum.getResult(1,2,3,4,5,6,7,8,9);//45 System.out.printf("%d\n",Sum.sum); &#125;&#125; 运行结果如下，自行体会:12x1aolin@x1aolin-E402NA:~/桌面$ java Exam145]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java参数传值]]></title>
    <url>%2FJava%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC.html</url>
    <content type="text"><![CDATA[当方法被调用的时候，如果方法有参数，参数必须要实例化，即参数必须有具体的值。在Java中，方法的所有参数都是“传值”的，也就是说，方法中参数变量的值是调用者指定的一个副本。 基本数据类型参数传值对于基本类型的参数，向该参数传递的值的级别不可以高于该参数的级别，可以低于该参数的级别。如果传递值的级别比参数的级别低，则传递过程中会自动转化。 引用类型参数的传值这里先普及一下什么是引用类型: 对象，数组，接口等都是引用类型，关于引用类型的含义或者理解在上篇博客第三点有提到:对象的引用和实体。当参数是引用类型时，“传值”传递过去的是变量中存放的“引用”，而不是变量的实体。 所以对于两个同类型的引用型变量，如果具有同样的引用，就会有同样的实体，因此，如果改变参数变量所引用的实体，就会导致原变量的实体发生同样的变化。但是，改变参数的“引用”不会影响向其传值的变量中存放的“引用”。放个图加深理解: 说明： 上面的意思是说当调用左右任何一个引用来改变实体后，另一个引用所指实体也会改变，它们本来就是一个嘛。当改变左右任何一个引用，就是该引用不再指向这个实体后，另一个应用不受影响，仍然指向这个实体 这个想想应该可以理解，就暂时不放代码示例了，如果大家有要求，我再把代码放上去。 可变参数 这个是C++里面没有的，所以请大家多关注一下。 可变参数是指在声明方法时不给出参数列表中从某项直至最后一项参数的名字和个数，但这些参数的类型应该相同。可变参数使用”…”表示若干个参数，最后一个参数必须是参数列表中的最后一个参数。例如:1public void aaa(double h,int ... x); 这里的x是方法aaa的参数列表中可变参数的参数代表。参数代表可以通过下标运算来表示参数列表中的具体参数，即x[0]，x[1]，… ，x[m-1]来表示x所代表的参数。对于一个参数代表，参数代表.length等于参数代表所代表的个数。举个栗子:123456789101112131415161718192021class Computer&#123; public double getResult(double a,int ... x)&#123; // !!! double result = 0; int sum = 0; for(int ss:x)&#123; //下面会给解释 sum +=ss; &#125; result = a*sum; System.out.println("x代表了"+x.length+"个数"); return result; &#125;&#125;public class Exam&#123; public static void main(String args[])&#123; Computer comp = new Computer(); double result = comp.getResult(1.0/3,5,6,7);//x代表三个数 System.out.println("5,6,7的平均数:"+result); result = comp.getResult(1.0/5,11,22,33,44,55);//x代表五个数 System.out.println("11,22,33,44,55的平均数为:"+result); &#125;&#125; 代码运行结果如下，请大家好好体会:1234567x1aolin@x1aolin-E402NA:~/桌面$ vim Exam.javax1aolin@x1aolin-E402NA:~/桌面$ javac Exam.java x1aolin@x1aolin-E402NA:~/桌面$ java Examx代表了3个数5,6,7的平均数:6.0x代表了5个数11,22,33,44,55的平均数为:33.0]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有向面积]]></title>
    <url>%2F%E6%9C%89%E5%90%91%E9%9D%A2%E7%A7%AF.html</url>
    <content type="text"><![CDATA[此次介绍用有向面积的概念求(凹)多边形的面积，理论基础传送门，大家可以点开超链接了解一下什么是有向面积，然后再来看此处的例题: Input:The input data consists of several figures. The first line of the input for each figure contains asingle integer n, the number of vertexes in the figure. (0≤n≤1000).In the following n lines, each contain a pair of real numbers, which describes the coordinates ofthe vertexes, (xi, yi). The figure in each test case starts from the first vertex to the second one,then from the second to the third, …… and so on. At last, it closes from the nth vertex to the firstone.The input ends with an empty figure (n = 0). And this figure not be processed. Output:As shown below, the output of each figure should contain the figure number and a colon followedby the area of the figure or the string “Impossible”.If the figure is a polygon, compute its area (accurate to two fractional digits). According to theinput vertexes, if they cannot form a polygon (that is, one line intersects with another whichshouldn’t be adjoined with it, for example, in a figure with four lines, the first line intersects withthe third one), just display “Impossible”, indicating the figure can’t be a polygon. If the amount ofthe vertexes is not enough to form a closed polygon, the output message should be “Impossible”either. C++代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;math.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;using namespace std;typedef pair&lt;double,double&gt; Point;int input(vector&lt;Point&gt; poi,double result[])&#123; int xuhao=0; while(1)&#123; int n; cin&gt;&gt;n; if(n&lt;=2) break; xuhao++; int num = n; //备份 while(n)&#123; //输入 double x,y; cin&gt;&gt;x; cin&gt;&gt;y; poi.push_back(make_pair(x,y)); n--; &#125; double sum=0.0; for(int i=0;i&lt;num;i++)&#123; //计算 sum +=(poi[i].first*poi[(i+1)%num].second)-(poi[(i+1)%num].first*poi[i].second); &#125; result[xuhao-1] = sum; poi.clear();//清空元素 &#125; return xuhao;&#125;int main()&#123; vector&lt;Point&gt; poi; poi.clear();//清空元素 double result [100] = &#123;0&#125;; int xuhao = input(poi,result); for(int i=0;i&lt;xuhao;i++)&#123; if(result[i]!=0.0)&#123; cout&lt;&lt;"Figure "&lt;&lt;i+1&lt;&lt;": "&lt;&lt;fabs(result[i]*0.5)&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;"Figure "&lt;&lt;i+1&lt;&lt;": Impossible"&lt;&lt;endl; &#125; &#125; return 0;&#125; 运行代码如下，请自行体会:1234567891011121314151617x1aolin@x1aolin-E402NA:~/projects$ vim AREA.cpp x1aolin@x1aolin-E402NA:~/projects$ g++ AREA.cpp x1aolin@x1aolin-E402NA:~/projects$ ./a.out 50 00 10.5 0.5 1 11 0 40 00 11 0 1 10Figure 1: 0.75Figure 2: Impossible]]></content>
      <categories>
        <category>算法与程序设计</category>
      </categories>
      <tags>
        <tag>计算几何算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算几何之寻找凸包]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B9%8B%E5%AF%BB%E6%89%BE%E5%87%B8%E5%8C%85.html</url>
    <content type="text"><![CDATA[首先我们先看一个例子: 这个问题就是典型的凸包问题。先讲一下什么是凸包:凸包是一组点集中的子集,这一子集形成的凸多边形可以将点集中所有的点都围住,并且这一凸多边形的面积是最小的。 显而易见，上述问题的求解就是把最外面的一圈点用折线圈起来，这样就是最好的结果。那么，怎么把这种思想体现到计算机算法中呢？其实有很多种解决方法，其中这里讲一个比较容易理解实现的算法:打包法具体算法如下: 找出点集中最下方的点，如果这样的点不止一个，就选用最左边的点。 设想在该点处拴住了一根橡皮筋的一端，另一端放在和该点成水平位置的右侧。 将皮筋沿逆时针方向转动,直到碰到第一个点，然后第二个，第三个…直到形成一个闭合的凸包。 具体而言:就是第一次找到一点(如P0)，以P0为每个矢量的起点，其他的点为矢量的终点，比较任意两个矢量的转角，就可以对余下的点进行按极角排序。如下图: 对于右图这种极角相同的情况，可以判定哪个点在中间，哪个点在两边(下面代码实现中on_segment()函数)。 C++代码实现如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;utility&gt; //pair所在头文件#include &lt;vector&gt; //vector容器#include &lt;algorithm&gt; //提供大量基于迭代器的非成员模板函数using namespace std;typedef pair&lt;double,double&gt; POINT;double direction(POINT p,POINT p1,POINT p2)&#123; POINT v1,v2; //定义两个向量，用于后续比较 v1.first = p2.first - p.first; v1.second = p2.second - p.second; v2.first = p1.first - p.first; v2.second = p1.second - p.second; double k = v1.first*v2.second - v1.second*v2.first;//类似z轴单位向量 return k;//k为正值,p2逆时针旋转得到p1，p2极角小,等于0时p1,p2共线&#125;bool on_segment(POINT p,POINT p1,POINT p2)&#123; //判断p是不是在以p1p2线段为对角线的边平行于x,y轴的矩形中 double min_x = p1.first &lt;p2.first ?p1.first :p2.first; double max_x = p1.first &gt;p2.first ?p1.first :p2.first; double min_y = p1.second&lt;p2.second?p1.second:p2.second; double max_y = p1.second&gt;p2.second?p1.second:p2.second; if(p.first &gt;= min_x &amp;&amp; p.first &lt;=max_x &amp;&amp; p.second&gt;= min_y &amp;&amp; p.second&gt;=max_y) return true; else return false;&#125;POINT startPoint; //定义一个起始点bool sortByPolorAngle(const POINT &amp;p1,const POINT &amp; p2)&#123; double d = direction(startPoint,p1,p2); if(d&lt;0) return true;//默认p1为下一个正确点 if(d&gt;0) return false; if(d=0 &amp;&amp; on_segment(startPoint,p1,p2)) return true; //感觉这种方式不会用到(???) if(d=0 &amp;&amp; on_segment(p1,startPoint,p2))//共线的两种方式 return true; return false; //以上条件都不符合 &#125;void find_convex_hull(vector&lt;POINT&gt; &amp; point)&#123; POINT p0 = point[0]; int k = 0; for(int i=1;i&lt;point.size();i++)&#123; //找起始点，具体算法中的第一点 if(point[i].second &lt;p0.second || point[i].second == p0.second &amp;&amp; point[i].first&lt;p0.first)&#123; p0 = point[i]; k = i; &#125; &#125; point.erase(point.begin()+k);//删除那个已经选出的点 point.insert(point.begin(),p0);//把p0插入到point的最前面 vector&lt;POINT&gt; convex_hull; //凸包容器 do&#123; convex_hull.push_back(point[0]); //在最后插入选出的点 startPoint = point[0]; point.erase(point.begin()); //删除已经选出的点,方便进行排序。 sort(point.begin(),point.end(),sortByPolorAngle); if(point[0] == convex_hull[0]) break; //出口,形成了一个凸包 point.push_back(convex_hull[convex_hull.size()-1]); &#125;while(1); for(int i = 0;i&lt;convex_hull.size();i++)//打印凸包 &#123; cout&lt;&lt;'('&lt;&lt;convex_hull[i].first&lt;&lt;','&lt;&lt;convex_hull[i].second&lt;&lt;')'&lt;&lt;endl; &#125;&#125;//下面给出验证main函数int main()&#123; vector&lt;POINT&gt; point; cout&lt;&lt;"请输入所有的点，我们将找出其对应的凸包:"&lt;&lt;endl; char s = 'Y'; int i=0; while(s == 'Y')&#123; double x,y; cout&lt;&lt;"x坐标:"; cin&gt;&gt;x; cout&lt;&lt;"y坐标:"; cin&gt;&gt;y; point.push_back(make_pair(x,y)); i++; cout&lt;&lt;"你还要继续输入吗？(Y/N):"; cin&gt;&gt;s; &#125; cout&lt;&lt;"输入结束，对应凸包为:"&lt;&lt;endl; find_convex_hull(point); return 0;&#125; 下面给出一些解释或补充，以便于更好理解代码: 数学基础—向量运算(叉乘)，三维向量叉乘推导,给那些有强迫症的一定要打破砂锅问到底的孩子们。 STL容器对应的几个函数用法: C++学习之容器—erase()函数,insert()函数,push_back()使用方法,sort()用法。]]></content>
      <categories>
        <category>算法与程序设计</category>
      </categories>
      <tags>
        <tag>计算几何算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对象基础]]></title>
    <url>%2FJava%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%BA%8C.html</url>
    <content type="text"><![CDATA[类是面向对象语言中最为重要的一种数据类型，类声明的变量称为对象。类是创建对象的模板，当使用一个类创建一个对象时，也称给出了这个类的一个实例。 创建对象创建对象包括对象的声明和为声明的对象分配内存两个步骤: 对象的声明类的名字 对象名字; //声明之后，就可以分配内存了 为声明的对象分配内存 使用new运算符和类的构造方法为声明的对象分配内存，即调用构造方法为其分配内存。如果类中没有构造方法，系统会调用默认的构造方法(默认构造方法:无参无语句)。如果类中定义了一个或多个构造方法，那么Java不提供默认的构造方法。举个栗子:1234567891011121314class xiyoujiRenwu&#123; float height,weight; String head,ear,hand,foot,mouth; void speak(String s)&#123; System.out.println(s); &#125;&#125;public class Example4_1&#123; public static void main(String argv[])&#123; xiyoujiRenwu zhubajie; //声明对象 zhubajie = new xiyoujiRenwu(); //为对象分配内存，默认构造方法 &#125;&#125;//自建构造方法此处不再给出，在以后的讲述中会有提到。 Notice: 如果类中定义了一个或者多个构造方法，那么Java不提供默认的构造方法！！！ 对象的内存模型接上面的代码给大家介绍一下对象的内存模型，以便于更好的理解对象这一概念： 声明对象zhubajie后，zhubajie的内存中还没有任何数据，也就是空对象。空对象不能使用，因为它还没有得到任何“实体”，必须再进行为**为对象分配内存的步骤，即为对象分配实体。 当系统见到: 1zhubajie = new xiyoujiRenwu(); 时，就会做两件事。 为xiyoujiRenwu类中的成员变量height, weight, head, ear, mouth, hand, foot分配内存，即类中的成员变量被分配内存空间，然后执行构造方法进行数据的初始化。(如果成员变量在声明时没有指定初值，并且所使用的构造方法也没有对成员变量进行初始化，那么，整型变量默认初值为0，浮点型变量默认初值0.0，boolean型变量默认false，引用型变量默认初值为NULL)。 给出一个信号，保证这些变量是属于对象zhubajie的。即new运算符为这些变量分配完内存后，会返回一个引用给zhubajie对象。(这样也就不难理解一个类使用new创建不同的对象(实例变量等)不会相互影响了，因为他们被分配不同的内存)。如下图所示: 使用对象抽象的目的时产生类，而类的目的是创建具有属性和行为的对象。对象不仅可以操作自己的变量改变状态，而且还能调用类中的方法产生一定的行为。12对象.变量; //调用变量对象.方法; //调用方法 体现封装: 当对象调用方法时，方法中出现的成员变量就是分配给该对象的变量。当对象调用方法时，方法中的局部变量被分配内存空间，方法执行完毕，局部变量即可释放内存。Notice: 局部变量在声明时如果没有初始化，那么它就没有默认值。 对象的引用和实体当用类创建一个对象时，类中的成员变量在堆(一种运行时的数据结构，支持动态内存管理) 中分配内存空间，这些内存空间成为该对象的实体或对象的变量，而上文所提到的对象中存放的引用在栈中分配内存，以确保实体由该对象使用。 由上面的解释大家可以知道，引用 和 实体 是分开的，即大家可以改变引用来相应改变它所能调用的实体。这么说大家可能还是不清楚，举个栗子给大家:1234567891011121314151617181920class x1aoPoint&#123; public int a,b; //public表示权限，后面会提到 x1aoPoint(int a,int b)&#123; //自定义构造方法(又复习了一下) this.a = a; this.b = b; //关于this会在后面的博客中提到哦 &#125;&#125;public class Lin&#123; public static void main(String args[])&#123; x1aoPoint p1,p2; p1 = new x1aoPoint(1,2); p2 = new x1aoPoint(4,3); //下面是重点！！！ System.out.println("("+p1.a+","+p1.b+")"); System.out.println(p1+"\n"+p2); p1 = p2; //改变引用，使p1也指向此前为p2分配的变量 System.out.println("("+p1.a+","+p1.b+")"); System.out.println(p1+"\n"+p2); &#125;&#125; 运行结果如下，其余请自己体会:123456789x1aolin@x1aolin-E402NA:~/桌面/javaExample$ vim Lin.javax1aolin@x1aolin-E402NA:~/桌面/javaExample$ javac Lin.java x1aolin@x1aolin-E402NA:~/桌面/javaExample$ java Lin(1,2)x1aoPoint@233c0b17x1aoPoint@61a52fbd(4,3)x1aoPoint@61a52fbdx1aoPoint@61a52fbd 最后补充一点: Java有所谓的“垃圾回收”机制：周期性的检测某个实体是否已经不再被任何对象所拥有，如果发现这样的实体，就会自动释放掉实体所占有的内存。所以，上面代码中，当p2的引用赋给p1时，最初分配给p1的实体就会被释放掉。]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类基础知识]]></title>
    <url>%2FJava%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B8%80.html</url>
    <content type="text"><![CDATA[面向对象语言特性众所周知，Java是一门面向对象的编程语言，它的源程序由若干个类组成，源文件时拓展名为.java的文本文件。下面给出面向对象编程的特性: 1.封装性。即将数据和对数据的操作封装在一起，通过抽象，从具体的实例中抽取共同的性质形成一般的概念。比如类的概念。 2.继承性。子类可以继承父类的属性和功能，既继承了父类所有的数据和数据上的操作，同时又可以添加子类独有的数据和数据上的操作。 3.多态性。一种是操作名称的多态，既有多个操作具有相同的名字，但这些操作所接受的信息类型必须不同。另一种多态是和继承有关的多态，是指同一个操作被不同的类型对象调用时可能产生不同的行为。 类的声明类是组成Java程 序的基本要素，类封装了一类对象的状态与方法，类是用来定义对象的模板。类的实现包括两个部分，即类的声明和类体，基本格式如下:123class 类名&#123; //类的声明 类体的内容 //类体&#125; 类的声明注意事项 :1.类的名字要符合标识符的规定。(语法要求)2.如果类名使用拉丁字母，那么类名的首字母使用大写字母。(不是语法要求但需要遵守)3.类名最好容易识别，见名知意。(不是语法要求但需要遵守) 类体说明 :1.类声明后的一对大括号{ }以及它们之间的内容成为类体，大括号之间的内容称为类体的内容。2.类体由两个部分构成:一部分是变量的声明，用来刻画属性;另一部分是方法的定义，用来刻画功能。举个栗子:123456789class Trapezoid&#123; float 上底,下底,高,laderArea; //变量声明，刻画属性 float 计算面积()&#123; //方法定义，刻画功能 laderArea = (上底+下底)*高/2.0f; &#125; void 修改高(float h)&#123; 高 = h; &#125;&#125; 成员变量和局部变量变量的有效范围 在变量声明部分声明的变量被称为类的成员变量，在方法体中声明的变量和方法的参数被称为局部变量。当然，成员变量和局部变量的类型可以时Java中的任何一种数据类型。 成员变量在整个类内都有效，局部变量只在声明它的方法内有效。 方法参数在整个方法内有效，方法内的局部变量从声明他的位置之后开始有效。 如果局部变量的声明是在一个复合语句中，那么该有效范围的有效范围就是该复合语句，即仅在该复合语句中有效。 如果局部变量的声明是在一个循环语句中，那么该局部变量的有效范围是该循环语句，即仅在循环语句中有效。举个栗子:123456789101112public class A&#123; int m = 10,sum = 0; //成员变量，在整个类中有效 void f()&#123; if(m&gt;9)&#123; int z = 10; //z仅仅在该复合语句中有效 z = 2*m + z; &#125; for(int i = 0;i&lt;m;++i)&#123; sum += i; //i仅在该循环语句中有效 &#125; &#125;&#125; 实例变量与类变量在声明成员变量前，用关键词static给予修饰的称作类变量(静态变量)，否则称之为实例变量(对象变量)。类变量是所有对象共有，其中一个对象将它的值改变，其他对象得到的就是改变后的结果；而实例变量则属于对象私有，某一个对象将其值改变，不影响其他对象。举个栗子：1234567891011121314class Dog&#123; float x = 0; //实例变量 static int y = 0; //类变量(静态变量)&#125;public class A&#123; public static void main(String[] args)&#123; Dog a1 = new Dog(); Dog a2 = new Dog(); a1.x = 3.0f; a1.y = 4; //等同于 Dog.y = 4; System.out.println(a2.y); //结果为4 System.out.println(a2.x); //结果为0 &#125;&#125; 成员的隐藏如果局部变量的名字与成员变量的名字相同，则成员变量被隐藏，即这个成员变量在这个方法内失效。例如:1234567class Tom&#123; int x = 99,y; void f()&#123; int x = 3; y = x; //y得到的值为3，而不是99 &#125;&#125; 如果仍希望在该方法中使用隐藏的成员变量，需要用到关键词this,比如这样:1234567class Tom&#123; int x = 99,y; void f()&#123; int x = 3; y = this.x; //y得到的值为99,而不是3 &#125;&#125; 变量书写风格虽然其中的一些要求不是语法要求，但是还是希望大家能够遵守，养成良好的变成习惯。 一行只声明一个变量(便于给代码添加注释)。 变量的名字符合标识符的规定。 变量的名字见名知意，避免容易混淆的变量的名字，也尽量不要用a1,a2这种方式。 方法最基本的方法包括方法名和方法的返回类型，并且很多方法声明中都给出了方法的参数，例如:123float area(int a,float b,...)&#123;//参数可以省略，根据需要填写 ...//方法体&#125; 方法的参数和返回类型可以是任意的Java数据类型，不需要返回类型时要用void。方法声明之后的一对大括号”{“、”}”以及之间的内容称为方法体。方法体内包括局部变量的声明和Java语句。写一个方法完全类似于C++里面的函数，只不过是面向对象语言中的称呼。 方法重载前面说过，Java中存在两种多态，即重载和重写，重写是和继承有关的多态，将在以后的博客中讨论。方法重载是多态性的一种，所谓功能多态性，是指可以向功能传递不同的消息，以便让对象根据相应的消息产生相应的行为。方法重载的意思是，一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同(1.参数个数不同 2.参数类型不同)。举个栗子:1234567891011121314class Lin&#123; float getArea(float r)&#123; return 3.14f*r*r; &#125; double getArea(float x,float y)&#123; return x*y; &#125; float getArea(int x,float y)&#123; return x*y; &#125; double getArea(float x,float y,float z)&#123; return (x*x+y*y+z*z)*2.0; &#125;&#125; Notice: 方法的返回类型和参数的名字不参与比较，所以说，方法重载需要保证参数个数或者参数类型的不同！！！ 构造方法和C++相同，当我们创建一个对象时，会调用构造方法进行初始化。构造方法也是一种特殊的方法， 它的名字必须与它所在类的名字完全相同 ,不需要写类型，也可以重载。举个栗子:12345678910111213class Trapezoid&#123; float 上底，下底，高; Trapzoid()&#123; //构造方法 上底 = 60; 下底 = 100; 高 = 20; &#125; Trapzoid(float x,int y,float z)&#123; //构造方法 上底 = x; 下底 = y; 高 = z; &#125; &#125; 实例方法与类方法和实例变量和类变量一样，类中的方法也分为实例方法和类方法。在声明方法时，方法类型前面不加关键字static修饰的是实例方法，加static的是类方法(静态方法)。举个例子:123456789class A&#123; int a; float b(int x,float y)&#123; //实例方法 &#125; static void speak(String s)&#123; //类方法 &#125;&#125; 想了解实例方法和类方法的区别请点击：实例方法和类方法的区别传送门 Notice: 对成员变量的操作只能放在方法中，方法可以对成员变量和该方法体中声明的局部变量进行操作。当然，在声明类的成员变量时可以同时赋予初值。 实例方法既能对类变量操作也能对实例变量进行操作，而类方法只能对类变量进行操作。 123456789101112class A&#123; int a; //实例变量 static int b; //类变量 void f(int x,int y)&#123; //实例方法 a = x; //true b = y; //true &#125; static void g(int z)&#123; b = 23; //true a = z; //False &#125;&#125; 一个类中的方法可以相互调用，实例方法可以调用该类中的其他方法；类中的类方法只能调用该类的类方法，不能调用实例方法。]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java语句基础]]></title>
    <url>%2FJava%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5%E4%BA%8C.html</url>
    <content type="text"><![CDATA[语句概述Java中的语句可分为以下六类。(1)方法调用语句。例如System.out.pritln(&quot;x1aolin&quot;)(2)表达式语句。即由一个表达式构成的语句。(3)复合语句。和C++一样，Java中也可以用{ }把一些语句括起来构成符合语句。(4)空语句。由一个分号构成的语句。(5)控制语句。条件分支语句，开关语句，和循环语句，下面会有简单介绍。(6)package语句和import语句。它们和类，对象有关，将在后续的blog中进行介绍。 条件分支语句主要分为if语句，if-else语句，if-else if-else语句。和C++用法完全一致，此处仅给出其相应的格式。语法格式如下:123456789101112131415161718192021if(表达式)&#123;若干语句&#125; //if语句语法格式if(表达式)&#123;若干语句&#125;else&#123;若干语句&#125; //if-else语法格式if(表达式)&#123;若干语句&#125;else if(若干语句)&#123;若干语句&#125;...else&#123;若干语句&#125; //if-else if-else语法格式 开关语句也就是switch case 语句，格式如下:12345678910111213141516switch(表达式)&#123; case 常量1: 若干语句 break; //可选，下面会讲述break的作用 case 常量2: 若干语句 break; //可选，下面会讲述break的作用 ... case 常量n: 若干语句 break; //可选，下面会讲述break的作用 default: 若干语句&#125; 注意 : “表达式”的值必须为byte、short、int、char型或枚举类型，他们当中的常量值也必须为上述类型且须各不相同。 switch语句首先计算表达式的值，计算结果对应case后面的变量值，并执行其后面对应的语句，直到碰到break为止，也就是说如果对应的case语句结尾没有break，那么程序就会执行紧随其后的一个case当中的内容。 循环语句1.for循环语句语法格式:123for(表达式1;表达式2;表达式3)&#123; 若干语句&#125; 说明 :(1)“表达式1”负责完成变量的初始化。(2)“表达式2”是boolean型的表达式，称为循环条件。(3)“表达式3”用来修饰变量，改变循环条件。 2.while语句和do-while语句不再多说break和continue语句(1)break和continue语句是用关键字break和continue加上分号构成的语句。(2)如果在某次循环中执行了break语句，那么整个循环语句就结束。(3)如果在某次循环中执行了continue语句，那么本次循环结束，不再执行continue后面的语句，转入进行下一次循环。 数组和for语句Java的JDK1.5版本对for语句的功能给予扩充、增强，以便更好的遍历数组。其语法格式如下:1234for(声明循环变量:数组的名字)&#123;... &#125;!!! 注意声明的循环变量类型必须和数组的类型相同 举例如下：12345678910111213141516171819202122public class x1ao&#123; public static void main(String argv[])&#123; int[] a = &#123;1,5,7,8&#125;; char b[] = &#123;'l','i','n','r'&#125;; //传统打印方式 for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+" "); &#125; for(int i=0;i&lt;b.length;++i)&#123;//上面有提到++x和x++的区别 System.out.print(b[i]+" "); &#125; System.out.println(); //美观换行 //改进方式 for(int j:a)&#123;//循环变量j依次取数组的每一个元素值 System.out.print(j+" "); &#125; for(char ch:b)&#123; System.out.print(ch+" "); &#125; System.out.println(); //美观换行 &#125;&#125; 运行结果如下，有问题请在评论区留言:12345x1aolin@x1aolin-E402NA:~/桌面/javaExample$ vim x1ao.javax1aolin@x1aolin-E402NA:~/桌面/javaExample$ javac x1ao.java x1aolin@x1aolin-E402NA:~/桌面/javaExample$ java x1ao1 5 7 8 l i n r 1 5 7 8 l i n r]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java运算符、表达式和语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java运算符相关]]></title>
    <url>%2FJava%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5%E4%B8%80.html</url>
    <content type="text"><![CDATA[说明： 因为这一块和C语言的规则相差无几，所以此处不会重点描述，只说明一下其中的重点和与C不同的部分。 instanceof运算符该运算符为二目运算符，左边的操作单元是一个对象，右边的是一个类。当左边的对象时右边的类或者子类创建的对象时，该运算符运算的结果时true,否则为false。 自增自减运算符此处仅以（++X）和（X++）为例。粗略的看，++x 和 x++ 的作用都是使x+1。但是++x是先执行x=x+1，然后再使用x的值，而x++是先使用x的值然后再执行x=x+1。举个栗子:123x = 5; //仅给出部分代码显示其功能y = ++x; // y的值为6z = x++; // z的值为5 运算符优先级与结合性 优先级 描述 运算符 结合性 1 分隔符 [ ] ( ) . , ; 2 对象归类，自增，自减函数，逻辑非 instanceof, ++, –, ! 从左到右 3 算数乘除运算 *, /, % 从左到右 4 算数加减运算 +, - 从左到右 5 移位运算 &gt;&gt;, &lt;&lt;, &gt;&gt;&gt; 从左到右 6 大小关系运算 &lt;, &lt;=, &gt;, &gt;= 从左到右 7 相等关系运算 ==, != 从左到右 8 按位与运算 &amp; 从左到右 9 按位异或运算 ^ 从左到右 10 按位或运算 &#124; 从左到右 11 逻辑与运算 &amp;&amp; 从左到右 12 逻辑或运算 &#x7C;&#x7C; 从左到右 13 三木条件运算 表达式?语句1:语句2 从左到右 14 赋值运算 = 从右到左]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java运算符、表达式和语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java枚举类型]]></title>
    <url>%2FJava%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[声明枚举类型java使用关键字 enum 声明枚举类型，语法格式如下:123enum 枚举名&#123; 常量列表&#125; 其中的“常量列表”是用逗号分隔的字符序列，称为枚举类型的常量(需符合标识符规定)。例如:123enum x1ao&#123; one,two,three,four&#125; 声明枚举变量 声明了一个枚举类型后，就可以用该枚举类型的枚举声明一个枚举变量了。例如:1x1ao x; //用到了上面的声明 这样，枚举类型就可以使用枚举名和”,”运算符获得枚举类型中的常量。1x = x1ao.one; //这时候使用System.out.println(x)就可以显示one字符串 说明与举例可以在一个Java源文件中声明、定义枚举类型，然后保存源文件，最后单独编译源文件得到枚举类型的字节码文件，那么该字节码就可以被其他源文件中的类使用。下面给出示例: Weekday.java文件123public enum Weekday&#123; 星期一,星期二,星期三,星期四,星期五,星期六,星期日&#125; Example7.java123456789public class Example7&#123;//文件名随便起，限制条件请分类查找java第一篇博客 public static void main(String args[])&#123; Weekday x = Weekday.星期日; if(x==Weekday.星期日)&#123; System.out.println(x); System.out.println("今天我休息！"); &#125; &#125;&#125; 下面给出运行结果，大家可以自己运行试试,复制代码后将中文逗号等字符改成英文状态！！！1234x1aolin@x1aolin-E402NA:~/桌面$ javac Example7.java x1aolin@x1aolin-E402NA:~/桌面$ java Example7星期日今天我休息！ 补充:枚举类型与for，switch数组 除了上面所说，枚举类型可以用枚举类型的名字.values()返回一个数组，该数组的值与该枚举类型中的常量一一对应。 jdk1.5后的版本允许switch语句中表达式的值是枚举类型。]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java从命令行输入和输出数据]]></title>
    <url>%2FJava%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE.html</url>
    <content type="text"><![CDATA[输入基本型数据 在Java基本类型介绍 一节中提到，Java程序都是由若干个类组成的，所以输入也是一个类。 Scanner类Scanner类用与创建一个对象:Scanner reader = new Scanner(System.in) 然后reader对象可通过以下函数对应读取用户在命令行输入的各种基本类型:nextBoolean(),nextByte(),nexyShort(),nextInt(),nextLong(),nextFloat(),nextDouble() 注意：上述方法在执行时都会发生堵塞，程序等待用户在命令行输入数据并按Enter确认。 下面通过一个实例加深以下理解:123456789101112131415161718import java.util.Scanner;public class Example2&#123; public static void main(String args[])&#123; System.out.println("请输入若干个数，每输入一个数回车确认"); System.out.println("最后输入数字-9999结束输入操作"); Scanner lll = new Scanner(System.in); double sum = 0; int m = 0; double x = lll.nextDouble(); while(x!=-9999)&#123; m+=1; // m = m + 1; sum+=x; // sum = sum + x; x = lll.nextDouble(); &#125; System.out.println(m+"个数的和为"+sum); System.out.println(m+"个数的平均值为"+sum/m); &#125;&#125; 运行结果如下，其余自行体会：12345678910x1aolin@x1aolin-E402NA:~/桌面$ java Example2请输入若干个数，每输入一个数回车确认最后输入数字-9999结束输入操作3456-99994个数的和为18.04个数的平均值为4.5 输入基本型数据三种类型：1234System.out.println() //1System.out.print() //2 二者的区别是1号代码输出数据后换行，2号不换行System.out.printf("格式控制部分"，表达式1，表达式2，...,表达式n)//类似c语言 注意事项: 使用时不可以采取回车操作 12345System.out.println("你好， 很高兴认识你"); // !!! 错误示范System.out.println("你好," + "很高兴认识你"); // !!! 正确示范字符串过长时用并置符号 + 将其首尾相连 在java中，允许使用并置符号 + 将变量、表达式或一个常数值与一个字符串并置在一起输出 对于上述第三种输出方法，有以下格式：(1)%d: int型数据(2)%f: 浮点型数据，小数部分最多保留6位。(3)%c: char型数据(4)%s: 字符串数据(5)%md:输出的int数据占据m列(6)%m.nf:输出的浮点型数据占据m列，小数点保留n位(小数点也会占一列)例如： 1System.out.println("%d %f",12,23.78);]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数组的用法]]></title>
    <url>%2FJava%E6%95%B0%E7%BB%84.html</url>
    <content type="text"><![CDATA[声明数组 一维数组声明格式：(1) 数组的元素类型 数组名称[ ];(2) 数组的元素类型[ ] 数组名称; 二维数组声明格式：(1) 数组的元素类型 数组名称[ ][ ];(2) 数组的元素类型[ ][ ] 数组名称;举例:123float boy[]; // 等价于 float[] boy;char cat[][]; // 等价于 char[][] cat; 注意 :(1) 数组boy的元素类型可以是Java中的任何一种类型。假如已经声明了一个Hello类型，那么就可以声明一个数组: Hello hh[];(2) 与C不同，Java不允许在声明数组的方括号内指定数组的方括号内指定数组元素个数。int a[6]或int[8] b等都会导致语法错误。 创建数组及初始化 声明数组仅仅是给出了数组名字和元素的数据类型，如果想要使用还必须为它分配内存空间，即创建数组。 静态初始化: 即定义数组的同时对数组进行初始化。举例: 1int[] a=&#123;1,2,3,4,5&#125;; //这样就间接创建了一个拥有5个元素的数组 动态初始化: 使用运算符new为数组分配空间。格式为：数组名字 = new 数组元素的类型[数组元素的个数]举例: 123int a[]; //声明a = new int[5]; //创建一个元素值为五个的数组a[0]=1; a[1]=2; a[2]=3; a[3]=4; a[4]=5; //同上面静态初始化的值 声明数组和创建数组可以一起完成 123float xiao[] = new float[5]; //一维数组的创建int lin[][] = new int[4][3]; //当然也可以分开，先声明后创建 Java采用“数组的数组”声明多维数组，即一个二维数组是由若干个一维数组组成的，比如上述创建的二维数组lin就是由4个长度为3的一维数组lin[0],lin[1],lin[2],lin[3]构成的。 !!! 构成二维数组的一维数组不必要有相同的长度，在创建二维数组时可以分别指定构成该二维数组的一维数组的长度。 1234567int lin[][] = new int[4][]; //未完成创建数组，该数组还不能使用 lin[0] = new int[1];lin[1] = new int[2];lin[2] = new int[3];lin[3] = new int[4]; //完成，一维数组大小我是随意定的//也可以使用下面的方式int lin[][] = &#123;&#123;9&#125;,&#123;2,5&#125;,&#123;8,9,4&#125;,&#123;3,2,1,7&#125;&#125;;//分配内存大小和上面相同 数组变量a中存放着这些内存单元的首地址，该地址称作数组的引用。 数组元素的使用 一维数组通过索引符访问自己的元素。注意索引符从0开始，若数组有10个元素，那么索引为0~9。 二维数组也是如此。举个栗子给大家尝尝:123int lin[][] = new int[4][3]; //第一个索引为0~3，第二个索引为0~2lin[3][2] = 12; lin[0][0] = 1; length的使用 说明: 数组的元素个数称为数组的长度。 对于一维数组，“数组名字.length”的值就是数组中元素的个数; 对于二维数组，“数组名字.length”的值为它含有的一维数组的个数。123float xiao[] = new float[5]; //xiao.length的值为5 int lin[][] = new int[4][3]; //lin.length的值为4 数组的引用 数组为引用型变量，因此，两个相同类型的数组如果具有相同的引用，它们就会有完全相同的元素。 对于 :123int a[] = &#123;1,2,3&#125;; int b[] = [4,5]; a = b; // a,b类型必须相同 如果这么处理，a中存放的引用和b的相同，系统将释放最初分配给数组a的元素，使得a的元素和b的元素相同。举个栗子做个小小的总结：12345678910111213141516import java.util.Arrays; //输出数组，下面会讲到public class Example3&#123; public static void main(String args[])&#123; int a[] = &#123;1,2,3&#125;; int b[] = &#123;4,5&#125;; System.out.println("数组a的元素个数 = "+a.length); System.out.println("数组b的元素个数 = "+b.length); System.out.println("数组a的引用 = "+a); System.out.println("数组a的引用 = "+b); System.out.println("a==b的结果为 "+(a==b)); a = b; System.out.println("数组a的元素个数 = "+a.length); System.out.println("数组b的元素个数 = "+b.length); System.out.println("a==b的结果为 "+(a==b)); System.out.println("a数组:"+Arrays.toString(a)); System.out.println("b数组:"+Arrays.toString(b)); 运行结果如下,其余自行体会:1234567891011x1aolin@x1aolin-E402NA:~/桌面$ java Example3数组a的元素个数 = 3数组b的元素个数 = 2数组a的引用 = [I@c39f790数组a的引用 = [I@71e7a66ba==b的结果为 false数组a的元素个数 = 2数组b的元素个数 = 2a==b的结果为 truea数组:[4, 5]b数组:[4, 5] 复制数组 通过上面的讲述我们知道，数组属于引用类型，所以在复制数组的时候不能简单的执行b=a这类代码。因为此操作只能使他们指向相同的内存单元，此时改变a[1]也就是改变了b[1],并不是实际的复制了数组。 下面介绍Java中三种复制方法，各有利弊，请自行评判。 1.arraycopy方法利用循环把一个数组的元素的值赋给另一个数组中的元素。这里用System类调用方法:1public static void arraycopy(sourceArray,int index1,copyArray,int index2,int length) 可以将数组sourceArray从索引index1开始的length个元素中的数据复制到数组copyArray中，copyArray数组从第index2元素开始存放这些数据，如果数组copyArray不能存放下复制的数据，程序运行将会发生异常。下面给出示例：12345678910111213141516171819import java.util.Arrays;public class Example4&#123; public static void main(String args[])&#123; char a[] = &#123;'a','b','c','d','e','f'&#125;; char[] b = new char[6]; b[0]='1';b[1]='2';b[2]='3';b[3]='4';b[4]='5';b[5]='6'; int[] c; c = new int[6]; c[0]=1;c[1]=2;c[2]=3;c[3]=4;c[4]=5;c[5]=6; int d[] = &#123;10,20,30,40,50,60&#125;; //复习前面的内容 System.arraycopy(a,0,b,0,a.length); System.arraycopy(c,2,d,2,(c.length-3)); System.out.println("数组a:"+Arrays.toString(a)); System.out.println("数组b:"+Arrays.toString(b)); System.out.println("数组c:"+Arrays.toString(c)); System.out.println("数组d:"+Arrays.toString(d)); &#125;&#125; 运行结果如下:1234567x1aolin@x1aolin-E402NA:~/桌面$ vim Example4.javax1aolin@x1aolin-E402NA:~/桌面$ javac Example4.java x1aolin@x1aolin-E402NA:~/桌面$ java Example4数组a:[a, b, c, d, e, f]数组b:[a, b, c, d, e, f]数组c:[1, 2, 3, 4, 5, 6]数组d:[10, 20, 3, 4, 5, 60] 缺点: 事先必须创建参数copyArray指定的数组。 2.copyOf和copyOfRange方法Array类用copyOf调用方法有:1234public static double[] copyOf(double[] original,int newLength)public static float[] copyOf(float[] original,int newLength)public static int[] copyOf(int[] original,int newLength)public static char[] copyOf(char[] original,int newLength) 可以把参数original指定的数组中从索引0开始的newLength个元素复制到一个新数组中，并返回这个新数组，且该新数组的长度为newLength。如果newLength的值大于original的长度，则其余的用0补齐。 Array类用copyOfRange调用方法有:1234public static double[] copyOfRange(double[] original,int from,int to)public static float[] copyOfRange(float[] original,int from,int to)public static int[] copyOfRange(int[] original,int from,int to)public static char[] copyOfRange(char[] original,int from,int to) 复制部分值。把参数original指定的数组中从索引from至to-1的元素复制到一个新数组中，并返回这个新数组，即新数组的长度为to-from。当然，如果新数组比原数组长，则多的那个部分补0。示例如下:12345678910111213import java.util.*;public class Example5&#123; public static void main(String args[])&#123; int[] a = &#123;10,20,30,40,50,60&#125;,b,c,d; b = Arrays.copyOf(a,10); System.out.println("数组a:"+Arrays.toString(a)); System.out.println("数组b:"+Arrays.toString(b)); c = Arrays.copyOfRange(a,2,5); System.out.println("数组c:"+Arrays.toString(c)); d = Arrays.copyOfRange(a,3,9); System.out.println("数组d:"+Arrays.toString(d)); &#125;&#125; 运行结果如下,其余自行体会:1234567x1aolin@x1aolin-E402NA:~/桌面$ vim Example5.java //ubuntu命令行的操作x1aolin@x1aolin-E402NA:~/桌面$ javac Example5.java x1aolin@x1aolin-E402NA:~/桌面$ java Example5数组a:[10, 20, 30, 40, 50, 60]数组b:[10, 20, 30, 40, 50, 60, 0, 0, 0, 0]数组c:[30, 40, 50]数组d:[40, 50, 60, 0, 0, 0] 补充1:数组的表示格式 前提: 引用 import java.util.Arrays，以后的博客中会讲到。 除了向C/C++中一样用循环输出数组的值外，JDK1.5版本提供了一个简单的输出元素值的放大。让Arrays类调用:public static String toString(int[] a)方法，可以得到参数指定的一维数组a的数据，格式如下:[a[0],a[1],a[2], ... ,a[a.length-1]]示例在上面“数组的引用”模块已经给出，此处不再示例。 补充2:Java数组排序这里重点说明Arrays类调用方法实现对数组的快速排序。两种调用方法:public static void sort(double a[])public static void sort(double a[],int start,int end) 补充3:对已排序数组进行二分查找public static int binarySearch(double[] a,double number)判断参数number指定的数是否在参数a指定的数组中，如果number在数组中，返回该元素的索引，如果找不到便返回一个负数。示例如下:12345678910111213141516import java.util.*;public class Example6&#123; public static void main(String args[])&#123; int []a = &#123;5,8,2,1,9,3,6,4,7&#125;; Arrays.sort(a); System.out.println(Arrays.toString(a)); int number = 6; int index = Arrays.binarySearch(a,number); if(index&gt;=0)&#123; System.out.println(number+"和数组中的索引为"+index+"的元素值相同"); &#125; else&#123; System.out.println(number+"不与数组中的任何元素值相同"); &#125; &#125;&#125; 运行结果如下，其余自行体会12345x1aolin@x1aolin-E402NA:~/桌面$ vim Example6.javax1aolin@x1aolin-E402NA:~/桌面$ javac Example6.java x1aolin@x1aolin-E402NA:~/桌面$ java Example6[1, 2, 3, 4, 5, 6, 7, 8, 9]6和数组中的索引为5的元素值相同]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基本类型介绍]]></title>
    <url>%2FJava%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[说明: 关于编译环境，安装相应的IDE等相关知识本文不会介绍，请自行百度 标识符和关键字标识符定义 : 用来标识类名、变量名、方法名、类型名、数组名、文件名的有效字符序列。 语法规则 :(1) 由字母、下划线、美元符号$、数字构成，长度无限制。(2) 第一个字符不可以是数字字符。(3) 不可以是关键字(关键字会在后续说明)。(4) 不可以是true、false、null这三个字符。(5) Java为强类型语言，所以严格区分大小写。(6) 使用比ASCII码更广泛的Unicode字符集，所以在(1)中所说的“字母”包含部分简体中文。 关键字说明 : 关键字就是Java中被赋予特定意义的单词。下面给出部分示例:123abstract; assert; boolean; break; byte; case; catch; char; class; const; continue default; do; double; else; enum; extends; final; ... //分号表示间隔 分隔符1.注释符 :(1)// 单行注释(以双斜杠开始，终止于行尾，注释一行，可放在语句后面)(2)/* */ 多行注释( /*开始，*/结束，中间可写多行)(3)/**开始，*/结束，这种注释主要是为了支持JDK工具javadoc而采用的。 2.空白符 :空格，回车，换行，制表符tab等。 为增强代码的可读性而建立，系统编译时会忽略它。 3.普通分隔符 :点号，分号，冒号，大括号，方括号，小括号。因为和C/C++用法相同，此处不再赘述。 基本数据类型Java语言有八中基本数据类型，习惯上可以分为四大类: 逻辑类型: boolean 整数类型: byte 、short 、int 、long 字符类型: char 浮点类型: float 、double 逻辑类型常量: true 、false变量: 使用关键字boolean来声明。 整数类型 十进制用数字1~9开头，八进制用数字0开头，十六机制用0x开头。 因为基本上和C语言差不多，稍微有点编程基础就可以理解，此处就不再赘述。重点讲一下和C语言不同的地方:(1)Java中不存在byte和short的常量表示法，但是可以把一定范围内的int型常量赋值给byte或short型变量。(2)long型常量用后缀L来表示，如108L。(3)这四个不同的类型区别：只是声明时系统分配予其内存的大小和其所能表示数的范围大小。 整数类型 所占字节数 所占位数 取值范围 int型 4 byte 32 bit -231~2^31-1 byte型 1 byte 8 bit -27~27-1 short型 2 byte 16 bit -215~215-1 long型 8 byte 64 bit -263~263-1 字符类型这里的char是相对Unicode来说的，所以 申请时系统分配给两个字节，占16位，最高位不是符号位，没有负数的char。char类型的取值范围是0~65535。1234567// 情况 1char x = 'a';char x = 97; //两者是等价的，因为97就是a字符在Unicode表当中的位置// 情况 2 char ch1 = '\n';char ch2 = '\"';char ch3 = '\\'; //有些字符只能通过转义字符进行输入 说明 : 要观察一个字符在Unicode表中的顺序位置，可以使用int型显式转换，如(int)&#39;a&#39;或int p = &#39;a&#39;。如果要得到一个0~65536的数所代表的Unicode表中相应位置上的字符，需使用char显式转换，示例如下:12345678910public class Test&#123; public static void main(String args[])&#123; char ch1 = 'w',ch2 = '好'; int p1 = 32831,p2 = 30452; System.out.printIn("\""+ch1+"\"的位置:"+(int)ch1); System.out.printIn("\""+ch2+"\"的位置:"+(int)ch2); System.out.printIn("第"+p1+"个位置上的字符是:"+(char)p1); System.out.printIn("第"+p2+"个位置上的字符是:"+(char)p2); &#125;&#125; 有兴趣的同学可以在自己的编译器下跑跑试试。 浮点类型float型(1) float定义常量时，常量后面必须要有后缀f或F。(2) float变量在存储float类型数据时保留8位有效数字，实际精度取决于具体数值。 double型保留16位有效数字，实际精度取决于具体数值。其与float的比较如下: 浮点类型 所占字节数 所占位数 取值范围 float型 4 32 10-38~1038和-1038~10-38 double型 8 64 将上面38换成308 基本数据类型的转换 将上述类型按照精度从低到高排序为 byte,short,char,int,long,float,double 当把级别低的变量的值=&gt;级别高的变量时，系统会自动完成数据类型的转换。 当把级别高的变量的值=&gt;级别低的变量时，需要用到强制转换,即显式类型转换运算，格式为: (类型名)要转换的值。 强制转换会造成“精度损失”或“数据溢出”。例如:1234float i = 10.1;double l = i; //自动转换byte b = (byte)i; //强制转换,精度损失 b = 10byte c = (byte)128; //数据溢出，c = -128 常见错误: 把一个double型常量赋值给float常量时未进行强制转换.错误示范: float x = 12.4正确做法: float x = (float)12.4 或者 float x = 12.4f 下面用一段代码总结一下上面所讲的内容:12345678910111213141516171819public class Example&#123; public static void main(String args[])&#123; int c = 128; long d = 77777; float f = 2e3f; double g = 3.14e-300; //指数表示法 double result = f*g; System.out.println("f= "+f); System.out.println("g= "+g); System.out.println("result= "+result); g = 1234.12345678; c = (int)d; f = (float)g; System.out.println("c= "+c); System.out.println("d= "+d); System.out.println("f= "+f); System.out.println("g= "+g); &#125;&#125; 运行结果如下:12345678x1aolin@x1aolin-E402NA:~/桌面$ java Examplef= 2000.0g= 3.14E-300result= 6.28E-297c= 77777d= 77777f= 1234.1234g= 1234.12345678]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序开发步骤]]></title>
    <url>%2FJava%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4.html</url>
    <content type="text"><![CDATA[从今天开始，我们进入到Java的基础课学习，这个教程的前提时有一点编程基础，比如C/C++，请大家做好心理准备。 编写源文件可以使用IDE，现今存在的IDE也有很多，大家可以根据自己的喜好去选择不同的IDE。但是本文主要时说明开发步骤，所以本文使用Liunx系统的vim进行编辑。Windows系统的小伙伴也可以使用记事本等文本文件进行源文件的编写。注意 : 在对文件进行命名的时候，源文件的拓展名必须为.java。 编译源文件定义： 使用Java编译器(javac.exe)编译源文件，得到字节码文件。格式： javac 文件名.java 运行程序使用Java平台中的Java解释器(java.exe)来解释、执行字节码文件。格式： java 文件名 //注意不要有添加后缀 一些注意事项 在Java源程序中，语句所涉及的小括号以及标点符号都是在英文状态下输入的，而字符串里面的符号不受限制。 如果源程序中有多个类，那么只能有一个public类; 如果有一个类是public类，那么源文件的名字必须与这个类的名字完全相同，拓展名为.java; 如果源文件没有public类，那么源文件的名字只要和某个类的名字相同，并且拓展名时.java就可以了。 如果源文件中包含多个类，编译源文件将生成多个拓展名为.class的文件，在每个拓展名为.class的文件中只存放一个类的字节码，其文件名与该类的名字相同，这些字节码文件被存放在与源文件相同的目录中。 ！！！一个Java应用程序必须有一个类含有 public static void main(String args[])方法，称这个类为应用程序的主类。 运行Java程序的时候注意：Java应用程序总是从主类的main方法开始执行，因此，需要进入主类字节码所在的目录(主类名.class)。 一个Java应用程序(也称为一个工程)是由若干个类组成的，这些类可以在一个源文件中，也可以分布在若干个源文件中。 如果应用程序的主类源文件和其他源文件在同一目录中，也可以只编译主类的源文件，Java系统会自动编译主类需要的其他源文件。 Java程序以类为“基本单位”，即一个java源程序是由若干个类所构成的。 一个Java程序可以将它使用的各个类分别存放在不同的源文件当中，也可以将它使用的类存放在一个源文件当中。 如果需要编译某个目录下的多个Java文件，在使用javac时，也可以将javac要编译的多个源文件用空格分离。例如:javac Car.java Person.java。]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cpp之const的用法]]></title>
    <url>%2FCpp%E4%B9%8Bconst%E7%9A%84%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[关于const的有关知识今天先讲这些，等日后再进行补充……Tips:最后有视频推荐链接，不喜欢读文章可以看看视频。 控制变化的const 1.const与基本的数据类型如:1const int x = 3 //常量 变量名 储存地址 存储内容 x &amp;x 3 固定不变 2.const与指针类型五种定义形式:123456789const int *p = NULL; //1int const *p = NULL; //2 1和2完全等价int *const p = NULL; //3 另外一种情况const int * const p = NULL; //4 int const * const p = NULL; //5 4和5完全等价 下面我们通过例子来说明问题：1234int x = 3;const int *p = &amp;x; /*p = &amp;y; 正确,即允许让指针p再指向另外的一个地址。*p = 4; 错误，因为我们的const此时修饰的是*p */ 变量名 存储地址 存储内容 x &amp;x 3 p &amp;p &amp;x 12int x = 3;int *const p = &amp;x; //p = &amp;y; 错误，因为我们的const此时修饰的是指针p 变量名 存储地址 存储内容 x &amp;x 3 p &amp;p &amp;x 固定不变 12const int x = 3;const int *const p = &amp;x; //p = &amp;y; *p = 4;都是错误的 变量名 存储地址 存储内容 x &amp;x 3 固定不变 p &amp;p &amp;x 固定不变 3.const与引用123int x = 3;const int &amp;y = x; //x = 10;True //y = 20;False,因为y被const修饰。//y是x的别名，他们的值始终相同。所以修改x的值后y的值也被其改变。 4.总结一下1234567891011121314151617const int x = 3; x = 5; //False 常量不可以被赋值int x = 3; const int y = x; y = 5; //False y为常量，不可被赋值int x = 3; const int *y = &amp;x; *y = 5; //False const修饰的是*y.int x = 3, z = 4; int *const y = &amp;x; y = &amp;z; //False const修饰的是指针y.const int x = 3; const int &amp;y = x; y = 5; //False 前面有提到//!!! 下面看一个对比的例子const int x = 3; int *y = &amp;x; //False x比y的权限小，x有被其指针改变的风险int x = 3; int const *y = &amp;x; //True x比y的权限大，可以通过!!! 指针指向const修饰的变量时，应该是 const int *const p = &amp;x;//限制其权限 推荐大家用const来定义常量，因为相比于宏定义#define来说，使用const编译器会检查语法错误。 定义拷贝 构造函数 拷贝构造函数定义格式: 类名(const 类名&amp; 变量名)，例如:123456789class Student&#123;public: Student()&#123;m_strName = "x1aolin";&#125; Student(const Student&amp; stu)&#123;&#125; //!!!拷贝构造函数private: string m_strName;&#125;;//拷贝构造函数在实例化对象复制初始化或直接初始化时调用 const重出江湖 先从一个大家比较熟悉的例子说起: 12345678class Coordinate&#123;public: Coordinate(int x,int y);private:const int m_ix;const int m_iy;&#125;; 因为成员变量是两个常成员，所以不能用一般的构造函数进行初始化，需要用初始化列表。123Coordinate::Coordinate(int x,int y):m_ix(x),m_iy(y)&#123;&#125; 从这里可以看到，一般的对象成员是可以用const来修饰的，其实，对象成员也可以用const来修饰，我们把这类成员称为常对象成员。 1.常对象成员如果想要在类中实现对象成员一旦初始化就不允许再修改，那么就可以用const常对象成员,例如:12345678class Line&#123;public: Line(int x1,int y1,int x2,int y2);private: const Coordinate m_coorA; const Coordinate m_coorB;&#125; 初始化用实例化时传参+初始化列表进行操作。 2.常成员函数如果大家更加大胆些，就可能会想到一个问题:既然有了常对象成员，那么是否会有常成员函数？答案自然是肯定的，例如:12345678910class Coordinate&#123;public: Coordinate(int x,int y); void changeX() const; // &lt;--- 常成员函数 1 void changeX(); // 2 1和2互为重载private: int m_ix; int m_iy;&#125; 常对象就只能调用常成员函数，而非常对象就都可以调用。但是类似重载的情况就只能实例化一个常对象来进行调用常成员函数了。 在重载情况下调用常对象成员示例:123456int main()&#123; const Coordinate coor(1,2);// &lt;--- 常对象的定义方法 coor.changeX(); //此时调用的changeX()函数就是常成员函数了 return 0;&#125; !!! 常成员函数中不可以修改数据成员的值。 在上一次的博客:this的用法中已经详细介绍了关于this应该如何运用，这里不在赘述。1234void Coordinate::changeX() const&#123; m_ix = 10; //False 这是不被允许的，原因下面有。&#125; 其实上面的代码可以理解为:1234void changeX(const Coordinate *this)&#123; this-&gt;m_ix = 10; //上面也提到常指针是不可以改变的，所以不被允许。&#125; 定义常成员函数的方法:在.h文件中，在普通成员函数声明后面加上 const ，然后在其对应的.cpp文件定义中的对应定义函数后面加上 const 后面。注意在函数括号后面加一个小空格，防止编译错误。 如果大家对常对象和常成员函数还是很模糊，点击传送门,深入理解。 3.常指针与常引用示例的前提条件:1234567891011class Coordinate&#123;public: Coordinate(int x,int y); int getX(); int getY(); void printInfo() const; //注意这个是常成员函数private: int m_iX; int m_iY;&#125;; 下面我们来看看对象的引用和对象的指针如何来定义:12345678910int main()&#123; Coordinate coor1(3,5); Coordinate &amp;coor2 = coor1; //&lt;---对象的引用 Coordinate *pCoor = &amp;coor1; //&lt;---对象的指针 coor1.printInfo(); coor2.printInfo(); pCoor-&gt;printInfo(); return 0;&#125; 仿照上述代码即可实现对象的引用和指针，需要注意的是，使用对象的引用时，可将对象直接赋值给其”别名” ；使用对象的指针时，需要将对象取地址(即加取地址符号&amp;)进行赋值。正如大家所想，如果我们在定义它们的指针和引用时，在其前面加上const就是常对象和常指针了,示例如下:12345678910int main()&#123; Coordinate coor(3,5); const Coordinate &amp;coor2 = coor1; //&lt;---对象的常引用 const Coordinate *pCoor = &amp;coor1; //&lt;---对象的常指针 coor1.printInfo(); coor2.printInfo(); pCoor-&gt;printInfo(); return 0;&#125; !!! 常引用和常指针只有读权限，没有写权限，只能调用它的常成员函数。 下面看一个更加复杂的例子:12345678910int main()&#123; Coordinate coor1(3,5); Coordinate coor2(7,9); Coordinate * const pCoor = &amp;coor1; pCoor-&gt;getY(); //1 需要读写权限对象调用 pCoor = coor2; //2 pCoor-&gt;printInfo(); //3 仅需要读权限的对象就可以调用 return 0;&#125; 下面我们分析一下上面这几行代码,有哪个是错误的。首先看第三行定义代码，所在的位置是在const后面，所以意味着这个pCoor指针不能再指向其他的对象，但是它的权限时同时具备读和写的。所以1是对的,2是错的,3也是对的。 const最重要的是可以使读写权限转变成只读权限*。 推荐视频: 第一部分视频连接: 控制变化的const 第三部分视频链接: 常对象成员和常成员函数,常指针与常引用 tips:可能需要登录才可以看视频。]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白如何在ubuntu上进行C++开发]]></title>
    <url>%2F%E5%B0%8F%E7%99%BD%E5%A6%82%E4%BD%95%E5%9C%A8ubuntu%E4%B8%8A%E8%BF%9B%E8%A1%8CC-%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[对于初入ubuntu开发的小白来说，这的确是一个严峻的挑战。当然，在linux下的IDE也很多，但是既然想成为一个合格的开发者，最好是要理解开发的整个过程。本文也是在查阅了大量的资料后的一个小总结，仅供大家参考。 1.编写程序本文选用的是vim，当今比较主流的一个文本编辑器。 把Vim打造成牛逼的C++ IDE 一步步将vim改造成C/C++开发环境(IDE) 其实都是大同小异啦。当然，如果你不想这么做，没人管你，不过对于那些刚刚从Windows转过来的童鞋还是很需要的。 如果你实在是想选取IDE的话，这里有很多的推荐,推荐2。 2.编译程序 说到这，就不得不提强大的gcc了，它的用法点这里。 了解的多了，就会有人产生一些疑惑，比如cc与gcc或者gcc与g++。 对于有个大型的C++工程来说，就不得不提makefile了，这个链接关于Makefile比较清晰。 支持原创请移步陈皓博客:https://blog.csdn.net/haoel/article/details/2886 当然我自己的博客也有写:跟我一起学写makefile。 3.运行程序 cd 到需要运行程序所在目录,运行命令 ./ xxx(文件名)即可。 自己编写成功的程序肯定是可以运行的，下载的程序可能会有权限问题。 权限问题解决请自己查阅资料解决。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟我一起学写makefile]]></title>
    <url>%2F%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6%E5%86%99makefile.html</url>
    <content type="text"><![CDATA[未完待续…… 写在前面作者在写本文时，着重参考了CSDN博客作者陈皓的博客，在此表示十分感谢。 对于大多数用Windows学编程的同学也许不知道makefile这个东西，因为Windows的IDE为你做了这个工作。最近打算转战Unix系统，所以在被逼无奈之下，了解了一下makefile，在此写出同大家一起分享。 Question：什么是makefile？ makefile关系了整个工程的编译规则，在一个工程中，源文件不计其数，其按照类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定那个文件需要先编译，那个文件需要后编译，那些文件需要重新编译，甚至于更加复杂的功能操作，，这里的makefile就像是一个shell脚本一样，其中也可以执行操作的命令。 makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具。 程序的编译和链接 一般来说，无论是C，C++，还是pas，首先要把源文件编译成中间代码文件，Windows下为.obj文件，Unix下是.o文件，即 Object File，这个动作叫做编译(compile)。然后再把大量的Object File合成可执行文件，这个动作叫做链接（link）。 编译时，编译器需要的是语法的正确，函数与变量的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（这里的头文件只要声明），只要所有的语法正确，编译器就可以编译出中间文件。一般来说，每个源文件都应该对应于一个中间文件。 链接时，主要是链接函数和全局变量。链接器并不管函数所在的源文件，只要函数的中间文件(Object File)，在大多数时候，由于源文件太多，对应编译生成的中间目标文件（.o）太多，而在连接时需要明显的指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”(Library File),即.lib文件，在UNIX下，是Archive File,也就是.a文件。 总而言之,源文件首先会生成中间目标文件（.obj或.o），再由中间目标文件生成执行文件。编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），你需要指定函数的Object File。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cpp之This指针]]></title>
    <url>%2FCpp%E4%B9%8BThis%E6%8C%87%E9%92%88.html</url>
    <content type="text"><![CDATA[1.this指针: 指向自身数据的指针举例如下：123456789class Array //代码1&#123;public: Array(int _len)&#123;len = _len;&#125; int getlen()&#123;return len;&#125; void setlen(int _len)&#123;len = _len;&#125;private: int len;&#125;; 这里数据成员和参数在表达相同意思时用的是不同的变量，所以如果想用相同的变量就需要一个标记来区分该变量时数据成员还是参数,即this指针。 123456789class Array //代码2&#123;public: Array(int len)&#123;this-&gt;len = len;&#125; int getlen()&#123;return len;&#125; void setlen(int len)&#123;this-&gt;len = len;&#125;private: int len;&#125;; 这样，用this指针指明了数据成员，就可以用相同的变量来进行表示了。 Question：为什么成员函数可以直接访问数据成员？ 知识准备: 对象结构在进行对多个对象实例化的时候，在内存中会定义对应多个数据成员，但是成员函数只有一份，储存在代码区。而且每个对象进行调用的时候，每个对象都能够准确无误的进行调用。大家有没有想过这是为什么呢？其实这就是this指针的功劳。 我们来看下面这个例子：123456789class Array //代码3&#123;public: Array(T *this,int _len)&#123;this-&gt;len = _len;&#125; int getlen(T *this)&#123;return this-&gt;len;&#125; void setlen(T *this,int _len)&#123;this-&gt;len = _len;&#125;private: int len;&#125;; 大家是不是发现了和第一个例子的区别？显而易见，就是每个成员函数都加了一个this指针，这样上面所提到的问题就迎刃而解了。我们设想一下，当我们去实例化一个对象并使用他们的成员函数时，this指针就代表这个对象本身的地址，也就是说当我们调用成员函数时,编译器会悄悄地把代码1转换成代码3，所以每次调用成员函数，都是改变对应对象的成员变量。 上面说了，编译器自动的为每个成员函数的参数列表都加了一个this指针, Thus，我们只需要理解就可，没有必要自己显式的写出来。 推荐视频：如何理解this指针? Tips: 看视频需要注册账号，只有注册登录才可以看视频。]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown简单用法]]></title>
    <url>%2Fmarkdown%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[本文是作者第一篇hexo博客，排版等问题不足之处请见谅。 1.Markdown官方文档及其他参考 特别感谢简书刘邓诏初的blog对本文的帮助 Markdown语法入门 官方文档详细版 2.常用语法规则标题共六级标题，用#的累计来进行区分，#号越少字号越大下面给出相应代码，如图所示： 换行和分段 换行：只需要在行末加两个空格键和一个回车 分段：段落之间空一行即可 文本样式 加粗: 加粗 斜体: 斜体 删除线: 删除线 底纹: 底纹 引用只要将文本内容之前加[ &gt;(大于号) ]即可将文本变成引用文本。 我是引用文本 图片和链接 图片格式: ! [图片描述] (链接的地址) 链接: [文本内容] (链接的地址) 如果是本地的图片可以参考: hexo生成blog本地图片插入方法 实际用时在 感叹号，中括号和小括号 之间不能有空格，这里只是为了展示效果 水平线三个[ - ]或者[ * ]都可以画出一条水平分割线 实现方式: 表格在markdown制作表格非常麻烦，必须要画出来！！！ 脚注脚注成对出现，[^1]作为标记，可以点击调至末尾注解。[^1]填写注解，不论写在什么位置，都会出现在文章的末尾。 注释注释是给自己看的，预览和发布时都不会出现。 end: 暂时先总结这些，实现了最基础的一些功能,能满足大家的一定需要，对markdown有兴趣却还没有基础的小白可以看看，大神请绕道，等日后再慢慢更新… 5月16日补充： 代码框的三种形式 两对’’’包裹 代码前面加两个空格键 代码前面加一个TAB键 让hexo代码高亮格式：123456&gt;```语言名 （比如cpp） &gt; #include &lt; iostream&gt;&gt; using namespace std;&gt; ...&gt;``` //第一行说明语言，下面是代码内容&gt; 点击这里可以查看代码高亮支持格式和化名 特别感谢：https://www.jianshu.com/p/0130ad32a08d]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim+插件实现markdown功能]]></title>
    <url>%2Fvim-%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0markdown%E5%8A%9F%E8%83%BD.html</url>
    <content type="text"><![CDATA[具体请参考：https://www.jianshu.com/p/44d31327f953里面实现了从小白到搭建好markdown的所有过程。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>示例</category>
      </categories>
      <tags>
        <tag>hello World</tag>
      </tags>
  </entry>
</search>
