<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cpp-封装篇之This指针]]></title>
    <url>%2F2018%2F05%2F17%2FCpp-%E5%B0%81%E8%A3%85%E7%AF%87%2F</url>
    <content type="text"><![CDATA[1.this指针: 指向自身数据的指针举例如下：123456789class Array //代码1&#123;public: Array(int _len)&#123;len = _len;&#125; int getlen()&#123;return len;&#125; void setlen(int _len)&#123;len = _len;&#125;private: int len; &#125;; 这里数据成员和参数在表达相同意思时用的是不同的变量，所以如果想用相同的变量就需要一个标记来区分该变量时数据成员还是参数,即this指针。123456789class Array //代码2&#123;public: Array(int len)&#123;this-&gt;len = len;&#125; int getlen()&#123;return len;&#125; void setlen(int len)&#123;this-&gt;len = len;&#125;private: int len;&#125;; 这样，用this指针指明了数据成员，就可以用相同的变量来进行表示了。 Question：为什么成员函数可以直接访问数据成员？ 知识准备: 对象结构在进行对多个对象实例化的时候，在内存中会定义对应多个数据成员，但是成员函数只有一份，储存在代码区。而且每个对象进行调用的时候，每个对象都能够准确无误的进行调用。大家有没有想过这是为什么呢？其实这就是this指针的功劳。 我们来看下面这个例子：123456789class Array //代码3&#123;public: Array(T *this,int _len)&#123;this-&gt;len = _len;&#125; int getlen(T *this)&#123;return this-&gt;len;&#125; void setlen(T *this,int _len)&#123;this-&gt;len = _len;&#125;private: int len;&#125;; 大家是不是发现了和第一个例子的区别？显而易见，就是每个成员函数都加了一个this指针，这样上面所提到的问题就迎刃而解了。我们设想一下，当我们去实例化一个对象并使用他们的成员函数时，this指针就代表这个对象本身的地址，也就是说当我们调用成员函数时,编译器会悄悄地把代码1转换成代码3，所以每次调用成员函数，都是改变对应对象的成员变量。 上面说了，编译器自动的为每个成员函数的参数列表都加了一个this指针, Thus，我们只需要理解就可，没有必要自己显式的写出来。 推荐视频：如何理解this指针? Tips: 看视频需要注册账号，只有注册登录才可以看视频。]]></content>
      <tags>
        <tag>C++面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hello World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown简单用法]]></title>
    <url>%2F2018%2F05%2F11%2Fmarkdown%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文是作者第一篇hexo博客，排版等问题不足之处请见谅。 1.Markdown官方文档及其他参考 特别感谢简书刘邓诏初的blog对本文的帮助 Markdown语法入门 官方文档详细版 2.常用语法规则标题共六级标题，用#的累计来进行区分，#号越少字号越大下面给出相应代码，如图所示： 换行和分段 换行：只需要在行末加两个空格键和一个回车 分段：段落之间空一行即可 文本样式 加粗: 加粗 斜体: 斜体 删除线: 删除线 底纹: 底纹 引用只要将文本内容之前加[ &gt;(大于号) ]即可将文本变成引用文本。 我是引用文本 图片和链接 图片格式: ! [图片描述] (链接的地址) 链接: [文本内容] (链接的地址) 如果是本地的图片可以参考: hexo生成blog本地图片插入方法 实际用时在 感叹号，中括号和小括号 之间不能有空格，这里只是为了展示效果 水平线三个[ - ]或者[ * ]都可以画出一条水平分割线 实现方式: 表格在markdown制作表格非常麻烦，必须要画出来！！！ 脚注脚注成对出现，[^1]作为标记，可以点击调至末尾注解。[^1]填写注解，不论写在什么位置，都会出现在文章的末尾。 注释注释是给自己看的，预览和发布时都不会出现。 end: 暂时先总结这些，实现了最基础的一些功能,能满足大家的一定需要，对markdown有兴趣却还没有基础的小白可以看看，大神请绕道，等日后再慢慢更新… 5月16日补充： 代码框的三种形式 两对’’’包裹 代码前面加两个空格键 代码前面加一个TAB键 让hexo代码高亮格式：123456&gt;```语言名 （比如cpp） &gt; #include &lt; iostream&gt;&gt; using namespace std;&gt; ...&gt;``` //第一行说明语言，下面是代码内容&gt; 点击这里可以查看代码高亮支持格式和化名 特别感谢：https://www.jianshu.com/p/0130ad32a08d]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim+插件实现markdown功能]]></title>
    <url>%2F2018%2F05%2F11%2Fvim-%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0markdown%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[具体请参考：https://www.jianshu.com/p/44d31327f953里面实现了从小白到搭建好markdown的所有过程。]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
