<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java之this关键字]]></title>
    <url>%2F2018%2F06%2F12%2FJava%E4%B9%8Bthis%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[稍等…..]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之static关键字]]></title>
    <url>%2F2018%2F06%2F11%2FJava%E4%B9%8Bstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[类体的定义 –&gt; 成员变量的定义 + 方法的定义。成员变量 –&gt; 实例变量 + 类变量(static) 。方法 –&gt; 构造方法 + 类方法(static) + 实例方法。类方法只能调用类方法，实例方法可调用类中的实例方法和类方法。 实例变量和类变量的区别 一个类通过使用new运算符可以创建多个不同的对象，这些对象将被分配不同的内存空间。更准确的是，不同对象的实例变量将被分配不同的内存空间，但是所有对象的这个类变量都分配给相同的一处内存，改变其中一个对象的这个类变量会影响其他对象的这个类变量,即对象共享类变量 当Java程序执行时，类的字节码文件被加载到内存，如果该类没有创建对象，类中的实例变量不会被分配到内存。但是类中的类变量是该类被加载到内存时，就分配了相应的内存空间。 如果该类创建对象，那么不同对象的实例变量互不相同，即分配不同的内存空间，而类变量不再重新分配内存，所有对象共享类变量，即所有对象的类变量是相同的一处内存空间，类变量的内存空间直到程序退出运行，才释放所占有的内存。 因为类变量的特殊性，它既可以通过某个对象访问，也可以直接通过类名访问；而实例变量只能通过对象访问。 道理比较浅显，我就不举例子啦。^_^ 实例方法和类方法的区别 方法的入口地址只分配一次，被所有对象共享，当所有的对象都不存在时，方法的入口地址才会取消。 当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址，在该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用。 对于类中的类方法，在该类被加载到内存时，就分配了相应的入口地址，所以类方法不仅可以被类创建的任何对象调用，也可以直接通过类名调用。类方法的入口地址直到程序退出才会被取消。 实例方法既能对类变量操作也能对实例变量进行操作，而类方法只能对类变量进行操作 由于类方法的特性，如果一个方法不需要操作实例变量就可以实现某种功能，就优先考虑声明为类方法,这样可以节省空间。 这此给大家举个栗子:(包含许多以前学过的知识)1234567891011121314class Sum&#123; static int sum = 0; static void getResult(int ... x)&#123;//详情请看[可变参数简介]（http://x1aolin6.top/2018/06/11/Java%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC/） for(int i:x)&#123; sum+=i; &#125; &#125;&#125;public class Exam1&#123; public static void main(String args[])&#123; Sum.getResult(1,2,3,4,5,6,7,8,9);//45 System.out.printf("%d\n",Sum.sum); &#125;&#125; 运行结果如下，自行体会:12x1aolin@x1aolin-E402NA:~/桌面$ java Exam145]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java参数传值]]></title>
    <url>%2F2018%2F06%2F11%2FJava%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[当方法被调用的时候，如果方法有参数，参数必须要实例化，即参数必须有具体的值。在Java中，方法的所有参数都是“传值”的，也就是说，方法中参数变量的值是调用者指定的一个副本。 基本数据类型参数传值对于基本类型的参数，向该参数传递的值的级别不可以高于该参数的级别，可以低于该参数的级别。如果传递值的级别比参数的级别低，则传递过程中会自动转化。 引用类型参数的传值这里先普及一下什么是引用类型: 对象，数组，接口等都是引用类型，关于引用类型的含义或者理解在上篇博客第三点有提到:对象的引用和实体。当参数是引用类型时，“传值”传递过去的是变量中存放的“引用”，而不是变量的实体。 所以对于两个同类型的引用型变量，如果具有同样的引用，就会有同样的实体，因此，如果改变参数变量所引用的实体，就会导致原变量的实体发生同样的变化。但是，改变参数的“引用”不会影响向其传值的变量中存放的“引用”。放个图加深理解: 说明： 上面的意思是说当调用左右任何一个引用来改变实体后，另一个引用所指实体也会改变，它们本来就是一个嘛。当改变左右任何一个引用，就是该引用不再指向这个实体后，另一个应用不受影响，仍然指向这个实体 这个想想应该可以理解，就暂时不放代码示例了，如果大家有要求，我再把代码放上去。 可变参数 这个是C++里面没有的，所以请大家多关注一下。 可变参数是指在声明方法时不给出参数列表中从某项直至最后一项参数的名字和个数，但这些参数的类型应该相同。可变参数使用”…”表示若干个参数，最后一个参数必须是参数列表中的最后一个参数。例如:1public void aaa(double h,int ... x); 这里的x是方法aaa的参数列表中可变参数的参数代表。参数代表可以通过下标运算来表示参数列表中的具体参数，即x[0]，x[1]，… ，x[m-1]来表示x所代表的参数。对于一个参数代表，参数代表.length等于参数代表所代表的个数。举个栗子:123456789101112131415161718192021class Computer&#123; public double getResult(double a,int ... x)&#123; // !!! double result = 0; int sum = 0; for(int ss:x)&#123; //下面会给解释 sum +=ss; &#125; result = a*sum; System.out.println("x代表了"+x.length+"个数"); return result; &#125;&#125;public class Exam&#123; public static void main(String args[])&#123; Computer comp = new Computer(); double result = comp.getResult(1.0/3,5,6,7);//x代表三个数 System.out.println("5,6,7的平均数:"+result); result = comp.getResult(1.0/5,11,22,33,44,55);//x代表五个数 System.out.println("11,22,33,44,55的平均数为:"+result); &#125;&#125; 代码运行结果如下，请大家好好体会:1234567x1aolin@x1aolin-E402NA:~/桌面$ vim Exam.javax1aolin@x1aolin-E402NA:~/桌面$ javac Exam.java x1aolin@x1aolin-E402NA:~/桌面$ java Examx代表了3个数5,6,7的平均数:6.0x代表了5个数11,22,33,44,55的平均数为:33.0]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有向面积]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%9C%89%E5%90%91%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[此次介绍用有向面积的概念求(凹)多边形的面积，理论基础传送门，大家可以点开超链接了解一下什么是有向面积，然后再来看此处的例题: Input: The input data consists of several figures. The first line of the input for each figure contains asingle integer n, the number of vertexes in the figure. (0≤n≤1000).In the following n lines, each contain a pair of real numbers, which describes the coordinates ofthe vertexes, (xi, yi). The figure in each test case starts from the first vertex to the second one,then from the second to the third, …… and so on. At last, it closes from the nth vertex to the firstone.The input ends with an empty figure (n = 0). And this figure not be processed. Output: As shown below, the output of each figure should contain the figure number and a colon followedby the area of the figure or the string “Impossible”.If the figure is a polygon, compute its area (accurate to two fractional digits). According to theinput vertexes, if they cannot form a polygon (that is, one line intersects with another whichshouldn’t be adjoined with it, for example, in a figure with four lines, the first line intersects withthe third one), just display “Impossible”, indicating the figure can’t be a polygon. If the amount ofthe vertexes is not enough to form a closed polygon, the output message should be “Impossible”either. 代码实现：1...未完待续]]></content>
      <categories>
        <category>算法与程序设计</category>
      </categories>
      <tags>
        <tag>计算几何算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算几何之寻找凸包]]></title>
    <url>%2F2018%2F06%2F09%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B9%8B%E5%AF%BB%E6%89%BE%E5%87%B8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[首先我们先看一个例子:这个问题就是典型的凸包问题。先讲一下什么是凸包:凸包是一组点集中的子集,这一子集形成的凸多边形可以将点集中所有的点都围住,并且这一凸多边形的面积是最小的。 显而易见，上述问题的求解就是把最外面的一圈点用折线圈起来，这样就是最好的结果。那么，怎么把这种思想体现到计算机算法中呢？其实有很多种解决方法，其中这里讲一个比较容易理解实现的算法:打包法具体算法如下: 找出点集中最下方的点，如果这样的点不止一个，就选用最左边的点。 设想在该点处拴住了一根橡皮筋的一端，另一端放在和该点成水平位置的右侧。 将皮筋沿逆时针方向转动,直到碰到第一个点，然后第二个，第三个…直到形成一个闭合的凸包。 具体而言:就是第一次找到一点(如P0)，以P0为每个矢量的起点，其他的点为矢量的终点，比较任意两个矢量的转角，就可以对余下的点进行按极角排序。如下图: 对于右图这种极角相同的情况，可以判定哪个点在中间，哪个点在两边(下面代码实现中on_segment()函数)。 C++代码实现如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;utility&gt; //pair所在头文件#include &lt;vector&gt; //vector容器#include &lt;algorithm&gt; //提供大量基于迭代器的非成员模板函数using namespace std;typedef pair&lt;double,double&gt; POINT;double direction(POINT p,POINT p1,POINT p2)&#123; POINT v1,v2; //定义两个向量，用于后续比较 v1.first = p2.first - p.first; v1.second = p2.second - p.second; v2.first = p1.first - p.first; v2.second = p1.second - p.second; double k = v1.first*v2.second - v1.second*v2.first;//类似z轴单位向量 return k;//k为正值,p2逆时针旋转得到p1，p2极角小,等于0时p1,p2共线&#125;bool on_segment(POINT p,POINT p1,POINT p2)&#123; //判断p是不是在以p1p2线段为对角线的边平行于x,y轴的矩形中 double min_x = p1.first &lt;p2.first ?p1.first :p2.first; double max_x = p1.first &gt;p2.first ?p1.first :p2.first; double min_y = p1.second&lt;p2.second?p1.second:p2.second; double max_y = p1.second&gt;p2.second?p1.second:p2.second; if(p.first &gt;= min_x &amp;&amp; p.first &lt;=max_x &amp;&amp; p.second&gt;= min_y &amp;&amp; p.second&gt;=max_y) return true; else return false;&#125;POINT startPoint; //定义一个起始点bool sortByPolorAngle(const POINT &amp;p1,const POINT &amp; p2)&#123; double d = direction(startPoint,p1,p2); if(d&lt;0) return true;//默认p1为下一个正确点 if(d&gt;0) return false; if(d=0 &amp;&amp; on_segment(startPoint,p1,p2)) return true; //感觉这种方式不会用到(???) if(d=0 &amp;&amp; on_segment(p1,startPoint,p2))//共线的两种方式 return true; return false; //以上条件都不符合 &#125;void find_convex_hull(vector&lt;POINT&gt; &amp; point)&#123; POINT p0 = point[0]; int k = 0; for(int i=1;i&lt;point.size();i++)&#123; //找起始点，具体算法中的第一点 if(point[i].second &lt;p0.second || point[i].second == p0.second &amp;&amp; point[i].first&lt;p0.first)&#123; p0 = point[i]; k = i; &#125; &#125; point.erase(point.begin()+k);//删除那个已经选出的点 point.insert(point.begin(),p0);//把p0插入到point的最前面 vector&lt;POINT&gt; convex_hull; //凸包容器 do&#123; convex_hull.push_back(point[0]); //在最后插入选出的点 startPoint = point[0]; point.erase(point.begin()); //删除已经选出的点,方便进行排序。 sort(point.begin(),point.end(),sortByPolorAngle); if(point[0] == convex_hull[0]) break; //出口,形成了一个凸包 point.push_back(convex_hull[convex_hull.size()-1]); &#125;while(1); for(int i = 0;i&lt;convex_hull.size();i++)//打印凸包 &#123; cout&lt;&lt;'('&lt;&lt;convex_hull[i].first&lt;&lt;','&lt;&lt;convex_hull[i].second&lt;&lt;')'&lt;&lt;endl; &#125;&#125;//下面给出验证main函数int main()&#123; vector&lt;POINT&gt; point; cout&lt;&lt;"请输入所有的点，我们将找出其对应的凸包:"&lt;&lt;endl; char s = 'Y'; int i=0; while(s == 'Y')&#123; double x,y; cout&lt;&lt;"x坐标:"; cin&gt;&gt;x; cout&lt;&lt;"y坐标:"; cin&gt;&gt;y; point.push_back(make_pair(x,y)); i++; cout&lt;&lt;"你还要继续输入吗？(Y/N):"; cin&gt;&gt;s; &#125; cout&lt;&lt;"输入结束，对应凸包为:"&lt;&lt;endl; find_convex_hull(point); return 0;&#125; 下面给出一些解释或补充，以便于更好理解代码: 数学基础—向量运算(叉乘)，三维向量叉乘推导,给那些有强迫症的一定要打破砂锅问到底的孩子们。 STL容器对应的几个函数用法: C++学习之容器—erase()函数,insert()函数,push_back()使用方法,sort()用法。]]></content>
      <categories>
        <category>算法与程序设计</category>
      </categories>
      <tags>
        <tag>计算几何算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对象基础]]></title>
    <url>%2F2018%2F06%2F04%2FJava%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[类是面向对象语言中最为重要的一种数据类型，类声明的变量称为对象。类是创建对象的模板，当使用一个类创建一个对象时，也称给出了这个类的一个实例。 创建对象创建对象包括对象的声明和为声明的对象分配内存两个步骤: 对象的声明类的名字 对象名字; //声明之后，就可以分配内存了 为声明的对象分配内存 使用new运算符和类的构造方法为声明的对象分配内存，即调用构造方法为其分配内存。如果类中没有构造方法，系统会调用默认的构造方法(默认构造方法:无参无语句)。如果类中定义了一个或多个构造方法，那么Java不提供默认的构造方法。举个栗子:1234567891011121314class xiyoujiRenwu&#123; float height,weight; String head,ear,hand,foot,mouth; void speak(String s)&#123; System.out.println(s); &#125;&#125;public class Example4_1&#123; public static void main(String argv[])&#123; xiyoujiRenwu zhubajie; //声明对象 zhubajie = new xiyoujiRenwu(); //为对象分配内存，默认构造方法 &#125;&#125;//自建构造方法此处不再给出，在以后的讲述中会有提到。 Notice: 如果类中定义了一个或者多个构造方法，那么Java不提供默认的构造方法！！！ 对象的内存模型接上面的代码给大家介绍一下对象的内存模型，以便于更好的理解对象这一概念： 声明对象zhubajie后，zhubajie的内存中还没有任何数据，也就是空对象。空对象不能使用，因为它还没有得到任何“实体”，必须再进行为**为对象分配内存的步骤，即为对象分配实体。 当系统见到: 1zhubajie = new xiyoujiRenwu(); 时，就会做两件事。 为xiyoujiRenwu类中的成员变量height, weight, head, ear, mouth, hand, foot分配内存，即类中的成员变量被分配内存空间，然后执行构造方法进行数据的初始化。(如果成员变量在声明时没有指定初值，并且所使用的构造方法也没有对成员变量进行初始化，那么，整型变量默认初值为0，浮点型变量默认初值0.0，boolean型变量默认false，引用型变量默认初值为NULL)。 给出一个信号，保证这些变量是属于对象zhubajie的。即new运算符为这些变量分配完内存后，会返回一个引用给zhubajie对象。(这样也就不难理解一个类使用new创建不同的对象(实例变量等)不会相互影响了，因为他们被分配不同的内存)。如下图所示: 使用对象抽象的目的时产生类，而类的目的是创建具有属性和行为的对象。对象不仅可以操作自己的变量改变状态，而且还能调用类中的方法产生一定的行为。12对象.变量; //调用变量对象.方法; //调用方法 体现封装: 当对象调用方法时，方法中出现的成员变量就是分配给该对象的变量。当对象调用方法时，方法中的局部变量被分配内存空间，方法执行完毕，局部变量即可释放内存。Notice: 局部变量在声明时如果没有初始化，那么它就没有默认值。 对象的引用和实体当用类创建一个对象时，类中的成员变量在堆(一种运行时的数据结构，支持动态内存管理) 中分配内存空间，这些内存空间成为该对象的实体或对象的变量，而上文所提到的对象中存放的引用在栈中分配内存，以确保实体由该对象使用。 由上面的解释大家可以知道，引用 和 实体 是分开的，即大家可以改变引用来相应改变它所能调用的实体。这么说大家可能还是不清楚，举个栗子给大家:1234567891011121314151617181920class x1aoPoint&#123; public int a,b; //public表示权限，后面会提到 x1aoPoint(int a,int b)&#123; //自定义构造方法(又复习了一下) this.a = a; this.b = b; //关于this会在后面的博客中提到哦 &#125;&#125;public class Lin&#123; public static void main(String args[])&#123; x1aoPoint p1,p2; p1 = new x1aoPoint(1,2); p2 = new x1aoPoint(4,3); //下面是重点！！！ System.out.println("("+p1.a+","+p1.b+")"); System.out.println(p1+"\n"+p2); p1 = p2; //改变引用，使p1也指向此前为p2分配的变量 System.out.println("("+p1.a+","+p1.b+")"); System.out.println(p1+"\n"+p2); &#125;&#125; 运行结果如下，其余请自己体会:123456789x1aolin@x1aolin-E402NA:~/桌面/javaExample$ vim Lin.javax1aolin@x1aolin-E402NA:~/桌面/javaExample$ javac Lin.java x1aolin@x1aolin-E402NA:~/桌面/javaExample$ java Lin(1,2)x1aoPoint@233c0b17x1aoPoint@61a52fbd(4,3)x1aoPoint@61a52fbdx1aoPoint@61a52fbd 最后补充一点: Java有所谓的“垃圾回收”机制：周期性的检测某个实体是否已经不再被任何对象所拥有，如果发现这样的实体，就会自动释放掉实体所占有的内存。所以，上面代码中，当p2的引用赋给p1时，最初分配给p1的实体就会被释放掉。]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类基础知识]]></title>
    <url>%2F2018%2F06%2F02%2FJava%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B8%80%2F</url>
    <content type="text"><![CDATA[面向对象语言特性众所周知，Java是一门面向对象的编程语言，它的源程序由若干个类组成，源文件时拓展名为.java的文本文件。下面给出面向对象编程的特性: 1.封装性。即将数据和对数据的操作封装在一起，通过抽象，从具体的实例中抽取共同的性质形成一般的概念。比如类的概念。 2.继承性。子类可以继承父类的属性和功能，既继承了父类所有的数据和数据上的操作，同时又可以添加子类独有的数据和数据上的操作。 3.多态性。一种是操作名称的多态，既有多个操作具有相同的名字，但这些操作所接受的信息类型必须不同。另一种多态是和继承有关的多态，是指同一个操作被不同的类型对象调用时可能产生不同的行为。 类的声明类是组成Java程 序的基本要素，类封装了一类对象的状态与方法，类是用来定义对象的模板。类的实现包括两个部分，即类的声明和类体，基本格式如下:123class 类名&#123; //类的声明 类体的内容 //类体&#125; 类的声明注意事项 :1.类的名字要符合标识符的规定。(语法要求)2.如果类名使用拉丁字母，那么类名的首字母使用大写字母。(不是语法要求但需要遵守)3.类名最好容易识别，见名知意。(不是语法要求但需要遵守) 类体说明 :1.类声明后的一对大括号{ }以及它们之间的内容成为类体，大括号之间的内容称为类体的内容。2.类体由两个部分构成:一部分是变量的声明，用来刻画属性;另一部分是方法的定义，用来刻画功能。举个栗子:123456789class Trapezoid&#123; float 上底,下底,高,laderArea; //变量声明，刻画属性 float 计算面积()&#123; //方法定义，刻画功能 laderArea = (上底+下底)*高/2.0f; &#125; void 修改高(float h)&#123; 高 = h; &#125;&#125; 成员变量和局部变量变量的有效范围 在变量声明部分声明的变量被称为类的成员变量，在方法体中声明的变量和方法的参数被称为局部变量。当然，成员变量和局部变量的类型可以时Java中的任何一种数据类型。 成员变量在整个类内都有效，局部变量只在声明它的方法内有效。 方法参数在整个方法内有效，方法内的局部变量从声明他的位置之后开始有效。 如果局部变量的声明是在一个复合语句中，那么该有效范围的有效范围就是该复合语句，即仅在该复合语句中有效。 如果局部变量的声明是在一个循环语句中，那么该局部变量的有效范围是该循环语句，即仅在循环语句中有效。举个栗子:123456789101112public class A&#123; int m = 10,sum = 0; //成员变量，在整个类中有效 void f()&#123; if(m&gt;9)&#123; int z = 10; //z仅仅在该复合语句中有效 z = 2*m + z; &#125; for(int i = 0;i&lt;m;++i)&#123; sum += i; //i仅在该循环语句中有效 &#125; &#125;&#125; 实例变量与类变量在声明成员变量前，用关键词static给予修饰的称作类变量(静态变量)，否则称之为实例变量(对象变量)。类变量是所有对象共有，其中一个对象将它的值改变，其他对象得到的就是改变后的结果；而实例变量则属于对象私有，某一个对象将其值改变，不影响其他对象。举个栗子：1234567891011121314class Dog&#123; float x = 0; //实例变量 static int y = 0; //类变量(静态变量)&#125;public class A&#123; public static void main(String[] args)&#123; Dog a1 = new Dog(); Dog a2 = new Dog(); a1.x = 3.0f; a1.y = 4; //等同于 Dog.y = 4; System.out.println(a2.y); //结果为4 System.out.println(a2.x); //结果为0 &#125;&#125; 成员的隐藏如果局部变量的名字与成员变量的名字相同，则成员变量被隐藏，即这个成员变量在这个方法内失效。例如:1234567class Tom&#123; int x = 99,y; void f()&#123; int x = 3; y = x; //y得到的值为3，而不是99 &#125;&#125; 如果仍希望在该方法中使用隐藏的成员变量，需要用到关键词this,比如这样:1234567class Tom&#123; int x = 99,y; void f()&#123; int x = 3; y = this.x; //y得到的值为99,而不是3 &#125;&#125; 变量书写风格虽然其中的一些要求不是语法要求，但是还是希望大家能够遵守，养成良好的变成习惯。 一行只声明一个变量(便于给代码添加注释)。 变量的名字符合标识符的规定。 变量的名字见名知意，避免容易混淆的变量的名字，也尽量不要用a1,a2这种方式。 方法最基本的方法包括方法名和方法的返回类型，并且很多方法声明中都给出了方法的参数，例如:123float area(int a,float b,...)&#123;//参数可以省略，根据需要填写 ...//方法体&#125; 方法的参数和返回类型可以是任意的Java数据类型，不需要返回类型时要用void。方法声明之后的一对大括号”{“、”}”以及之间的内容称为方法体。方法体内包括局部变量的声明和Java语句。写一个方法完全类似于C++里面的函数，只不过是面向对象语言中的称呼。 方法重载前面说过，Java中存在两种多态，即重载和重写，重写是和继承有关的多态，将在以后的博客中讨论。方法重载是多态性的一种，所谓功能多态性，是指可以向功能传递不同的消息，以便让对象根据相应的消息产生相应的行为。方法重载的意思是，一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同(1.参数个数不同 2.参数类型不同)。举个栗子:1234567891011121314class Lin&#123; float getArea(float r)&#123; return 3.14f*r*r; &#125; double getArea(float x,float y)&#123; return x*y; &#125; float getArea(int x,float y)&#123; return x*y; &#125; double getArea(float x,float y,float z)&#123; return (x*x+y*y+z*z)*2.0; &#125;&#125; Notice: 方法的返回类型和参数的名字不参与比较，所以说，方法重载需要保证参数个数或者参数类型的不同！！！ 构造方法和C++相同，当我们创建一个对象时，会调用构造方法进行初始化。构造方法也是一种特殊的方法， 它的名字必须与它所在类的名字完全相同 ,不需要写类型，也可以重载。举个栗子:12345678910111213class Trapezoid&#123; float 上底，下底，高; Trapzoid()&#123; //构造方法 上底 = 60; 下底 = 100; 高 = 20; &#125; Trapzoid(float x,int y,float z)&#123; //构造方法 上底 = x; 下底 = y; 高 = z; &#125; &#125; 实例方法与类方法和实例变量和类变量一样，类中的方法也分为实例方法和类方法。在声明方法时，方法类型前面不加关键字static修饰的是实例方法，加static的是类方法(静态方法)。举个例子:123456789class A&#123; int a; float b(int x,float y)&#123; //实例方法 &#125; static void speak(String s)&#123; //类方法 &#125;&#125; 想了解实例方法和类方法的区别请点击：实例方法和类方法的区别传送门 Notice: 对成员变量的操作只能放在方法中，方法可以对成员变量和该方法体中声明的局部变量进行操作。当然，在声明类的成员变量时可以同时赋予初值。 实例方法既能对类变量操作也能对实例变量进行操作，而类方法只能对类变量进行操作。 123456789101112class A&#123;int a; //实例变量static int b; //类变量void f(int x,int y)&#123; //实例方法 a = x;//true b = y;//true&#125;static void g(int z)&#123; b = 23; a = z;&#125;&#125; 一个类中的方法可以相互调用，实例方法可以调用该类中的其他方法；类中的类方法只能调用该类的类方法，不能调用实例方法。]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java语句基础]]></title>
    <url>%2F2018%2F06%2F01%2FJava%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[语句概述Java中的语句可分为以下六类。(1)方法调用语句。例如System.out.pritln(&quot;x1aolin&quot;)(2)表达式语句。即由一个表达式构成的语句。(3)复合语句。和C++一样，Java中也可以用{ }把一些语句括起来构成符合语句。(4)空语句。由一个分号构成的语句。(5)控制语句。条件分支语句，开关语句，和循环语句，下面会有简单介绍。(6)package语句和import语句。它们和类，对象有关，将在后续的blog中进行介绍。 条件分支语句主要分为if语句，if-else语句，if-else if-else语句。和C++用法完全一致，此处仅给出其相应的格式。语法格式如下:123456789101112131415161718192021if(表达式)&#123;若干语句&#125; //if语句语法格式if(表达式)&#123;若干语句&#125;else&#123;若干语句&#125; //if-else语法格式if(表达式)&#123;若干语句&#125;else if(若干语句)&#123;若干语句&#125;...else&#123;若干语句&#125; //if-else if-else语法格式 开关语句也就是switch case 语句，格式如下:12345678910111213141516switch(表达式)&#123; case 常量1: 若干语句 break; //可选，下面会讲述break的作用 case 常量2: 若干语句 break; //可选，下面会讲述break的作用 ... case 常量n: 若干语句 break; //可选，下面会讲述break的作用 default: 若干语句&#125; 注意 : “表达式”的值必须为byte、short、int、char型或枚举类型，他们当中的常量值也必须为上述类型且须各不相同。 switch语句首先计算表达式的值，计算结果对应case后面的变量值，并执行其后面对应的语句，直到碰到break为止，也就是说如果对应的case语句结尾没有break，那么程序就会执行紧随其后的一个case当中的内容。 循环语句1.for循环语句语法格式:123for(表达式1;表达式2;表达式3)&#123; 若干语句&#125; 说明 :(1)“表达式1”负责完成变量的初始化。(2)“表达式2”是boolean型的表达式，称为循环条件。(3)“表达式3”用来修饰变量，改变循环条件。 2.while语句和do-while语句不再多说break和continue语句(1)break和continue语句是用关键字break和continue加上分号构成的语句。(2)如果在某次循环中执行了break语句，那么整个循环语句就结束。(3)如果在某次循环中执行了continue语句，那么本次循环结束，不再执行continue后面的语句，转入进行下一次循环。 数组和for语句Java的JDK1.5版本对for语句的功能给予扩充、增强，以便更好的遍历数组。其语法格式如下:1234for(声明循环变量:数组的名字)&#123;... &#125;!!! 注意声明的循环变量类型必须和数组的类型相同 举例如下：12345678910111213141516171819202122public class x1ao&#123; public static void main(String argv[])&#123; int[] a = &#123;1,5,7,8&#125;; char b[] = &#123;'l','i','n','r'&#125;; //传统打印方式 for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+" "); &#125; for(int i=0;i&lt;b.length;++i)&#123;//上面有提到++x和x++的区别 System.out.print(b[i]+" "); &#125; System.out.println(); //美观换行 //改进方式 for(int j:a)&#123;//循环变量j依次取数组的每一个元素值 System.out.print(j+" "); &#125; for(char ch:b)&#123; System.out.print(ch+" "); &#125; System.out.println(); //美观换行 &#125;&#125; 运行结果如下，有问题请在评论区留言:12345x1aolin@x1aolin-E402NA:~/桌面/javaExample$ vim x1ao.javax1aolin@x1aolin-E402NA:~/桌面/javaExample$ javac x1ao.java x1aolin@x1aolin-E402NA:~/桌面/javaExample$ java x1ao1 5 7 8 l i n r 1 5 7 8 l i n r]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java运算符、表达式和语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java运算符相关]]></title>
    <url>%2F2018%2F06%2F01%2FJava%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5%E4%B8%80%2F</url>
    <content type="text"><![CDATA[说明： 因为这一块和C语言的规则相差无几，所以此处不会重点描述，只说明一下其中的重点和与C不同的部分。 instanceof运算符该运算符为二目运算符，左边的操作单元是一个对象，右边的是一个类。当左边的对象时右边的类或者子类创建的对象时，该运算符运算的结果时true,否则为false。 自增自减运算符此处仅以（++X）和（X++）为例。粗略的看，++x 和 x++ 的作用都是使x+1。但是++x是先执行x=x+1，然后再使用x的值，而x++是先使用x的值然后再执行x=x+1。举个栗子:123x = 5; //仅给出部分代码显示其功能y = ++x; // y的值为6z = x++; // z的值为5 运算符优先级与结合性 优先级 描述 运算符 结合性 1 分隔符 [ ] ( ) . , ; 2 对象归类，自增，自减函数，逻辑非 instanceof, ++, –, ! 从左到右 3 算数乘除运算 *, /, % 从左到右 4 算数加减运算 +, - 从左到右 5 移位运算 &gt;&gt;, &lt;&lt;, &gt;&gt;&gt; 从左到右 6 大小关系运算 &lt;, &lt;=, &gt;, &gt;= 从左到右 7 相等关系运算 ==, != 从左到右 8 按位与运算 &amp; 从左到右 9 按位异或运算 ^ 从左到右 10 按位或运算 \ 从左到右 11 逻辑与运算 &amp;&amp; 从左到右 12 逻辑或运算 &#x7C;&#x7C; 从左到右 13 三木条件运算 表达式?语句1:语句2 从左到右 14 赋值运算 = 从右到左]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java运算符、表达式和语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java枚举类型]]></title>
    <url>%2F2018%2F05%2F31%2FJava%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[声明枚举类型java使用关键字 enum 声明枚举类型，语法格式如下:123enum 枚举名&#123; 常量列表&#125; 其中的“常量列表”是用逗号分隔的字符序列，称为枚举类型的常量(需符合标识符规定)。例如:123enum x1ao&#123; one,two,three,four&#125; 声明枚举变量声明了一个枚举类型后，就可以用该枚举类型的枚举声明一个枚举变量了。例如:1x1ao x; //用到了上面的声明 这样，枚举类型就可以使用枚举名和”,”运算符获得枚举类型中的常量。1x = x1ao.one; //这时候使用System.out.println(x)就可以显示one字符串 说明与举例可以在一个Java源文件中声明、定义枚举类型，然后保存源文件，最后单独编译源文件得到枚举类型的字节码文件，那么该字节码就可以被其他源文件中的类使用。下面给出示例: Weekday.java文件123public enum Weekday&#123; 星期一，星期二，星期三，星期四，星期五，星期六，星期日&#125; Example7.java123456789public class Example7&#123;//文件名随便起，限制条件请分类查找java第一篇博客 public static void main(String args[])&#123; Weekday x = Weekday.星期日; if(x==Weekday.星期日)&#123; System.out.println(x); System.out.println("今天我休息！"); &#125; &#125;&#125; 下面给出运行结果，大家可以自己运行试试,复制代码后将中文逗号等字符改成英文状态！！！1234x1aolin@x1aolin-E402NA:~/桌面$ javac Example7.java x1aolin@x1aolin-E402NA:~/桌面$ java Example7星期日今天我休息！ 补充:枚举类型与for，switch数组 除了上面所说，枚举类型可以用枚举类型的名字.values()返回一个数组，该数组的值与该枚举类型中的常量一一对应。 jdk1.5后的版本允许switch语句中表达式的值是枚举类型。]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java从命令行输入和输出数据]]></title>
    <url>%2F2018%2F05%2F26%2FJava%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[输入基本型数据 在Java基本类型介绍 一节中提到，Java程序都是由若干个类组成的，所以输入也是一个类。 Scanner类Scanner类用与创建一个对象:Scanner reader = new Scanner(System.in) 然后reader对象可通过以下函数对应读取用户在命令行输入的各种基本类型:nextBoolean(),nextByte(),nexyShort(),nextInt(),nextLong(),nextFloat(),nextDouble() 注意：上述方法在执行时都会发生堵塞，程序等待用户在命令行输入数据并按Enter确认。 下面通过一个实例加深以下理解:123456789101112131415161718import java.util.Scanner;public class Example2&#123; public static void main(String args[])&#123; System.out.println("请输入若干个数，每输入一个数回车确认"); System.out.println("最后输入数字-9999结束输入操作"); Scanner lll = new Scanner(System.in); double sum = 0; int m = 0; double x = lll.nextDouble(); while(x!=-9999)&#123; m+=1; // m = m + 1; sum+=x; // sum = sum + x; x = lll.nextDouble(); &#125; System.out.println(m+"个数的和为"+sum); System.out.println(m+"个数的平均值为"+sum/m); &#125;&#125; 运行结果如下，其余自行体会：12345678910x1aolin@x1aolin-E402NA:~/桌面$ java Example2请输入若干个数，每输入一个数回车确认最后输入数字-9999结束输入操作3456-99994个数的和为18.04个数的平均值为4.5 输入基本型数据三种类型：1234System.out.println() //1System.out.print() //2 二者的区别是1号代码输出数据后换行，2号不换行System.out.printf("格式控制部分"，表达式1，表达式2，...,表达式n)//类似c语言 注意事项: 使用时不可以采取回车操作 12345System.out.println("你好， 很高兴认识你"); // !!! 错误示范System.out.println("你好," + "很高兴认识你"); // !!! 正确示范字符串过长时用并置符号 + 将其首尾相连 在java中，允许使用并置符号 + 将变量、表达式或一个常数值与一个字符串并置在一起输出 对于上述第三种输出方法，有以下格式：(1)%d: int型数据(2)%f: 浮点型数据，小数部分最多保留6位。(3)%c: char型数据(4)%s: 字符串数据(5)%md:输出的int数据占据m列(6)%m.nf:输出的浮点型数据占据m列，小数点保留n位(小数点也会占一列)例如： 1System.out.println("%d %f",12,23.78);]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数组的用法]]></title>
    <url>%2F2018%2F05%2F26%2FJava%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[声明数组 一维数组声明格式：(1) 数组的元素类型 数组名称[ ];(2) 数组的元素类型[ ] 数组名称; 二维数组声明格式：(1) 数组的元素类型 数组名称[ ][ ];(2) 数组的元素类型[ ][ ] 数组名称;举例:123float boy[]; // 等价于 float[] boy;char cat[][]; // 等价于 char[][] cat; 注意 :(1) 数组boy的元素类型可以是Java中的任何一种类型。假如已经声明了一个Hello类型，那么就可以声明一个数组: Hello hh[];(2) 与C不同，Java不允许在声明数组的方括号内指定数组的方括号内指定数组元素个数。int a[6]或int[8] b等都会导致语法错误。 创建数组及初始化 声明数组仅仅是给出了数组名字和元素的数据类型，如果想要使用还必须为它分配内存空间，即创建数组。 静态初始化: 即定义数组的同时对数组进行初始化。举例: 1int[] a=&#123;1,2,3,4,5&#125;; //这样就间接创建了一个拥有5个元素的数组 动态初始化: 使用运算符new为数组分配空间。格式为：数组名字 = new 数组元素的类型[数组元素的个数]举例: 123int a[]; //声明a = new int[5]; //创建一个元素值为五个的数组a[0]=1; a[1]=2; a[2]=3; a[3]=4; a[4]=5; //同上面静态初始化的值 声明数组和创建数组可以一起完成 123float xiao[] = new float[5]; //一维数组的创建int lin[][] = new int[4][3]; //当然也可以分开，先声明后创建 Java采用“数组的数组”声明多维数组，即一个二维数组是由若干个一维数组组成的，比如上述创建的二维数组lin就是由4个长度为3的一维数组lin[0],lin[1],lin[2],lin[3]构成的。 !!! 构成二维数组的一维数组不必要有相同的长度，在创建二维数组时可以分别指定构成该二维数组的一维数组的长度。 1234567int lin[][] = new int[4][]; //未完成创建数组，该数组还不能使用 lin[0] = new int[1];lin[1] = new int[2];lin[2] = new int[3];lin[3] = new int[4]; //完成，一维数组大小我是随意定的//也可以使用下面的方式int lin[][] = &#123;&#123;9&#125;,&#123;2,5&#125;,&#123;8,9,4&#125;,&#123;3,2,1,7&#125;&#125;;//分配内存大小和上面相同 数组变量a中存放着这些内存单元的首地址，该地址称作数组的引用。 数组元素的使用 一维数组通过索引符访问自己的元素。注意索引符从0开始，若数组有10个元素，那么索引为0~9。 二维数组也是如此。举个栗子给大家尝尝:123int lin[][] = new int[4][3]; //第一个索引为0~3，第二个索引为0~2lin[3][2] = 12; lin[0][0] = 1; length的使用 说明: 数组的元素个数称为数组的长度。 对于一维数组，“数组名字.length”的值就是数组中元素的个数; 对于二维数组，“数组名字.length”的值为它含有的一维数组的个数。123float xiao[] = new float[5]; //xiao.length的值为5 int lin[][] = new int[4][3]; //lin.length的值为4 数组的引用 数组为引用型变量，因此，两个相同类型的数组如果具有相同的引用，它们就会有完全相同的元素。 对于 :123int a[] = &#123;1,2,3&#125;; int b[] = [4,5]; a = b; // a,b类型必须相同 如果这么处理，a中存放的引用和b的相同，系统将释放最初分配给数组a的元素，使得a的元素和b的元素相同。举个栗子做个小小的总结：12345678910111213141516import java.util.Arrays; //输出数组，下面会讲到public class Example3&#123; public static void main(String args[])&#123; int a[] = &#123;1,2,3&#125;; int b[] = &#123;4,5&#125;; System.out.println("数组a的元素个数 = "+a.length); System.out.println("数组b的元素个数 = "+b.length); System.out.println("数组a的引用 = "+a); System.out.println("数组a的引用 = "+b); System.out.println("a==b的结果为 "+(a==b)); a = b; System.out.println("数组a的元素个数 = "+a.length); System.out.println("数组b的元素个数 = "+b.length); System.out.println("a==b的结果为 "+(a==b)); System.out.println("a数组:"+Arrays.toString(a)); System.out.println("b数组:"+Arrays.toString(b)); 运行结果如下,其余自行体会:1234567891011x1aolin@x1aolin-E402NA:~/桌面$ java Example3数组a的元素个数 = 3数组b的元素个数 = 2数组a的引用 = [I@c39f790数组a的引用 = [I@71e7a66ba==b的结果为 false数组a的元素个数 = 2数组b的元素个数 = 2a==b的结果为 truea数组:[4, 5]b数组:[4, 5] 复制数组 通过上面的讲述我们知道，数组属于引用类型，所以在复制数组的时候不能简单的执行b=a这类代码。因为此操作只能使他们指向相同的内存单元，此时改变a[1]也就是改变了b[1],并不是实际的复制了数组。 下面介绍Java中三种复制方法，各有利弊，请自行评判。 1.arraycopy方法利用循环把一个数组的元素的值赋给另一个数组中的元素。这里用System类调用方法:1public static void arraycopy(sourceArray,int index1,copyArray,int index2,int length) 可以将数组sourceArray从索引index1开始的length个元素中的数据复制到数组copyArray中，copyArray数组从第index2元素开始存放这些数据，如果数组copyArray不能存放下复制的数据，程序运行将会发生异常。下面给出示例：12345678910111213141516171819import java.util.Arrays;public class Example4&#123; public static void main(String args[])&#123; char a[] = &#123;'a','b','c','d','e','f'&#125;; char[] b = new char[6]; b[0]='1';b[1]='2';b[2]='3';b[3]='4';b[4]='5';b[5]='6'; int[] c; c = new int[6]; c[0]=1;c[1]=2;c[2]=3;c[3]=4;c[4]=5;c[5]=6; int d[] = &#123;10,20,30,40,50,60&#125;; //复习前面的内容 System.arraycopy(a,0,b,0,a.length); System.arraycopy(c,2,d,2,(c.length-3)); System.out.println("数组a:"+Arrays.toString(a)); System.out.println("数组b:"+Arrays.toString(b)); System.out.println("数组c:"+Arrays.toString(c)); System.out.println("数组d:"+Arrays.toString(d)); &#125;&#125; 运行结果如下:1234567x1aolin@x1aolin-E402NA:~/桌面$ vim Example4.javax1aolin@x1aolin-E402NA:~/桌面$ javac Example4.java x1aolin@x1aolin-E402NA:~/桌面$ java Example4数组a:[a, b, c, d, e, f]数组b:[a, b, c, d, e, f]数组c:[1, 2, 3, 4, 5, 6]数组d:[10, 20, 3, 4, 5, 60] 缺点: 事先必须创建参数copyArray指定的数组。 2.copyOf和copyOfRange方法Array类用copyOf调用方法有:1234public static double[] copyOf(double[] original,int newLength)public static float[] copyOf(float[] original,int newLength)public static int[] copyOf(int[] original,int newLength)public static char[] copyOf(char[] original,int newLength) 可以把参数original指定的数组中从索引0开始的newLength个元素复制到一个新数组中，并返回这个新数组，且该新数组的长度为newLength。如果newLength的值大于original的长度，则其余的用0补齐。 Array类用copyOfRange调用方法有:1234public static double[] copyOfRange(double[] original,int from,int to)public static float[] copyOfRange(float[] original,int from,int to)public static int[] copyOfRange(int[] original,int from,int to)public static char[] copyOfRange(char[] original,int from,int to) 复制部分值。把参数original指定的数组中从索引from至to-1的元素复制到一个新数组中，并返回这个新数组，即新数组的长度为to-from。当然，如果新数组比原数组长，则多的那个部分补0。示例如下:12345678910111213import java.util.*;public class Example5&#123; public static void main(String args[])&#123; int[] a = &#123;10,20,30,40,50,60&#125;,b,c,d; b = Arrays.copyOf(a,10); System.out.println("数组a:"+Arrays.toString(a)); System.out.println("数组b:"+Arrays.toString(b)); c = Arrays.copyOfRange(a,2,5); System.out.println("数组c:"+Arrays.toString(c)); d = Arrays.copyOfRange(a,3,9); System.out.println("数组d:"+Arrays.toString(d)); &#125;&#125; 运行结果如下,其余自行体会:1234567x1aolin@x1aolin-E402NA:~/桌面$ vim Example5.java //ubuntu命令行的操作x1aolin@x1aolin-E402NA:~/桌面$ javac Example5.java x1aolin@x1aolin-E402NA:~/桌面$ java Example5数组a:[10, 20, 30, 40, 50, 60]数组b:[10, 20, 30, 40, 50, 60, 0, 0, 0, 0]数组c:[30, 40, 50]数组d:[40, 50, 60, 0, 0, 0] 补充1:数组的表示格式 前提: 引用 import java.util.Arrays，以后的博客中会讲到。 除了向C/C++中一样用循环输出数组的值外，JDK1.5版本提供了一个简单的输出元素值的放大。让Arrays类调用:public static String toString(int[] a)方法，可以得到参数指定的一维数组a的数据，格式如下:[a[0],a[1],a[2], ... ,a[a.length-1]]示例在上面“数组的引用”模块已经给出，此处不再示例。 补充2:Java数组排序这里重点说明Arrays类调用方法实现对数组的快速排序。两种调用方法:public static void sort(double a[])public static void sort(double a[],int start,int end) 补充3:对已排序数组进行二分查找public static int binarySearch(double[] a,double number)判断参数number指定的数是否在参数a指定的数组中，如果number在数组中，返回该元素的索引，如果找不到便返回一个负数。示例如下:12345678910111213141516import java.util.*;public class Example6&#123; public static void main(String args[])&#123; int []a = &#123;5,8,2,1,9,3,6,4,7&#125;; Arrays.sort(a); System.out.println(Arrays.toString(a)); int number = 6; int index = Arrays.binarySearch(a,number); if(index&gt;=0)&#123; System.out.println(number+"和数组中的索引为"+index+"的元素值相同"); &#125; else&#123; System.out.println(number+"不与数组中的任何元素值相同"); &#125; &#125;&#125; 运行结果如下，其余自行体会12345x1aolin@x1aolin-E402NA:~/桌面$ vim Example6.javax1aolin@x1aolin-E402NA:~/桌面$ javac Example6.java x1aolin@x1aolin-E402NA:~/桌面$ java Example6[1, 2, 3, 4, 5, 6, 7, 8, 9]6和数组中的索引为5的元素值相同]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基本类型介绍]]></title>
    <url>%2F2018%2F05%2F23%2FJava%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[说明: 关于编译环境，安装相应的IDE等相关知识本文不会介绍，请自行百度 标识符和关键字标识符定义 : 用来标识类名、变量名、方法名、类型名、数组名、文件名的有效字符序列。 语法规则 :(1) 由字母、下划线、美元符号$、数字构成，长度无限制。(2) 第一个字符不可以是数字字符。(3) 不可以是关键字(关键字会在后续说明)。(4) 不可以是true、false、null这三个字符。(5) Java为强类型语言，所以严格区分大小写。(6) 使用比ASCII码更广泛的Unicode字符集，所以在(1)中所说的“字母”包含部分简体中文。 关键字说明 : 关键字就是Java中被赋予特定意义的单词。下面给出部分示例:123abstract; assert; boolean; break; byte; case; catch; char; class; const; continue default; do; double; else; enum; extends; final; ... //分号表示间隔 分隔符1.注释符 :(1)// 单行注释(以双斜杠开始，终止于行尾，注释一行，可放在语句后面)(2)/* */ 多行注释( /*开始，*/结束，中间可写多行)(3)/**开始，*/结束，这种注释主要是为了支持JDK工具javadoc而采用的。 2.空白符 :空格，回车，换行，制表符tab等。 为增强代码的可读性而建立，系统编译时会忽略它。 3.普通分隔符 :点号，分号，冒号，大括号，方括号，小括号。因为和C/C++用法相同，此处不再赘述。 基本数据类型Java语言有八中基本数据类型，习惯上可以分为四大类: 逻辑类型: boolean 整数类型: byte 、short 、int 、long 字符类型: char 浮点类型: float 、double 逻辑类型常量: true 、false变量: 使用关键字boolean来声明。 整数类型 十进制用数字1~9开头，八进制用数字0开头，十六机制用0x开头。 因为基本上和C语言差不多，稍微有点编程基础就可以理解，此处就不再赘述。重点讲一下和C语言不同的地方:(1)Java中不存在byte和short的常量表示法，但是可以把一定范围内的int型常量赋值给byte或short型变量。(2)long型常量用后缀L来表示，如108L。(3)这四个不同的类型区别：只是声明时系统分配予其内存的大小和其所能表示数的范围大小。 整数类型 所占字节数 所占位数 取值范围 int型 4 byte 32 bit -231~2^31-1 byte型 1 byte 8 bit -27~27-1 short型 2 byte 16 bit -215~215-1 long型 8 byte 64 bit -263~263-1 字符类型这里的char是相对Unicode来说的，所以 申请时系统分配给两个字节，占16位，最高位不是符号位，没有负数的char。char类型的取值范围是0~65535。1234567// 情况 1char x = 'a';char x = 97; //两者是等价的，因为97就是a字符在Unicode表当中的位置// 情况 2 char ch1 = '\n';char ch2 = '\"';char ch3 = '\\'; //有些字符只能通过转义字符进行输入 说明 : 要观察一个字符在Unicode表中的顺序位置，可以使用int型显式转换，如(int)&#39;a&#39;或int p = &#39;a&#39;。如果要得到一个0~65536的数所代表的Unicode表中相应位置上的字符，需使用char显式转换，示例如下:12345678910public class Test&#123; public static void main(String args[])&#123; char ch1 = 'w',ch2 = '好'; int p1 = 32831,p2 = 30452; System.out.printIn("\""+ch1+"\"的位置:"+(int)ch1); System.out.printIn("\""+ch2+"\"的位置:"+(int)ch2); System.out.printIn("第"+p1+"个位置上的字符是:"+(char)p1); System.out.printIn("第"+p2+"个位置上的字符是:"+(char)p2); &#125;&#125; 有兴趣的同学可以在自己的编译器下跑跑试试。 浮点类型float型(1) float定义常量时，常量后面必须要有后缀f或F。(2) float变量在存储float类型数据时保留8位有效数字，实际精度取决于具体数值。 double型保留16位有效数字，实际精度取决于具体数值。其与float的比较如下: 浮点类型 所占字节数 所占位数 取值范围 float型 4 32 10-38~1038和-1038~10-38 double型 8 64 将上面38换成308 基本数据类型的转换 将上述类型按照精度从低到高排序为 byte,short,char,int,long,float,double 当把级别低的变量的值=&gt;级别高的变量时，系统会自动完成数据类型的转换。 当把级别高的变量的值=&gt;级别低的变量时，需要用到强制转换,即显式类型转换运算，格式为: (类型名)要转换的值。 强制转换会造成“精度损失”或“数据溢出”。例如:1234float i = 10.1;double l = i; //自动转换byte b = (byte)i; //强制转换,精度损失 b = 10byte c = (byte)128; //数据溢出，c = -128 常见错误: 把一个double型常量赋值给float常量时未进行强制转换.错误示范: float x = 12.4正确做法: float x = (float)12.4 或者 float x = 12.4f 下面用一段代码总结一下上面所讲的内容:12345678910111213141516171819public class Example&#123; public static void main(String args[])&#123; int c = 128; long d = 77777; float f = 2e3f; double g = 3.14e-300; //指数表示法 double result = f*g; System.out.println("f= "+f); System.out.println("g= "+g); System.out.println("result= "+result); g = 1234.12345678; c = (int)d; f = (float)g; System.out.println("c= "+c); System.out.println("d= "+d); System.out.println("f= "+f); System.out.println("g= "+g); &#125;&#125; 运行结果如下:12345678x1aolin@x1aolin-E402NA:~/桌面$ java Examplef= 2000.0g= 3.14E-300result= 6.28E-297c= 77777d= 77777f= 1234.1234g= 1234.12345678]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序开发步骤]]></title>
    <url>%2F2018%2F05%2F21%2FJava%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[从今天开始，我们进入到Java的基础课学习，这个教程的前提时有一点编程基础，比如C/C++，请大家做好心理准备。 编写源文件可以使用IDE，现今存在的IDE也有很多，大家可以根据自己的喜好去选择不同的IDE。但是本文主要时说明开发步骤，所以本文使用Liunx系统的vim进行编辑。Windows系统的小伙伴也可以使用记事本等文本文件进行源文件的编写。注意 : 在对文件进行命名的时候，源文件的拓展名必须为.java。 编译源文件定义： 使用Java编译器(javac.exe)编译源文件，得到字节码文件。格式： javac 文件名.java 运行程序使用Java平台中的Java解释器(java.exe)来解释、执行字节码文件。格式： java 文件名 //注意不要有添加后缀 一些注意事项 在Java源程序中，语句所涉及的小括号以及标点符号都是在英文状态下输入的，而字符串里面的符号不受限制。 如果源程序中有多个类，那么只能有一个public类; 如果有一个类是public类，那么源文件的名字必须与这个类的名字完全相同，拓展名为.java; 如果源文件没有public类，那么源文件的名字只要和某个类的名字相同，并且拓展名时.java就可以了。 如果源文件中包含多个类，编译源文件将生成多个拓展名为.class的文件，在每个拓展名为.class的文件中只存放一个类的字节码，其文件名与该类的名字相同，这些字节码文件被存放在与源文件相同的目录中。 ！！！一个Java应用程序必须有一个类含有 public static void main(String args[])方法，称这个类为应用程序的主类。 运行Java程序的时候注意：Java应用程序总是从主类的main方法开始执行，因此，需要进入主类字节码所在的目录(主类名.class)。 一个Java应用程序(也称为一个工程)是由若干个类组成的，这些类可以在一个源文件中，也可以分布在若干个源文件中。 如果应用程序的主类源文件和其他源文件在同一目录中，也可以只编译主类的源文件，Java系统会自动编译主类需要的其他源文件。 Java程序以类为“基本单位”，即一个java源程序是由若干个类所构成的。 一个Java程序可以将它使用的各个类分别存放在不同的源文件当中，也可以将它使用的类存放在一个源文件当中。 如果需要编译某个目录下的多个Java文件，在使用javac时，也可以将javac要编译的多个源文件用空格分离。例如:javac Car.java Person.java。]]></content>
      <categories>
        <category>Java入门教程</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cpp之const的用法]]></title>
    <url>%2F2018%2F05%2F19%2FCpp%E4%B9%8Bconst%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[关于const的有关知识今天先讲这些，等日后再进行补充……Tips:最后有视频推荐链接，不喜欢读文章可以看看视频。 控制变化的const 1.const与基本的数据类型如:1const int x = 3 //常量 变量名 储存地址 存储内容 x &amp;x 3 固定不变 2.const与指针类型五种定义形式:123456789const int *p = NULL; //1int const *p = NULL; //2 1和2完全等价int *const p = NULL; //3 另外一种情况const int * const p = NULL; //4 int const * const p = NULL; //5 4和5完全等价 下面我们通过例子来说明问题：1234int x = 3;const int *p = &amp;x; /*p = &amp;y; 正确,即允许让指针p再指向另外的一个地址。*p = 4; 错误，因为我们的const此时修饰的是*p */ 变量名 存储地址 存储内容 x &amp;x 3 p &amp;p &amp;x 12int x = 3;int *const p = &amp;x; //p = &amp;y; 错误，因为我们的const此时修饰的是指针p 变量名 存储地址 存储内容 x &amp;x 3 p &amp;p &amp;x 固定不变 12const int x = 3;const int *const p = &amp;x; //p = &amp;y; *p = 4;都是错误的 变量名 存储地址 存储内容 x &amp;x 3 固定不变 p &amp;p &amp;x 固定不变 3.const与引用123int x = 3;const int &amp;y = x; //x = 10;True //y = 20;False,因为y被const修饰。//y是x的别名，他们的值始终相同。所以修改x的值后y的值也被其改变。 4.总结一下1234567891011121314151617const int x = 3; x = 5; //False 常量不可以被赋值int x = 3; const int y = x; y = 5; //False y为常量，不可被赋值int x = 3; const int *y = &amp;x; *y = 5; //False const修饰的是*y.int x = 3, z = 4; int *const y = &amp;x; y = &amp;z; //False const修饰的是指针y.const int x = 3; const int &amp;y = x; y = 5; //False 前面有提到//!!! 下面看一个对比的例子const int x = 3; int *y = &amp;x; //False x比y的权限小，x有被其指针改变的风险int x = 3; int const *y = &amp;x; //True x比y的权限大，可以通过!!! 指针指向const修饰的变量时，应该是 const int *const p = &amp;x;//限制其权限 推荐大家用const来定义常量，因为相比于宏定义#define来说，使用const编译器会检查语法错误。 定义拷贝 构造函数 拷贝构造函数定义格式: 类名(const 类名&amp; 变量名)，例如:123456789class Student&#123;public: Student()&#123;m_strName = "x1aolin";&#125; Student(const Student&amp; stu)&#123;&#125; //!!!拷贝构造函数private: string m_strName;&#125;;//拷贝构造函数在实例化对象复制初始化或直接初始化时调用 const重出江湖 先从一个大家比较熟悉的例子说起: 12345678class Coordinate&#123;public: Coordinate(int x,int y);private:const int m_ix;const int m_iy;&#125;; 因为成员变量是两个常成员，所以不能用一般的构造函数进行初始化，需要用初始化列表。123Coordinate::Coordinate(int x,int y):m_ix(x),m_iy(y)&#123;&#125; 从这里可以看到，一般的对象成员是可以用const来修饰的，其实，对象成员也可以用const来修饰，我们把这类成员称为常对象成员。 1.常对象成员如果想要在类中实现对象成员一旦初始化就不允许再修改，那么就可以用const常对象成员,例如:12345678class Line&#123;public: Line(int x1,int y1,int x2,int y2);private: const Coordinate m_coorA; const Coordinate m_coorB;&#125; 初始化用实例化时传参+初始化列表进行操作。 2.常成员函数如果大家更加大胆些，就可能会想到一个问题:既然有了常对象成员，那么是否会有常成员函数？答案自然是肯定的，例如:12345678910class Coordinate&#123;public: Coordinate(int x,int y); void changeX() const; // &lt;--- 常成员函数 1 void changeX(); // 2 1和2互为重载private: int m_ix; int m_iy;&#125; 常对象就只能调用常成员函数，而非常对象就都可以调用。但是类似重载的情况就只能实例化一个常对象来进行调用常成员函数了。 在重载情况下调用常对象成员示例:123456int main()&#123; const Coordinate coor(1,2);// &lt;--- 常对象的定义方法 coor.changeX(); //此时调用的changeX()函数就是常成员函数了 return 0;&#125; !!! 常成员函数中不可以修改数据成员的值。 在上一次的博客:this的用法中已经详细介绍了关于this应该如何运用，这里不在赘述。1234void Coordinate::changeX() const&#123; m_ix = 10; //False 这是不被允许的，原因下面有。&#125; 其实上面的代码可以理解为:1234void changeX(const Coordinate *this)&#123; this-&gt;m_ix = 10; //上面也提到常指针是不可以改变的，所以不被允许。&#125; 定义常成员函数的方法:在.h文件中，在普通成员函数声明后面加上 const ，然后在其对应的.cpp文件定义中的对应定义函数后面加上 const 后面。注意在函数括号后面加一个小空格，防止编译错误。 如果大家对常对象和常成员函数还是很模糊，点击传送门,深入理解。 3.常指针与常引用示例的前提条件:1234567891011class Coordinate&#123;public: Coordinate(int x,int y); int getX(); int getY(); void printInfo() const; //注意这个是常成员函数private: int m_iX; int m_iY;&#125;; 下面我们来看看对象的引用和对象的指针如何来定义:12345678910int main()&#123; Coordinate coor1(3,5); Coordinate &amp;coor2 = coor1; //&lt;---对象的引用 Coordinate *pCoor = &amp;coor1; //&lt;---对象的指针 coor1.printInfo(); coor2.printInfo(); pCoor-&gt;printInfo(); return 0;&#125; 仿照上述代码即可实现对象的引用和指针，需要注意的是，使用对象的引用时，可将对象直接赋值给其”别名” ；使用对象的指针时，需要将对象取地址(即加取地址符号&amp;)进行赋值。正如大家所想，如果我们在定义它们的指针和引用时，在其前面加上const就是常对象和常指针了,示例如下:12345678910int main()&#123; Coordinate coor(3,5); const Coordinate &amp;coor2 = coor1; //&lt;---对象的常引用 const Coordinate *pCoor = &amp;coor1; //&lt;---对象的常指针 coor1.printInfo(); coor2.printInfo(); pCoor-&gt;printInfo(); return 0;&#125; !!! 常引用和常指针只有读权限，没有写权限，只能调用它的常成员函数。 下面看一个更加复杂的例子:12345678910int main()&#123; Coordinate coor1(3,5); Coordinate coor2(7,9); Coordinate * const pCoor = &amp;coor1; pCoor-&gt;getY(); //1 需要读写权限对象调用 pCoor = coor2; //2 pCoor-&gt;printInfo(); //3 仅需要读权限的对象就可以调用 return 0;&#125; 下面我们分析一下上面这几行代码,有哪个是错误的。首先看第三行定义代码，所在的位置是在const后面，所以意味着这个pCoor指针不能再指向其他的对象，但是它的权限时同时具备读和写的。所以1是对的,2是错的,3也是对的。 const最重要的是可以使读写权限转变成只读权限*。 推荐视频: 第一部分视频连接: 控制变化的const 第三部分视频链接: 常对象成员和常成员函数,常指针与常引用 tips:可能需要登录才可以看视频。]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白如何在ubuntu上进行C++开发]]></title>
    <url>%2F2018%2F05%2F18%2F%E5%B0%8F%E7%99%BD%E5%A6%82%E4%BD%95%E5%9C%A8ubuntu%E4%B8%8A%E8%BF%9B%E8%A1%8CC-%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[对于初入ubuntu开发的小白来说，这的确是一个严峻的挑战。当然，在linux下的IDE也很多，但是既然想成为一个合格的开发者，最好是要理解开发的整个过程。本文也是在查阅了大量的资料后的一个小总结，仅供大家参考。 1.编写程序本文选用的是vim，当今比较主流的一个文本编辑器。 把Vim打造成牛逼的C++ IDE 一步步将vim改造成C/C++开发环境(IDE) 其实都是大同小异啦。当然，如果你不想这么做，没人管你，不过对于那些刚刚从Windows转过来的童鞋还是很需要的。 如果你实在是想选取IDE的话，这里有很多的推荐,推荐2。 2.编译程序 说到这，就不得不提强大的gcc了，它的用法点这里。 了解的多了，就会有人产生一些疑惑，比如cc与gcc或者gcc与g++。 对于有个大型的C++工程来说，就不得不提makefile了，这个链接关于Makefile比较清晰。 支持原创请移步陈皓博客:https://blog.csdn.net/haoel/article/details/2886 当然我自己的博客也有写:跟我一起学写makefile。 3.运行程序 cd 到需要运行程序所在目录,运行命令 ./ xxx(文件名)即可。 自己编写成功的程序肯定是可以运行的，下载的程序可能会有权限问题。 权限问题解决请自己查阅资料解决。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟我一起学写makefile]]></title>
    <url>%2F2018%2F05%2F17%2F%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6%E5%86%99makefile%2F</url>
    <content type="text"><![CDATA[未完待续…… 写在前面作者在写本文时，着重参考了CSDN博客作者陈皓的博客，在此表示十分感谢。 对于大多数用Windows学编程的同学也许不知道makefile这个东西，因为Windows的IDE为你做了这个工作。最近打算转战Unix系统，所以在被逼无奈之下，了解了一下makefile，在此写出同大家一起分享。 Question：什么是makefile？ makefile关系了整个工程的编译规则，在一个工程中，源文件不计其数，其按照类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定那个文件需要先编译，那个文件需要后编译，那些文件需要重新编译，甚至于更加复杂的功能操作，，这里的makefile就像是一个shell脚本一样，其中也可以执行操作的命令。 makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具。 程序的编译和链接 一般来说，无论是C，C++，还是pas，首先要把源文件编译成中间代码文件，Windows下为.obj文件，Unix下是.o文件，即 Object File，这个动作叫做编译(compile)。然后再把大量的Object File合成可执行文件，这个动作叫做链接（link）。 编译时，编译器需要的是语法的正确，函数与变量的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（这里的头文件只要声明），只要所有的语法正确，编译器就可以编译出中间文件。一般来说，每个源文件都应该对应于一个中间文件。 链接时，主要是链接函数和全局变量。链接器并不管函数所在的源文件，只要函数的中间文件(Object File)，在大多数时候，由于源文件太多，对应编译生成的中间目标文件（.o）太多，而在连接时需要明显的指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”(Library File),即.lib文件，在UNIX下，是Archive File,也就是.a文件。 总而言之,源文件首先会生成中间目标文件（.obj或.o），再由中间目标文件生成执行文件。编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），你需要指定函数的Object File。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cpp之This指针]]></title>
    <url>%2F2018%2F05%2F17%2FCpp%E4%B9%8BThis%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[1.this指针: 指向自身数据的指针举例如下：123456789class Array //代码1&#123;public: Array(int _len)&#123;len = _len;&#125; int getlen()&#123;return len;&#125; void setlen(int _len)&#123;len = _len;&#125;private: int len;&#125;; 这里数据成员和参数在表达相同意思时用的是不同的变量，所以如果想用相同的变量就需要一个标记来区分该变量时数据成员还是参数,即this指针。 123456789class Array //代码2&#123;public: Array(int len)&#123;this-&gt;len = len;&#125; int getlen()&#123;return len;&#125; void setlen(int len)&#123;this-&gt;len = len;&#125;private: int len;&#125;; 这样，用this指针指明了数据成员，就可以用相同的变量来进行表示了。 Question：为什么成员函数可以直接访问数据成员？ 知识准备: 对象结构在进行对多个对象实例化的时候，在内存中会定义对应多个数据成员，但是成员函数只有一份，储存在代码区。而且每个对象进行调用的时候，每个对象都能够准确无误的进行调用。大家有没有想过这是为什么呢？其实这就是this指针的功劳。 我们来看下面这个例子：123456789class Array //代码3&#123;public: Array(T *this,int _len)&#123;this-&gt;len = _len;&#125; int getlen(T *this)&#123;return this-&gt;len;&#125; void setlen(T *this,int _len)&#123;this-&gt;len = _len;&#125;private: int len;&#125;; 大家是不是发现了和第一个例子的区别？显而易见，就是每个成员函数都加了一个this指针，这样上面所提到的问题就迎刃而解了。我们设想一下，当我们去实例化一个对象并使用他们的成员函数时，this指针就代表这个对象本身的地址，也就是说当我们调用成员函数时,编译器会悄悄地把代码1转换成代码3，所以每次调用成员函数，都是改变对应对象的成员变量。 上面说了，编译器自动的为每个成员函数的参数列表都加了一个this指针, Thus，我们只需要理解就可，没有必要自己显式的写出来。 推荐视频：如何理解this指针? Tips: 看视频需要注册账号，只有注册登录才可以看视频。]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown简单用法]]></title>
    <url>%2F2018%2F05%2F11%2Fmarkdown%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文是作者第一篇hexo博客，排版等问题不足之处请见谅。 1.Markdown官方文档及其他参考 特别感谢简书刘邓诏初的blog对本文的帮助 Markdown语法入门 官方文档详细版 2.常用语法规则标题共六级标题，用#的累计来进行区分，#号越少字号越大下面给出相应代码，如图所示： 换行和分段 换行：只需要在行末加两个空格键和一个回车 分段：段落之间空一行即可 文本样式 加粗: 加粗 斜体: 斜体 删除线: 删除线 底纹: 底纹 引用只要将文本内容之前加[ &gt;(大于号) ]即可将文本变成引用文本。 我是引用文本 图片和链接 图片格式: ! [图片描述] (链接的地址) 链接: [文本内容] (链接的地址) 如果是本地的图片可以参考: hexo生成blog本地图片插入方法 实际用时在 感叹号，中括号和小括号 之间不能有空格，这里只是为了展示效果 水平线三个[ - ]或者[ * ]都可以画出一条水平分割线 实现方式: 表格在markdown制作表格非常麻烦，必须要画出来！！！ 脚注脚注成对出现，[^1]作为标记，可以点击调至末尾注解。[^1]填写注解，不论写在什么位置，都会出现在文章的末尾。 注释注释是给自己看的，预览和发布时都不会出现。 end: 暂时先总结这些，实现了最基础的一些功能,能满足大家的一定需要，对markdown有兴趣却还没有基础的小白可以看看，大神请绕道，等日后再慢慢更新… 5月16日补充： 代码框的三种形式 两对’’’包裹 代码前面加两个空格键 代码前面加一个TAB键 让hexo代码高亮格式：123456&gt;```语言名 （比如cpp） &gt; #include &lt; iostream&gt;&gt; using namespace std;&gt; ...&gt;``` //第一行说明语言，下面是代码内容&gt; 点击这里可以查看代码高亮支持格式和化名 特别感谢：https://www.jianshu.com/p/0130ad32a08d]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim+插件实现markdown功能]]></title>
    <url>%2F2018%2F05%2F11%2Fvim-%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0markdown%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[具体请参考：https://www.jianshu.com/p/44d31327f953里面实现了从小白到搭建好markdown的所有过程。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>示例</category>
      </categories>
      <tags>
        <tag>hello World</tag>
      </tags>
  </entry>
</search>
