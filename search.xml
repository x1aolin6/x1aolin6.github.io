<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cpp之const的用法]]></title>
    <url>%2F2018%2F05%2F19%2FCpp%E4%B9%8Bconst%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[关于const的有关知识今天先讲这些，等日后再进行补充……Tips:最后有视频推荐链接，不喜欢读文章可以看看视频。 控制变化的const 1.const与基本的数据类型如:1const int x = 3 //常量 变量名 储存地址 存储内容 x &amp;x 3 固定不变 2.const与指针类型五种定义形式:123456789const int *p = NULL; //1int const *p = NULL; //2 1和2完全等价int *const p = NULL; //3 另外一种情况const int * const p = NULL; //4 int const * const p = NULL; //5 4和5完全等价 下面我们通过例子来说明问题：1234int x = 3;const int *p = &amp;x; /*p = &amp;y; 正确,即允许让指针p再指向另外的一个地址。*p = 4; 错误，因为我们的const此时修饰的是*p */ 变量名 存储地址 存储内容 x &amp;x 3 p &amp;p &amp;x 12int x = 3;int *const p = &amp;x; //p = &amp;y; 错误，因为我们的const此时修饰的是指针p 变量名 存储地址 存储内容 x &amp;x 3 p &amp;p &amp;x 固定不变 12const int x = 3;const int *const p = &amp;x; //p = &amp;y; *p = 4;都是错误的 变量名 存储地址 存储内容 x &amp;x 3 固定不变 p &amp;p &amp;x 固定不变 3.const与引用123int x = 3;const int &amp;y = x; //x = 10;True //y = 20;False,因为y被const修饰。//y是x的别名，他们的值始终相同。所以修改x的值后y的值也被其改变。 4.总结一下1234567891011121314151617const int x = 3; x = 5; //False 常量不可以被赋值int x = 3; const int y = x; y = 5; //False y为常量，不可被赋值int x = 3; const int *y = &amp;x; *y = 5; //False const修饰的是*y.int x = 3, z = 4; int *const y = &amp;x; y = &amp;z; //False const修饰的是指针y.const int x = 3; const int &amp;y = x; y = 5; //False 前面有提到//!!! 下面看一个对比的例子const int x = 3; int *y = &amp;x; //False x比y的权限小，x有被其指针改变的风险int x = 3; int const *y = &amp;x; //True x比y的权限大，可以通过!!! 指针指向const修饰的变量时，应该是 const int *const p = &amp;x;//限制其权限 推荐大家用const来定义常量，因为相比于宏定义#define来说，使用const编译器会检查语法错误。 定义拷贝 构造函数 拷贝构造函数定义格式: 类名(const 类名&amp; 变量名)，例如:123456789class Student&#123;public: Student()&#123;m_strName = "x1aolin";&#125; Student(const Student&amp; stu)&#123;&#125; //!!!拷贝构造函数private: string m_strName;&#125;;//拷贝构造函数在实例化对象复制初始化或直接初始化时调用 const重出江湖 先从一个大家比较熟悉的例子说起: 12345678class Coordinate&#123;public: Coordinate(int x,int y);private:const int m_ix;const int m_iy;&#125;; 因为成员变量是两个常成员，所以不能用一般的构造函数进行初始化，需要用初始化列表。123Coordinate::Coordinate(int x,int y):m_ix(x),m_iy(y)&#123;&#125; 从这里可以看到，一般的对象成员是可以用const来修饰的，其实，对象成员也可以用const来修饰，我们把这类成员称为常对象成员。 1.常对象成员如果想要在类中实现对象成员一旦初始化就不允许再修改，那么就可以用const常对象成员,例如:12345678class Line&#123;public: Line(int x1,int y1,int x2,int y2);private: const Coordinate m_coorA; const Coordinate m_coorB;&#125; 初始化用实例化时传参+初始化列表进行操作。 2.常成员函数如果大家更加大胆些，就可能会想到一个问题:既然有了常对象成员，那么是否会有常成员函数？答案自然是肯定的，例如:12345678910class Coordinate&#123;public: Coordinate(int x,int y); void changeX() const; // &lt;--- 常成员函数 1 void changeX(); // 2 1和2互为重载private: int m_ix; int m_iy;&#125; 常对象就只能调用常成员函数，而非常对象就都可以调用。但是类似重载的情况就只能实例化一个常对象来进行调用常成员函数了。 在重载情况下调用常对象成员示例:123456int main()&#123; const Coordinate coor(1,2);// &lt;--- 常对象的定义方法 coor.changeX(); //此时调用的changeX()函数就是常成员函数了 return 0;&#125; !!! 常成员函数中不可以修改数据成员的值。 在上一次的博客:this的用法中已经详细介绍了关于this应该如何运用，这里不在赘述。1234void Coordinate::changeX() const&#123; m_ix = 10; //False 这是不被允许的，原因下面有。&#125; 其实上面的代码可以理解为:1234void changeX(const Coordinate *this)&#123; this-&gt;m_ix = 10; //上面也提到常指针是不可以改变的，所以不被允许。&#125; 定义常成员函数的方法:在.h文件中，在普通成员函数声明后面加上 const ，然后在其对应的.cpp文件定义中的对应定义函数后面加上 const 后面。注意在函数括号后面加一个小空格，防止编译错误。 如果大家对常对象和常成员函数还是很模糊，点击传送门,深入理解。 3.常指针与常引用示例的前提条件:1234567891011class Coordinate&#123;public: Coordinate(int x,int y); int getX(); int getY(); void printInfo() const; //注意这个是常成员函数private: int m_iX; int m_iY;&#125;; 下面我们来看看对象的引用和对象的指针如何来定义:12345678910int main()&#123; Coordinate coor1(3,5); Coordinate &amp;coor2 = coor1; //&lt;---对象的引用 Coordinate *pCoor = &amp;coor1; //&lt;---对象的指针 coor1.printInfo(); coor2.printInfo(); pCoor-&gt;printInfo(); return 0;&#125; 仿照上述代码即可实现对象的引用和指针，需要注意的是，使用对象的引用时，可将对象直接赋值给其”别名” ；使用对象的指针时，需要将对象取地址(即加取地址符号&amp;)进行赋值。正如大家所想，如果我们在定义它们的指针和引用时，在其前面加上const就是常对象和常指针了,示例如下:12345678910int main()&#123; Coordinate coor(3,5); const Coordinate &amp;coor2 = coor1; //&lt;---对象的常引用 const Coordinate *pCoor = &amp;coor1; //&lt;---对象的常指针 coor1.printInfo(); coor2.printInfo(); pCoor-&gt;printInfo(); return 0;&#125; !!! 常引用和常指针只有读权限，没有写权限，只能调用它的常成员函数。 下面看一个更加复杂的例子:12345678910int main()&#123; Coordinate coor1(3,5); Coordinate coor2(7,9); Coordinate * const pCoor = &amp;coor1; pCoor-&gt;getY(); //1 需要读写权限对象调用 pCoor = coor2; //2 pCoor-&gt;printInfo(); //3 仅需要读权限的对象就可以调用 return 0;&#125; 下面我们分析一下上面这几行代码,有哪个是错误的。首先看第三行定义代码，所在的位置是在const后面，所以意味着这个pCoor指针不能再指向其他的对象，但是它的权限时同时具备读和写的。所以1是对的,2是错的,3也是对的。 const最重要的是可以使读写权限转变成只读权限*。 推荐视频: 第一部分视频连接: 控制变化的const 第三部分视频链接: 常对象成员和常成员函数,常指针与常引用 tips:可能需要登录才可以看视频。]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白如何在ubuntu上进行C++开发]]></title>
    <url>%2F2018%2F05%2F18%2F%E5%B0%8F%E7%99%BD%E5%A6%82%E4%BD%95%E5%9C%A8ubuntu%E4%B8%8A%E8%BF%9B%E8%A1%8CC-%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[对于初入ubuntu开发的小白来说，这的确是一个严峻的挑战。当然，在linux下的IDE也很多，但是既然想成为一个合格的开发者，最好是要理解开发的整个过程。本文也是在查阅了大量的资料后的一个小总结，仅供大家参考。 1.编写程序本文选用的是vim，当今比较主流的一个文本编辑器。 把Vim打造成牛逼的C++ IDE 一步步将vim改造成C/C++开发环境(IDE) 其实都是大同小异啦。当然，如果你不想这么做，没人管你，不过对于那些刚刚从Windows转过来的童鞋还是很需要的。 如果你实在是想选取IDE的话，这里有很多的推荐,推荐2。 2.编译程序 说到这，就不得不提强大的gcc了，它的用法点这里。 了解的多了，就会有人产生一些疑惑，比如cc与gcc或者gcc与g++。 对于有个大型的C++工程来说，就不得不提makefile了，这个链接关于Makefile比较清晰。 支持原创请移步陈皓博客:https://blog.csdn.net/haoel/article/details/2886 当然我自己的博客也有写:跟我一起学写makefile。 3.运行程序 cd 到需要运行程序所在目录,运行命令 ./ xxx(文件名)即可。 自己编写成功的程序肯定是可以运行的，下载的程序可能会有权限问题。 权限问题解决请自己查阅资料解决。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟我一起学写makefile]]></title>
    <url>%2F2018%2F05%2F17%2F%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6%E5%86%99makefile%2F</url>
    <content type="text"><![CDATA[未完待续…… 写在前面作者在写本文时，着重参考了CSDN博客作者陈皓的博客，在此表示十分感谢。 对于大多数用Windows学编程的同学也许不知道makefile这个东西，因为Windows的IDE为你做了这个工作。最近打算转战Unix系统，所以在被逼无奈之下，了解了一下makefile，在此写出同大家一起分享。 Question：什么是makefile？ makefile关系了整个工程的编译规则，在一个工程中，源文件不计其数，其按照类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定那个文件需要先编译，那个文件需要后编译，那些文件需要重新编译，甚至于更加复杂的功能操作，，这里的makefile就像是一个shell脚本一样，其中也可以执行操作的命令。 makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具。 程序的编译和链接 一般来说，无论是C，C++，还是pas，首先要把源文件编译成中间代码文件，Windows下为.obj文件，Unix下是.o文件，即 Object File，这个动作叫做编译(compile)。然后再把大量的Object File合成可执行文件，这个动作叫做链接（link）。 编译时，编译器需要的是语法的正确，函数与变量的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（这里的头文件只要声明），只要所有的语法正确，编译器就可以编译出中间文件。一般来说，每个源文件都应该对应于一个中间文件。 链接时，主要是链接函数和全局变量。链接器并不管函数所在的源文件，只要函数的中间文件(Object File)，在大多数时候，由于源文件太多，对应编译生成的中间目标文件（.o）太多，而在连接时需要明显的指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”(Library File),即.lib文件，在UNIX下，是Archive File,也就是.a文件。 总而言之,源文件首先会生成中间目标文件（.obj或.o），再由中间目标文件生成执行文件。编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），你需要指定函数的Object File。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cpp之This指针]]></title>
    <url>%2F2018%2F05%2F17%2FCpp%E4%B9%8BThis%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[1.this指针: 指向自身数据的指针举例如下：123456789class Array //代码1&#123;public: Array(int _len)&#123;len = _len;&#125; int getlen()&#123;return len;&#125; void setlen(int _len)&#123;len = _len;&#125;private: int len;&#125;; 这里数据成员和参数在表达相同意思时用的是不同的变量，所以如果想用相同的变量就需要一个标记来区分该变量时数据成员还是参数,即this指针。 123456789class Array //代码2&#123;public: Array(int len)&#123;this-&gt;len = len;&#125; int getlen()&#123;return len;&#125; void setlen(int len)&#123;this-&gt;len = len;&#125;private: int len;&#125;; 这样，用this指针指明了数据成员，就可以用相同的变量来进行表示了。 Question：为什么成员函数可以直接访问数据成员？ 知识准备: 对象结构在进行对多个对象实例化的时候，在内存中会定义对应多个数据成员，但是成员函数只有一份，储存在代码区。而且每个对象进行调用的时候，每个对象都能够准确无误的进行调用。大家有没有想过这是为什么呢？其实这就是this指针的功劳。 我们来看下面这个例子：123456789class Array //代码3&#123;public: Array(T *this,int _len)&#123;this-&gt;len = _len;&#125; int getlen(T *this)&#123;return this-&gt;len;&#125; void setlen(T *this,int _len)&#123;this-&gt;len = _len;&#125;private: int len;&#125;; 大家是不是发现了和第一个例子的区别？显而易见，就是每个成员函数都加了一个this指针，这样上面所提到的问题就迎刃而解了。我们设想一下，当我们去实例化一个对象并使用他们的成员函数时，this指针就代表这个对象本身的地址，也就是说当我们调用成员函数时,编译器会悄悄地把代码1转换成代码3，所以每次调用成员函数，都是改变对应对象的成员变量。 上面说了，编译器自动的为每个成员函数的参数列表都加了一个this指针, Thus，我们只需要理解就可，没有必要自己显式的写出来。 推荐视频：如何理解this指针? Tips: 看视频需要注册账号，只有注册登录才可以看视频。]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown简单用法]]></title>
    <url>%2F2018%2F05%2F11%2Fmarkdown%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文是作者第一篇hexo博客，排版等问题不足之处请见谅。 1.Markdown官方文档及其他参考 特别感谢简书刘邓诏初的blog对本文的帮助 Markdown语法入门 官方文档详细版 2.常用语法规则标题共六级标题，用#的累计来进行区分，#号越少字号越大下面给出相应代码，如图所示： 换行和分段 换行：只需要在行末加两个空格键和一个回车 分段：段落之间空一行即可 文本样式 加粗: 加粗 斜体: 斜体 删除线: 删除线 底纹: 底纹 引用只要将文本内容之前加[ &gt;(大于号) ]即可将文本变成引用文本。 我是引用文本 图片和链接 图片格式: ! [图片描述] (链接的地址) 链接: [文本内容] (链接的地址) 如果是本地的图片可以参考: hexo生成blog本地图片插入方法 实际用时在 感叹号，中括号和小括号 之间不能有空格，这里只是为了展示效果 水平线三个[ - ]或者[ * ]都可以画出一条水平分割线 实现方式: 表格在markdown制作表格非常麻烦，必须要画出来！！！ 脚注脚注成对出现，[^1]作为标记，可以点击调至末尾注解。[^1]填写注解，不论写在什么位置，都会出现在文章的末尾。 注释注释是给自己看的，预览和发布时都不会出现。 end: 暂时先总结这些，实现了最基础的一些功能,能满足大家的一定需要，对markdown有兴趣却还没有基础的小白可以看看，大神请绕道，等日后再慢慢更新… 5月16日补充： 代码框的三种形式 两对’’’包裹 代码前面加两个空格键 代码前面加一个TAB键 让hexo代码高亮格式：123456&gt;```语言名 （比如cpp） &gt; #include &lt; iostream&gt;&gt; using namespace std;&gt; ...&gt;``` //第一行说明语言，下面是代码内容&gt; 点击这里可以查看代码高亮支持格式和化名 特别感谢：https://www.jianshu.com/p/0130ad32a08d]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim+插件实现markdown功能]]></title>
    <url>%2F2018%2F05%2F11%2Fvim-%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0markdown%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[具体请参考：https://www.jianshu.com/p/44d31327f953里面实现了从小白到搭建好markdown的所有过程。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>示例</category>
      </categories>
      <tags>
        <tag>hello World</tag>
      </tags>
  </entry>
</search>
