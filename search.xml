<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Cpp之const的用法</title>
      <link href="/2018/05/19/Cpp%E4%B9%8Bconst%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2018/05/19/Cpp%E4%B9%8Bconst%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote><p>关于const的有关知识今天先讲这些，等日后再进行补充……<br>Tips:<em>最后有视频推荐链接</em>，不喜欢读文章可以看看视频。</p></blockquote><h3 id="控制变化的const"><a href="#控制变化的const" class="headerlink" title="控制变化的const"></a>控制变化的const</h3><hr><h4 id="1-const与基本的数据类型"><a href="#1-const与基本的数据类型" class="headerlink" title="1.const与基本的数据类型"></a>1.const与基本的数据类型</h4><p>如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span> <span class="comment">//常量</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">储存地址</th><th style="text-align:center">存储内容</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">&amp;x</td><td style="text-align:center"><code>3</code>  固定不变</td></tr></tbody></table><a id="more"></a><h4 id="2-const与指针类型"><a href="#2-const与指针类型" class="headerlink" title="2.const与指针类型"></a>2.const与指针类型</h4><p>五种定义形式:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">NULL</span>;    <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p = <span class="literal">NULL</span>;    <span class="comment">//2  1和2完全等价</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = <span class="literal">NULL</span>;    <span class="comment">//3  另外一种情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = <span class="literal">NULL</span>;  <span class="comment">//4 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p = <span class="literal">NULL</span>;  <span class="comment">//5  4和5完全等价</span></span><br></pre></td></tr></table></figure></p><p>下面我们通过例子来说明问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;x;    <span class="comment">/*</span></span><br><span class="line"><span class="comment">p = &amp;y; 正确,即允许让指针p再指向另外的一个地址。</span></span><br><span class="line"><span class="comment">*p = 4; 错误，因为我们的const此时修饰的是*p    */</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">存储地址</th><th style="text-align:center">存储内容</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">&amp;x</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">&amp;p</td><td style="text-align:center">&amp;x</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;x;    <span class="comment">//p = &amp;y; 错误，因为我们的const此时修饰的是指针p</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">存储地址</th><th style="text-align:center">存储内容</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">&amp;x</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">&amp;p</td><td style="text-align:center"><code>&amp;x</code>  固定不变</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;x;    <span class="comment">//p = &amp;y; *p = 4;都是错误的</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">存储地址</th><th style="text-align:center">存储内容</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">&amp;x</td><td style="text-align:center"><code>3</code>   固定不变</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">&amp;p</td><td style="text-align:center"><code>&amp;x</code>  固定不变</td></tr></tbody></table><h4 id="3-const与引用"><a href="#3-const与引用" class="headerlink" title="3.const与引用"></a>3.const与引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;y = x;    <span class="comment">//x = 10;True //y = 20;False,因为y被const修饰。</span></span><br><span class="line"><span class="comment">//y是x的别名，他们的值始终相同。所以修改x的值后y的值也被其改变。</span></span><br></pre></td></tr></table></figure><h4 id="4-总结一下"><a href="#4-总结一下" class="headerlink" title="4.总结一下"></a>4.总结一下</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span>;  x = <span class="number">5</span>; <span class="comment">//False 常量不可以被赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;  <span class="keyword">const</span> <span class="keyword">int</span> y = x; y = <span class="number">5</span>; <span class="comment">//False y为常量，不可被赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;  <span class="keyword">const</span> <span class="keyword">int</span> *y = &amp;x; *y = <span class="number">5</span>; <span class="comment">//False const修饰的是*y.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>, z = <span class="number">4</span>; <span class="keyword">int</span> *<span class="keyword">const</span> y = &amp;x; y = &amp;z; <span class="comment">//False const修饰的是指针y.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span>; <span class="keyword">const</span> <span class="keyword">int</span> &amp;y = x; y = <span class="number">5</span>; <span class="comment">//False 前面有提到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//!!! 下面看一个对比的例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span>; <span class="keyword">int</span> *y = &amp;x;  <span class="comment">//False x比y的权限小，x有被其指针改变的风险</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>; <span class="keyword">int</span> <span class="keyword">const</span> *y = &amp;x;  <span class="comment">//True x比y的权限大，可以通过</span></span><br><span class="line"></span><br><span class="line">!!! 指针指向<span class="keyword">const</span>修饰的变量时，应该是 <span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;x;<span class="comment">//限制其权限</span></span><br></pre></td></tr></table></figure><blockquote><p>推荐大家用const来定义常量，因为相比于宏定义#define来说，使用const编译器会检查语法错误。  </p></blockquote><h3 id="定义拷贝-构造函数"><a href="#定义拷贝-构造函数" class="headerlink" title="定义拷贝 构造函数"></a>定义拷贝 构造函数</h3><hr><p>拷贝构造函数定义格式: 类名(const 类名&amp; 变量名)，例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Student()&#123;m_strName = <span class="string">"x1aolin"</span>;&#125;</span><br><span class="line">   Student(<span class="keyword">const</span> Student&amp; stu)&#123;&#125;    <span class="comment">//!!!拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="built_in">string</span> m_strName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//拷贝构造函数在实例化对象复制初始化或直接初始化时调用</span></span><br></pre></td></tr></table></figure></p><h3 id="const重出江湖"><a href="#const重出江湖" class="headerlink" title="const重出江湖"></a>const重出江湖</h3><hr><p>先从一个大家比较熟悉的例子说起:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Coordinate(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_ix;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_iy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为成员变量是两个常成员，所以不能用一般的构造函数进行初始化，需要用初始化列表。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Coordinate::Coordinate(<span class="keyword">int</span> x,<span class="keyword">int</span> y):m_ix(x),m_iy(y)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这里可以看到，一般的对象成员是可以用const来修饰的，其实，对象成员也可以<br>用const来修饰，我们把这类成员称为常对象成员。</p><h4 id="1-常对象成员"><a href="#1-常对象成员" class="headerlink" title="1.常对象成员"></a>1.常对象成员</h4><p>如果想要在类中实现对象成员一旦初始化就不允许再修改，那么就可以用const常对象成员,例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Line(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">const</span> Coordinate m_coorA;</span><br><span class="line">   <span class="keyword">const</span> Coordinate m_coorB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化用实例化时传参+初始化列表进行操作。</p><h4 id="2-常成员函数"><a href="#2-常成员函数" class="headerlink" title="2.常成员函数"></a>2.常成员函数</h4><p>如果大家更加大胆些，就可能会想到一个问题:既然有了常对象成员，那么是否会有常成员函数？答案自然是肯定的，例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Coordinate(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">changeX</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// &lt;--- 常成员函数 1</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">changeX</span><span class="params">()</span></span>;    <span class="comment">// 2 1和2互为重载</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> m_ix;</span><br><span class="line">   <span class="keyword">int</span> m_iy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><em>常对象就只能调用常成员函数，而非常对象就都可以调用。但是类似重载的情况就只能实例化一个常对象来进行调用常成员函数了</em>。</p></blockquote><p>在重载情况下调用常对象成员示例:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Coordinate <span class="title">coor</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">// &lt;--- 常对象的定义方法</span></span><br><span class="line">coor.changeX();    <span class="comment">//此时调用的changeX()函数就是常成员函数了</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><em>!!! 常成员函数中不可以修改数据成员的值</em>。</p></blockquote><p>在上一次的<a href="http://x1aolin6.top/2018/05/17/Cpp-%E5%B0%81%E8%A3%85%E7%AF%87/">博客:this的用法</a>中已经详细介绍了关于this应该如何运用，这里不在赘述。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Coordinate::changeX() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    m_ix = <span class="number">10</span>; <span class="comment">//False 这是不被允许的，原因下面有。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实上面的代码可以理解为:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeX</span><span class="params">(<span class="keyword">const</span> Coordinate *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_ix = <span class="number">10</span>; <span class="comment">//上面也提到常指针是不可以改变的，所以不被允许。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>定义常成员函数的方法</strong>:<br>在.h文件中，在普通成员函数声明后面加上 const ，然后在其对应的.cpp文件定义<br>中的对应定义函数后面加上 const 后面。注意在函数括号后面加一个小空格，防止编译错误。</p><blockquote><p><em>如果大家对常对象和常成员函数还是很模糊，点击<a href="http://www.jb51.net/article/84409.htm" target="_blank" rel="noopener">传送门</a>,深入理解</em>。</p></blockquote><h4 id="3-常指针与常引用"><a href="#3-常指针与常引用" class="headerlink" title="3.常指针与常引用"></a>3.常指针与常引用</h4><p>示例的前提条件:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Coordinate(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//注意这个是常成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> m_iX;</span><br><span class="line">   <span class="keyword">int</span> m_iY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>下面我们来看看对象的引用和对象的指针如何来定义:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Coordinate <span class="title">coor1</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">   Coordinate &amp;coor2 = coor1;  <span class="comment">//&lt;---对象的引用</span></span><br><span class="line">   Coordinate *pCoor = &amp;coor1; <span class="comment">//&lt;---对象的指针</span></span><br><span class="line">   coor1.printInfo();</span><br><span class="line">   coor2.printInfo();</span><br><span class="line">   pCoor-&gt;printInfo();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仿照上述代码即可实现对象的引用和指针，需要注意的是，使用对象的引用时，可将对象直接赋值给其”别名” ；使用对象的指针时，需要将对象取地址(即加取地址符号&amp;)进行赋值。<br>正如大家所想，如果我们在定义它们的指针和引用时，在其前面加上<code>const</code>就是常对象和常指针了,示例如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">Coordinate <span class="title">coor</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> Coordinate &amp;coor2 = coor1;  <span class="comment">//&lt;---对象的常引用</span></span><br><span class="line">    <span class="keyword">const</span> Coordinate *pCoor = &amp;coor1; <span class="comment">//&lt;---对象的常指针</span></span><br><span class="line">    coor1.printInfo();</span><br><span class="line">    coor2.printInfo();</span><br><span class="line">    pCoor-&gt;printInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><em>!!! 常引用和常指针只有读权限，没有写权限，只能调用它的常成员函数</em>。</p></blockquote><p>下面看一个更加复杂的例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Coordinate <span class="title">coor1</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Coordinate <span class="title">coor2</span><span class="params">(<span class="number">7</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">Coordinate * <span class="keyword">const</span> pCoor = &amp;coor1;</span><br><span class="line">pCoor-&gt;getY();       <span class="comment">//1  需要读写权限对象调用</span></span><br><span class="line">pCoor = coor2;       <span class="comment">//2</span></span><br><span class="line">pCoor-&gt;printInfo();  <span class="comment">//3  仅需要读权限的对象就可以调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们分析一下上面这几行代码,有哪个是错误的。首先看第三行定义代码，<em>所在的位置是在<code>const</code>后面，所以意味着这个pCoor指针不能再指向其他的对象，<br>但是它的权限时同时具备读和写的。所以<code>1</code>是对的,<code>2</code>是错的,<code>3</code>也是对的。  </em>const最重要的是可以使读写权限转变成只读权限*。</p><p><em>推荐视频</em>:  </p><ul><li>第一部分视频连接: <a href="https://www.imooc.com/video/7423" target="_blank" rel="noopener">控制变化的const</a></li><li>第三部分视频链接: <a href="https://www.imooc.com/video/8143" target="_blank" rel="noopener">常对象成员和常成员函数</a>,<a href="https://www.imooc.com/video/8161" target="_blank" rel="noopener">常指针与常引用</a><blockquote><p>tips:可能需要登录才可以看视频。</p></blockquote></li></ul>]]></content>
      
      
        <tags>
            
            <tag> C++面向对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小白如何在ubuntu上进行C++开发</title>
      <link href="/2018/05/18/%E5%B0%8F%E7%99%BD%E5%A6%82%E4%BD%95%E5%9C%A8ubuntu%E4%B8%8A%E8%BF%9B%E8%A1%8CC-%E5%BC%80%E5%8F%91/"/>
      <url>/2018/05/18/%E5%B0%8F%E7%99%BD%E5%A6%82%E4%BD%95%E5%9C%A8ubuntu%E4%B8%8A%E8%BF%9B%E8%A1%8CC-%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<blockquote><p>对于初入ubuntu开发的小白来说，这的确是一个严峻的挑战。当然，在linux下的IDE也很多，但是既然想成为一个合格的开发者，最好是要理解开发的整个过程。本文也是在查阅了大量的资料后的一个小总结，仅供大家参考。</p></blockquote><h4 id="1-编写程序"><a href="#1-编写程序" class="headerlink" title="1.编写程序"></a>1.编写程序</h4><p>本文选用的是vim，当今比较主流的一个文本编辑器。</p><ul><li><a href="https://blog.csdn.net/doc_sgl/article/details/47205779" target="_blank" rel="noopener">把Vim打造成牛逼的C++ IDE</a></li><li><a href="https://blog.csdn.net/yinjiabin/article/details/8254609" target="_blank" rel="noopener">一步步将vim改造成C/C++开发环境(IDE)</a></li><li>其实都是大同小异啦。当然，如果你不想这么做，没人管你，不过对于那些刚刚从Windows转过来的童鞋还是很需要的。</li><li>如果你实在是想选取IDE的话，<a href="https://linux.cn/article-5078-weibo.html" target="_blank" rel="noopener">这里有很多的推荐</a>,<a href="https://linux.cn/article-5078-2.html" target="_blank" rel="noopener">推荐2</a>。</li></ul><h4 id="2-编译程序"><a href="#2-编译程序" class="headerlink" title="2.编译程序"></a>2.编译程序</h4><ul><li>说到这，就不得不提强大的gcc了，它的用法<a href="http://man.linuxde.net/gcc" target="_blank" rel="noopener">点这里</a>。</li><li>了解的多了，就会有人产生一些疑惑，比如<a href="https://www.cnblogs.com/zhouyinhui/archive/2010/02/01/1661078.html" target="_blank" rel="noopener">cc与gcc</a>或者<a href="http://www.cnblogs.com/xiedan/archive/2009/10/25/1589462.html" target="_blank" rel="noopener">gcc与g++</a>。</li><li>对于有个大型的C++工程来说，就不得不提<a href="https://blog.csdn.net/ruglcc/article/details/7814546/" target="_blank" rel="noopener">makefile</a>了，这个链接关于Makefile比较清晰。</li><li><p>支持原创请移步陈皓博客:<a href="https://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="noopener">https://blog.csdn.net/haoel/article/details/2886</a></p></li><li><p>当然我自己的博客也有写:<a href="http://x1aolin6.top/2018/05/17/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6%E5%86%99makefile/">跟我一起学写makefile</a>。</p></li></ul><h4 id="3-运行程序"><a href="#3-运行程序" class="headerlink" title="3.运行程序"></a>3.运行程序</h4><ul><li>cd 到需要运行程序所在目录,运行命令 ./ xxx(文件名)即可。</li><li>自己编写成功的程序肯定是可以运行的，下载的程序可能会有权限问题。</li><li>权限问题解决请自己查阅资料解决。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> C++面向对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>跟我一起学写makefile</title>
      <link href="/2018/05/17/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6%E5%86%99makefile/"/>
      <url>/2018/05/17/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6%E5%86%99makefile/</url>
      <content type="html"><![CDATA[<blockquote><p>未完待续……</p></blockquote><h5 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h5><p>作者在写本文时，着重参考了<a href="https://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="noopener">CSDN博客作者陈皓</a>的博客，在此表示十分感谢。</p><hr><p><em>对于大多数用Windows学编程的同学也许不知道makefile这个东西，因为Windows的IDE为你做了这个工作。最近打算转战Unix系统，所以在被逼无奈之下，了解了一下makefile，在此写出同大家一起分享</em>。</p><blockquote><p>Question：什么是makefile？</p></blockquote><p>makefile关系了整个工程的编译规则，在一个工程中，源文件不计其数，其按照类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定那个文件需要先编译，那个文件需要后编译，那些文件需要重新编译，甚至于更加复杂的功能操作，，这里的makefile就像是一个shell脚本一样，其中也可以执行操作的命令。</p><p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具。</p><h5 id="程序的编译和链接"><a href="#程序的编译和链接" class="headerlink" title="程序的编译和链接"></a>程序的编译和链接</h5><hr><p>一般来说，无论是C，C++，还是pas，首先要把源文件编译成中间代码文件，Windows下为.obj文件，Unix下是.o文件，即 Object File，这个动作叫做编译(compile)。<br>然后再把大量的Object File合成可执行文件，这个动作叫做链接（link）。  </p><p><strong>编译</strong>时，编译器需要的是语法的正确，函数与变量的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（这里的头文件只要声明），只要所有的语法正确，编译器就可以编译出中间文件。一般来说，每个源文件都应该对应于一个中间文件。</p><p><strong>链接</strong>时，主要是链接函数和全局变量。链接器并不管函数所在的源文件，只要函数的中间文件(Object File)，在大多数时候，由于源文件太多，对应编译生成的中间目标文件（.o）太多，而在连接时需要明显的指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”(Library File),即.lib文件，在UNIX下，是Archive File,也就是.a文件。</p><p><strong>总而言之</strong>,源文件首先会生成中间目标文件（.obj或.o），再由中间目标文件生成执行文件。编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），你需要指定函数的Object File。</p>]]></content>
      
      
        <tags>
            
            <tag> C++面向对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cpp-封装篇之This指针</title>
      <link href="/2018/05/17/Cpp-%E5%B0%81%E8%A3%85%E7%AF%87/"/>
      <url>/2018/05/17/Cpp-%E5%B0%81%E8%A3%85%E7%AF%87/</url>
      <content type="html"><![CDATA[<h4 id="1-this指针-指向自身数据的指针"><a href="#1-this指针-指向自身数据的指针" class="headerlink" title="1.this指针: 指向自身数据的指针"></a>1.this指针: <em>指向自身数据的指针</em></h4><p>举例如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>          //代码1</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Array(<span class="keyword">int</span> _len)&#123;len = _len;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> len;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setlen</span><span class="params">(<span class="keyword">int</span> _len)</span></span>&#123;len = _len;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里数据成员和参数在表达相同意思时用的是不同的变量，<em>所以如果想用相同的变量就需要一个标记来区分该变量时数据成员还是参数</em>,即<strong>this指针</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>          //代码2</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len)&#123;<span class="keyword">this</span>-&gt;len = len;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> len;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setlen</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;<span class="keyword">this</span>-&gt;len = len;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这样，用this指针指明了数据成员，就可以用相同的变量来进行表示了。</p><blockquote><p>Question：为什么成员函数可以直接访问数据成员？  </p></blockquote><p><strong>知识准备</strong>: 对象结构<br>在进行对多个对象实例化的时候，在内存中会定义对应多个数据成员，但是成员函数只有一份，储存在代码区。而且每个对象进行调用的时候，每个对象都能够准确无误的进行调用。大家有没有想过这是为什么呢？<br><em>其实这就是this指针的功劳。</em> 我们来看下面这个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>          //代码3</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(T *<span class="keyword">this</span>,<span class="keyword">int</span> _len)&#123;<span class="keyword">this</span>-&gt;len = _len;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">(T *<span class="keyword">this</span>)</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;len;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setlen</span><span class="params">(T *<span class="keyword">this</span>,<span class="keyword">int</span> _len)</span></span>&#123;<span class="keyword">this</span>-&gt;len = _len;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>大家是不是发现了和第一个例子的区别？显而易见，就是每个成员函数都加了一个this指针，这样上面所提到的问题就迎刃而解了。<br>我们设想一下，当我们去实例化一个对象并使用他们的成员函数时，<strong>this指针就代表这个对象本身的地址</strong>，也就是说当我们调用成员函数时,编译器会悄悄地把代码1转换成代码3，所以每次调用成员函数，都是改变对应对象的成员变量。  </p><p>上面说了，<em>编译器自动的为每个成员函数的参数列表都加了一个this指针</em>, Thus，我们只需要理解就可，没有必要自己显式的写出来。</p><hr><p><em>推荐视频</em>：<a href="https://www.imooc.com/video/8162" target="_blank" rel="noopener">如何理解this指针?</a></p><blockquote><p>Tips: 看视频需要注册账号，只有注册登录才可以看视频。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> C++面向对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/12/hello-world/"/>
      <url>/2018/05/12/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
        <tags>
            
            <tag> hello World </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown简单用法</title>
      <link href="/2018/05/11/markdown%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"/>
      <url>/2018/05/11/markdown%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote><p>本文是作者第一篇hexo博客，排版等问题不足之处请见谅。</p></blockquote><h3 id="1-Markdown官方文档及其他参考"><a href="#1-Markdown官方文档及其他参考" class="headerlink" title="1.Markdown官方文档及其他参考"></a>1.Markdown官方文档及其他参考</h3><ul><li>特别感谢简书<a href="https://www.jianshu.com/p/0130ad32a08d" target="_blank" rel="noopener">刘邓诏初</a>的blog对本文的帮助</li><li><a href="https://www.cnblogs.com/yuxiuyan/p/6044682.html" target="_blank" rel="noopener">Markdown语法入门</a></li><li><a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">官方文档详细版</a>  </li></ul><h3 id="2-常用语法规则"><a href="#2-常用语法规则" class="headerlink" title="2.常用语法规则"></a>2.常用语法规则</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>共六级标题，用#的累计来进行区分，#号越少字号越大<br>下面给出相应代码，如图所示：<br><img src="/2018/05/11/markdown简单用法/1.png" alt="lll"><br><img src="/2018/05/11/markdown简单用法/9.png" alt="ll"></p><h4 id="换行和分段"><a href="#换行和分段" class="headerlink" title="换行和分段"></a>换行和分段</h4><ul><li>换行：只需要在行末加两个空格键和一个回车  </li><li>分段：段落之间空一行即可<br><img src="/2018/05/11/markdown简单用法/2.png" alt="换行和分段">  </li></ul><h4 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h4><ul><li>加粗: <strong>加粗</strong></li><li>斜体: <em>斜体</em></li><li>删除线: <del>删除线</del></li><li>底纹: <code>底纹</code><br><img src="/2018/05/11/markdown简单用法/3.png" alt="style">  </li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>只要将文本内容之前加[ &gt;(大于号) ]即可将文本变成引用文本。</p><blockquote><p>我是引用文本  </p></blockquote><p><img src="/2018/05/11/markdown简单用法/4.png" alt="引用">  </p><h4 id="图片和链接"><a href="#图片和链接" class="headerlink" title="图片和链接"></a>图片和链接</h4><ul><li><strong>图片格式</strong>: ! [图片描述] (链接的地址)  </li><li><strong>链接</strong>:  [文本内容] (链接的地址)  </li><li>如果是本地的图片可以参考: <a href="https://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="noopener">hexo生成blog本地图片插入方法</a>  <blockquote><p><em>实际用时在 感叹号，中括号和小括号 之间不能有空格，这里只是为了展示效果</em></p></blockquote></li></ul><h4 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h4><p>三个[ - ]或者[ * ]都可以画出一条水平分割线 </p><hr><hr><p>实现方式: <img src="/2018/05/11/markdown简单用法/5.png" alt="水平线">  </p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>在markdown制作表格非常麻烦，必须要画出来！！！  </p><p><img src="/2018/05/11/markdown简单用法/6.png" alt="表格">  </p><h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><p>脚注成对出现，[^1]作为标记，可以点击调至末尾注解。[^1]填写注解，不论写在什么位置<br>，都会出现在文章的末尾。  </p><p><img src="/2018/05/11/markdown简单用法/7.png" alt="脚注">  </p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注释是给自己看的，预览和发布时都不会出现。  </p><!-- hhh  -->  <p><img src="/2018/05/11/markdown简单用法/8.png" alt="注释">  </p><blockquote><p>end: 暂时先总结这些，实现了最基础的一些功能,能满足大家的一定需要，对markdown有兴趣却还没有基础的小白可以看看，大神请绕道，等日后再慢慢更新…  </p></blockquote><hr><p>5月16日补充：  </p><h4 id="代码框的三种形式"><a href="#代码框的三种形式" class="headerlink" title="代码框的三种形式"></a>代码框的三种形式</h4><ul><li>两对’’’包裹  </li><li>代码前面加两个<strong>空格键</strong></li><li>代码前面加一个<strong>TAB键</strong><br><img src="/2018/05/11/markdown简单用法/10.png" alt="代码框">  </li></ul><blockquote><p>让hexo代码高亮格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;```语言名 （比如cpp）  </span><br><span class="line">&gt;    #include &lt; iostream&gt;</span><br><span class="line">&gt;    using namespace std;</span><br><span class="line">&gt;    ...</span><br><span class="line">&gt;``` //第一行说明语言，下面是代码内容</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>点击这里可以查看<a href="http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html" target="_blank" rel="noopener">代码高亮支持格式和化名</a></p><hr><p>特别感谢：<a href="https://www.jianshu.com/p/0130ad32a08d" target="_blank" rel="noopener">https://www.jianshu.com/p/0130ad32a08d</a></p>]]></content>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim+插件实现markdown功能</title>
      <link href="/2018/05/11/vim-%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0markdown%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/05/11/vim-%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0markdown%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h5 id="具体请参考：https-www-jianshu-com-p-44d31327f953"><a href="#具体请参考：https-www-jianshu-com-p-44d31327f953" class="headerlink" title="具体请参考：https://www.jianshu.com/p/44d31327f953"></a>具体请参考：<a href="https://www.jianshu.com/p/44d31327f953" target="_blank" rel="noopener">https://www.jianshu.com/p/44d31327f953</a></h5><p>里面实现了从小白到搭建好markdown的所有过程。</p>]]></content>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
