<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>链表</title>
      <link href="/%E9%93%BE%E8%A1%A8.html"/>
      <url>/%E9%93%BE%E8%A1%A8.html</url>
      <content type="html"><![CDATA[<blockquote><p>看了<a href="http://www.x1aolin6.top/%E9%A1%BA%E5%BA%8F%E8%A1%A8.html">顺序表的相关介绍</a>,在顺序表中插入和删除一个元素时，在等概论的情况下，需要移动表中约一般的元素。此外，顺序表需要使用连续的内存空间，且空间大小要按照最大需求进行分配，可能导致内存空间利用率不高。</p></blockquote><p>为了解决这个问题，我们特别推出了<strong>链表</strong>这一数据结构。</p><h3 id="链表概念"><a href="#链表概念" class="headerlink" title="链表概念"></a>链表概念</h3><p>链表是使用不连续的或者连续的存储空间来存放线性表的数据结构。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>在每个数据元素后面附加一个地址域(指针域)，用来存放当前元素的直接后继地址。<br>这个<strong>由数据域和指针域形成的结构</strong>作为一个整体，叫做<strong>结点</strong>。<br><a id="more"></a></p><p>假设要在表L中的第 i 个位置上插入值为<code>x</code>的元素，为了实现插入，并且不移动元素，需要另外开辟存储单元来存放要插入的<code>x</code>的值。在这种情况下，为了能体现出<code>x</code>与其新的前驱、后继元素之间的逻辑关系(次序)，要<strong>为每个元素增加一个变量以记录元素的地址</strong>，从而构成了称为<strong><em>结点</em></strong>的一个整体。</p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构_队列</title>
      <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97.html"/>
      <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97.html</url>
      <content type="html"><![CDATA[<h3 id="队列原理"><a href="#队列原理" class="headerlink" title="队列原理"></a>队列原理</h3><blockquote><p>所谓队列，从特点上来讲，就是一个先入先出的数据模型。即FIFO: first in first out</p></blockquote><p>最前面的元素称之为队头，最后面的元素称之为队尾。<strong>从形式上来说</strong>，队列分为两种:一种称之为“普通队列”，另一种称之为“环形队列”。 </p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>顺序表</title>
      <link href="/%E9%A1%BA%E5%BA%8F%E8%A1%A8.html"/>
      <url>/%E9%A1%BA%E5%BA%8F%E8%A1%A8.html</url>
      <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p> 线性表L是n个元素e<sub>1</sub>,e<sub>2</sub>,e<sub>3</sub>, …e<sub>n</sub>,组成的有限序列，记作L = (e<sub>1</sub>,e<sub>2</sub>,e<sub>3</sub>, …e<sub>n</sub>),其中n(n&gt;=0)为表长度；当n = 0时，记做L=()。</p><p>非空线性表的特点:</p><ul><li>有一个唯一的“第一个”数据元素。</li><li>有一个唯一的“最后一个”数据元素。</li><li>除头元素外，表中其他元素有且只有一个直接前驱。</li><li>除尾元素外，表中其他元素有且只有一个直接后继。</li></ul><a id="more"></a><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><blockquote><p>附一个typedef用法的博客：<a href="https://www.cnblogs.com/qyaizs/articles/2039101.html" target="_blank" rel="noopener">传送门</a>，下面开始正式说明。</p></blockquote><h4 id="顺序表定义"><a href="#顺序表定义" class="headerlink" title="顺序表定义"></a>顺序表定义</h4><p><strong>顺序存储方式：</strong> 假设在计算机中有一个足够大的连续的存储空间，则可将表中元素按照其逻辑次序依次存储到这一存储区，由此而得到的线性表称为 <strong>顺序表</strong>。</p><p><strong>具体实现</strong>:<br>使用数组来对应连续的存储空间，如<code>data[MAXLEN]</code>,另外用一个<code>int</code>类的变量来记录表的长度，和作为“路标”操作数组里的元素。</p><p>C语言实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 100  <span class="comment">//最大长度设置</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">elementType data[MAXLEN];</span><br><span class="line"><span class="keyword">int</span> listLen;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sList</span> <span class="title">seqList</span>;</span> <span class="comment">//起别名，具体看上面传送门</span></span><br></pre></td></tr></table></figure></p><p>C++语言实现:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 100  <span class="comment">//最大长度设置</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">seqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">elementType data[MAXLEN];</span><br><span class="line"><span class="keyword">int</span> listLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>说明: 代码中的<code>elementType</code>在使用时可用<code>tepedef</code>来指定为你所需要的类型。比如你想要一个double类型的数组，用来存放学生的成绩，可以用<code>typedef double elementType</code>。这样做的目的就是使更加模板化，使用起来更加方便。</p><h4 id="常用基本运算"><a href="#常用基本运算" class="headerlink" title="常用基本运算"></a>常用基本运算</h4><blockquote><p>学会了常用的几个基本运算，再进行融会贯通即可。   </p></blockquote><h5 id="初始化运算的实现"><a href="#初始化运算的实现" class="headerlink" title="初始化运算的实现"></a>初始化运算的实现</h5><p>说起初始化，可能大家的思路就是把数组清空，然后<code>lis tLen = 0;</code>才可以，其实并不需要。设想一下，原来我们选择的存储空间内就是有“无效数据”的，无论用没有用到，它都会有一些数据，只是没用到的那些数据对我们无效罢了。所以，我们在初始化的时候，就只需要将<code>listLen</code>初始化为0即可，然后以前的数据都自动看做“无效数据”，下次进行运算时插入覆盖掉就好了。<br>代码如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialList</span><span class="params">(seqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L-&gt;listLen = <span class="number">0</span>;  <span class="comment">//使用引用也可以的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="求表长度的实现"><a href="#求表长度的实现" class="headerlink" title="求表长度的实现"></a>求表长度的实现</h5><p>其实求表长度几乎不需要什么操作，就是为了方便起见，写了一个返回函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listLength</span><span class="params">(seqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.listLen; <span class="comment">//为什么没有求长度的操作？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>回答上面的问题: 因<code>listLen</code>在其他的所有操作中都是相当于在数组的最后，也就是在所有的操作下，<code>listLen</code><em>时刻</em> 代表着这个表的长度，所以当我们需要的时候直接来取即可。</p><h5 id="按序号求元素"><a href="#按序号求元素" class="headerlink" title="按序号求元素"></a>按序号求元素</h5><p>顺序表L的序号为i的元素存放在下标为i-1的数组单元中，因此，直接从该数组单元中去值即可。下面给出一种实现:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElement</span><span class="params">(seqList L,<span class="keyword">int</span> i,elementType &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.listLen)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//取值失败</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">x = L.data[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//取值成功</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="查找元素的实现"><a href="#查找元素的实现" class="headerlink" title="查找元素的实现"></a>查找元素的实现</h5><p>即确定元素x是否在顺序表L中，以及在L中的位置。需要依次比较各元素，所以得使用循环搜索。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listLocate</span><span class="params">(seqList L, elementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x==L.data[i]);</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;  <span class="comment">//返回序号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//没有找到，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="插入元素的实现"><a href="#插入元素的实现" class="headerlink" title="插入元素的实现"></a>插入元素的实现</h5><p>这个可以说是比较麻烦的一项操作了，因为在顺序表插入一个值，插入值后面的所有值都得向后移动一个位置。下面给出一种代码示例:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listInsert</span><span class="params">(seqList &amp;L,elementType x,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L.listLen == MAXLEN)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.listLen+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L.listLen<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)&#123;</span><br><span class="line">L.data[j+<span class="number">1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line">L.data[i<span class="number">-1</span>] = x;</span><br><span class="line">L.listLen++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="删除算法实现"><a href="#删除算法实现" class="headerlink" title="删除算法实现"></a>删除算法实现</h5><p>删除的过程也是覆盖的过程，只需将要删除的元素后的所有元素都向前一位即可。对了，要记得<code>listLen--</code>操作。下面给出一种代码示例:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listDelete</span><span class="params">(seqlist *L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;listLen&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空表不能删除元素</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;listLen)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//删除元素不存在</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>;j&lt;L.listlen;j++)</span><br><span class="line">&#123;</span><br><span class="line">L.data[j] = L.data[j+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">L.listLen--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cpp多态篇</title>
      <link href="/cpp%E5%A4%9A%E6%80%81%E7%AF%87.html"/>
      <url>/cpp%E5%A4%9A%E6%80%81%E7%AF%87.html</url>
      <content type="html"><![CDATA[<h3 id="多态概述"><a href="#多态概述" class="headerlink" title="多态概述"></a><a href="https://www.imooc.com/video/9194" target="_blank" rel="noopener">多态概述</a></h3><blockquote><p>什么是多态？</p></blockquote><p>所谓多态，就是当发出一条命令的时候，不同的对象接收到同样的命令之后所做出的动作是不同的。用比较官方的话来讲，<strong>就是指相同对象收到不同消息或不同对象收到相同消息时产生不同的动作。</strong></p><h3 id="虚函数及实现原理"><a href="#虚函数及实现原理" class="headerlink" title="虚函数及实现原理"></a><a href="https://www.imooc.com/video/9195" target="_blank" rel="noopener">虚函数及实现原理</a></h3><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><blockquote><p>由<code>virtual</code>关键字修饰的函数称之为虚函数。</p></blockquote><h5 id="1-静态多态-早绑定"><a href="#1-静态多态-早绑定" class="headerlink" title="1.静态多态(早绑定)"></a>1.静态多态(早绑定)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">int</span> width)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>程序在运行之前，在编译阶段就已经确定下来到底要使用哪个函数了。可见，很早的就已经将函数编译进去了，那么，我们就把这种情况叫做早绑定。</p><h5 id="2-动态多态-晚绑定"><a href="#2-动态多态-晚绑定" class="headerlink" title="2.动态多态(晚绑定)"></a>2.动态多态(晚绑定)</h5><p>动态多态必须以封装和继承为基础。</p><p>在定义成员函数的时候就把我们想要<strong>实现多态的成员函数</strong>前面加<code>virtual</code>关键字使其成为虚函数。然后在定义子类的时候，给相同的函数也加上<code>virtual</code>关键字，当然，这并不是必须的，如果你不加，系统会自动为你加上。如果加上了，我们会在后续的使用当中看的更加明显，所以推荐大家在子类的定义当中也加上virtual，避免出错。<br>下面举个例子给大家:</p><p><code>Shape.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHAPE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHAPE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"calcArea"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Shape()&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Shape()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Shape()&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"~Shape()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>Rect.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RECT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Shape.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span>:</span><span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Rect--&gt;caleArea()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> m_dWidth*m_dHeight;</span><br><span class="line">&#125;</span><br><span class="line">Rect(<span class="keyword">double</span> width,<span class="keyword">double</span> height)</span><br><span class="line">&#123;</span><br><span class="line">m_dWidth = width;</span><br><span class="line">m_dHeight = height;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Rect()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Rect()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"~Rect()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">double</span> m_dWidth;</span><br><span class="line"><span class="keyword">double</span> m_dHeight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>Circle.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CIRCLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CIRCLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Shape.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span><span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Circle--&gt;calcArea()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14</span>*m_dR*m_dR;</span><br><span class="line">&#125;</span><br><span class="line">Circle(<span class="keyword">double</span> r)&#123;</span><br><span class="line">m_dR = r;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Circle()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Circle()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"~Circle()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">double</span> m_dR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>demo.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Circle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Rect.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Shape *s1 = <span class="keyword">new</span> Rect(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">Shape *s2 = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">s1-&gt;calcArea();</span><br><span class="line">s2-&gt;calcArea();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> s1;</span><br><span class="line"><span class="keyword">delete</span> s2;</span><br><span class="line"></span><br><span class="line">s1 = <span class="literal">NULL</span>;</span><br><span class="line">s2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，请自行体会(代码可复制试验)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x1aolin@x1aolin-E402NA:~/桌面/虚函数$ g++ demo.cpp Circle.h Rect.h Shape.h -o o</span><br><span class="line">x1aolin@x1aolin-E402NA:~/桌面/虚函数$ ./o</span><br><span class="line">Shape()</span><br><span class="line">Rect()</span><br><span class="line">Shape()</span><br><span class="line">Circle()</span><br><span class="line">Rect--&gt;caleArea()</span><br><span class="line">Circle--&gt;calcArea()</span><br><span class="line">~Shape()</span><br><span class="line">~Shape()</span><br></pre></td></tr></table></figure></p><h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><blockquote><p>从定义上理解很简单，就是 virtual -&gt;析构函数。</p></blockquote><p>在上面的代码中我们详细说明了什么是动态多态，确实给我们处理问题又带来了新的方法。但是从上面的运行结果来看，还是存在一定的问题的，那就是<strong>内存泄漏</strong>。通过运行结果可以明显看出，在最后释放内存时，只是运行了父类的析构函数，而没有运行子类的析构函数，因此，如果在子类的构造函数中申请了一段内存的话，那么就有可能造成泄露。那么，该如何解决这个问题呢？</p><p>这就用到了本节中的虚析构函数，只需要把<code>Shape.h</code>文件修改为:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Shape();</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">virtual</span> ~Shape();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h5 id="virtual使用限制"><a href="#virtual使用限制" class="headerlink" title="virtual使用限制:"></a>virtual使用限制:</h5><ul><li><p>普通函数不能是虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span><span class="comment">//FALSE</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;;<span class="comment">//必须为某个类的成员函数，不能是一个全局函数</span></span><br></pre></td></tr></table></figure></li><li><p>静态成员函数不能是虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ll</span><span class="params">()</span></span>;  <span class="comment">//FALSE</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>内联函数不能是虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">AA</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>;  <span class="comment">//FALSE 这样写计算机会忽略掉inline效应</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>构造函数不能是虚函数</p></li></ul>]]></content>
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> cpp多态 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cpp继承篇</title>
      <link href="/cpp%E7%BB%A7%E6%89%BF%E7%AF%87.html"/>
      <url>/cpp%E7%BB%A7%E6%89%BF%E7%AF%87.html</url>
      <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>视频链接:<a href="https://www.imooc.com/video/8701" target="_blank" rel="noopener">https://www.imooc.com/video/8701</a></p></blockquote><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>通过继承机制，可以利用已有的数据类型来定义新的数据类型。所定义的新的数据类型不仅拥有新定义的成员，而且还同时拥有旧的成员。我们称已存在的用来派生新类的类为基类，又称为父类。由已存在的类派生出的新类称为派生类，又称为子类。</p><h4 id="为什么要使用继承"><a href="#为什么要使用继承" class="headerlink" title="为什么要使用继承?"></a>为什么要使用继承?</h4><p>1、继承可以减少重复的代码。比如父类已经提供的方法，子类可以直接使用，不必再去实现。<br>2、继承是多态性的前提。当然使用继承的同时也提高了类的耦合度。</p><a id="more"></a><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>:</span> <span class="keyword">public</span> Person  <span class="comment">//公有继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Worker();</span><br><span class="line">~Worker();</span><br><span class="line"><span class="keyword">int</span> m_iSalary;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><blockquote><p>视频链接:<a href="https://www.imooc.com/video/8703" target="_blank" rel="noopener">https://www.imooc.com/video/8703</a></p></blockquote><ul><li>公有继承  <code>class A:public B</code></li><li>保护继承  <code>class A:protected B</code></li><li>私有继承  <code>class A:private B</code></li></ul><h4 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h4><ul><li>public<br>子类可以继承父类<code>public</code>下的所有数据成员和成员函数，并且在子类中的访问权限也是<code>public</code>,子类可以直接用<code>.</code>或者<code>-&gt;</code>符号直接访问父类中的数据成员和成员函数。</li><li>protected<br>子类继承父类所有的<code>protected</code>下的所有数据成员和成员函数，并且在子类中的访问权限为<code>protected</code>,子类不可以直接用<code>.</code>或者<code>-&gt;</code>符号直接访问父类中的数据成员和成员函数。</li><li>private<br>子类继承父类所有的<code>private</code>下的所有数据成员和成员函数到不可见位置。换句话说，<strong>子类无法访问父类的private成员</strong>。  </li></ul><p>下面给出一个例子来加深一下理解：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> m_iAge;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> m_strName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>经过继承之后，相当于下面的代码:(下面备注<strong>继承过来的</strong>的代码实际运用中不可见，与下面“隐藏”相区别)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>:</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  <span class="comment">//**继承过来的**，可在任意位置使用</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> m_iAge; <span class="comment">//**继承过来的**，可在类内使用</span></span><br><span class="line">  <span class="keyword">int</span> m_iSalary;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> h;  <span class="comment">//m_strName继承不可见，也无法使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最后用一个表格总结一下:</p><table><thead><tr><th style="text-align:center">基类成员访问属型</th><th style="text-align:center">继承方式</th><th style="text-align:center">派生类成员访问属型</th></tr></thead><tbody><tr><td style="text-align:center">private成员</td><td style="text-align:center">public</td><td style="text-align:center">无法访问</td></tr><tr><td style="text-align:center">protected成员</td><td style="text-align:center">public</td><td style="text-align:center">protected</td></tr><tr><td style="text-align:center">public成员</td><td style="text-align:center">public</td><td style="text-align:center">public</td></tr></tbody></table><h4 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h4><table><thead><tr><th style="text-align:center">基类成员访问属型</th><th style="text-align:center">继承方式</th><th style="text-align:center">派生类成员访问属型</th></tr></thead><tbody><tr><td style="text-align:center">private成员</td><td style="text-align:center">protected</td><td style="text-align:center">无法访问</td></tr><tr><td style="text-align:center">protected成员</td><td style="text-align:center">protected</td><td style="text-align:center">protected</td></tr><tr><td style="text-align:center">public成员</td><td style="text-align:center">protected</td><td style="text-align:center">protected</td></tr></tbody></table><h4 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h4><table><thead><tr><th style="text-align:center">基类成员访问属型</th><th style="text-align:center">继承方式</th><th style="text-align:center">派生类成员访问属型</th></tr></thead><tbody><tr><td style="text-align:center">private成员</td><td style="text-align:center">private</td><td style="text-align:center">无法访问</td></tr><tr><td style="text-align:center">protected成员</td><td style="text-align:center">private</td><td style="text-align:center">private</td></tr><tr><td style="text-align:center">public成员</td><td style="text-align:center">private</td><td style="text-align:center">private</td></tr></tbody></table><h3 id="继承中的特殊关系"><a href="#继承中的特殊关系" class="headerlink" title="继承中的特殊关系"></a>继承中的特殊关系</h3><blockquote><p>视频链接:<a href="https://www.imooc.com/video/8708" target="_blank" rel="noopener">https://www.imooc.com/video/8708</a></p></blockquote><h4 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h4><p>如果子类中有与父类同名的数据成员和成员函数，那么用子类实例化一个对象后，这个对象通过一般手段只能调用子类中的数据成员和成员函数。总结为三个关键字：<strong>父子关系 成员同名 隐藏</strong></p><p>除此之外，如果子类父类中成员函数名字相同，但是参数不同，也是能形成隐藏的。 <strong>子类和父类之间无法形成重载，只能形成隐藏。</strong> 如果想要调用父类的同名成员函数，仍需要用到命名空间，具体看下面的代码。</p><p>下面给出一个例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  //父类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">string</span> m_strName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soldier</span>:</span><span class="keyword">public</span> Person  <span class="comment">//子类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;  <span class="comment">//同名成员函数,内容不同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_iCode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Soldier soldier;</span><br><span class="line">soldier.play();  <span class="comment">//调用子类中的play函数</span></span><br><span class="line">soldier.Person::play();  <span class="comment">//调用父类Person中的成员函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这是语法规定，但是我们为了避免混淆，一般不会用到同名的成员变量和成员函数，所以尽量不要让子类和父类的成员变量和成员函数同名，这是一种好的编程习惯。</p><h4 id="IS-A"><a href="#IS-A" class="headerlink" title="IS A"></a>IS A</h4><p>类似于Java当中的上转型对象，在C++当中，派生类的对象也可以赋值给基类。当然，基类的指针也可以指向派生类的对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于上面的代码,Person类是Soldier的父类。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Soldier s1;</span><br><span class="line">Person p1 = s1;    <span class="comment">//True</span></span><br><span class="line">Person *p2 = &amp;s1;  <span class="comment">//True</span></span><br><span class="line"></span><br><span class="line">s1 = p1;</span><br><span class="line">Soldier *s2 = &amp;p1;  <span class="comment">//False</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们用子类的对象向父类的对象赋值时，其本质就是将子类当中从父类继承下来的数据成员赋值给父类的对象，子类当中的其他的数据此时就会被截断。其中，实例化对象能够调用的成员函数依旧是父类当中的成员函数。</p><p><strong>虚的析构函数 ：</strong> 写成<code>virtual ~Person()</code>，这样在释放基类的指针时就会先执行子类的析构函数，避免内存泄漏。</p><p>想要了解更详细的内容，请看博客<a href="http://www.x1aolin6.top/cpp%E5%A4%9A%E6%80%81%E7%AF%87.html">cpp多态篇</a></p><h3 id="多继承与多重继承"><a href="#多继承与多重继承" class="headerlink" title="多继承与多重继承"></a>多继承与多重继承</h3><blockquote><p>视频链接:<a href="https://www.imooc.com/video/8716" target="_blank" rel="noopener">https://www.imooc.com/video/8716</a></p></blockquote><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p> 举个栗子: 人类－－士兵类－－步兵类<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soldier</span>:</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Infantryman</span>:</span><span class="keyword">public</span> Soldier</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>多继承，也就是一个子类有多个父类。具体到代码层面:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Farmer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MigrantWorker</span>:</span><span class="keyword">public</span> Worker,<span class="keyword">public</span> Farmer<span class="comment">//不写public默认私有继承</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>结论: 无论继承的层级有多少层，只要保持着直接或者间接的继承关系，那么子类都可以与自己的直接父类或者是间接父类称之为是一个的关系，并且能够对父类的指针对直接子类或间接子类的对象进行相应的操作。</p><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><blockquote><p>视频链接:<a href="https://www.imooc.com/video/8719" target="_blank" rel="noopener">https://www.imooc.com/video/8719</a></p></blockquote><p>最典型的“菱形继承”既有多继承，也会有多重继承。图片我就不放了，请大家自行点击<a href="https://blog.csdn.net/monamokia/article/details/51537312" target="_blank" rel="noopener">传送门</a>进行了解。</p><p>如何处理其中带来的数据冗余问题呢？就需要这节题目所带来的“虚继承”了。下面说一下什么是虚继承: 虚继承是继承的一种方式，其定义关键字是<code>virtual</code>。下面给出示例说明使用方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Person <span class="comment">//virtual 和 public 前后位置随意</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用虚继承后，菱形继承最顶层的父类，并没有进行参数的传递，也就是说参数只使用了顶层父类的默认参数，而无法从子类当中获得传入的参数。</p><p>下面给出一个简单例题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">定义Person人类，worker工人类及children儿童类，</span><br><span class="line"></span><br><span class="line">worker类中定义数据成员m_strName姓名，</span><br><span class="line"></span><br><span class="line">children类中定义成员m_iAge年龄，</span><br><span class="line"></span><br><span class="line">worker类及children类均虚公有继承Person类，</span><br><span class="line"></span><br><span class="line">定义ChildLabourer童工类，公有继承工人类和儿童类，</span><br><span class="line">从而形成菱形继承关系。在main函数中通过new实例化</span><br><span class="line">ChildLabourer类的对象，并通过该对象调用Person，</span><br><span class="line">Worker及Children类中的成员函数，最后销毁该对象，</span><br><span class="line">掌握多重继承，多继承，虚继承的定义方法。</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> cpp继承 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java访问权限</title>
      <link href="/Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.html"/>
      <url>/Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.html</url>
      <content type="html"><![CDATA[<blockquote><p>和C++一样，Java中对象操作自己的变量和使用类中的方法是有一定的限制的，即所谓的<strong>访问权限</strong>。</p></blockquote><p>所谓访问权限，是指对象是否可以通过<code>.</code>运算符操作自己的变量或者使用类中的方法，访问限制修饰符有<code>private</code>,<code>protected</code>,<code>public</code>，下面会对其分别进行介绍。</p>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类与对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java包和import语句</title>
      <link href="/Java%E5%8C%85%E5%92%8Cimport%E8%AF%AD%E5%8F%A5.html"/>
      <url>/Java%E5%8C%85%E5%92%8Cimport%E8%AF%AD%E5%8F%A5.html</url>
      <content type="html"><![CDATA[<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包是Java语言中有效的管理类的一个机制。不同Java源文件中可能出现名字相同的类，如果想区分这些类，就需要使用包名。<strong>使用包名的目的是有效的区分名字相同的类</strong>。</p><h4 id="1-包语句"><a href="#1-包语句" class="headerlink" title="1.包语句"></a>1.包语句</h4><p>通过关键词<code>package</code>声明包语句。package语句需要放在Java源文件的第一条语句，指明该源文件定义的类所在的包，即为该源文件中声明的类指定包名。<br>一般格式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名;<span class="comment">//包名是一个合法的标识符或者若干个标识符加“.”分隔而成</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>有的小伙伴可能会有疑问了，在这篇blog之前的blog中的Java代码都没有加上述语句，为什么还能运行？那是因为我们省略了package语句。如果省略了该语句，源文件中所定义命名的类被隐含地认为是无名包的一部分，只要这些类的字节码被存放在相同的目录中，那么他们就属于同一个包，只是没有包名罢了。</p><h4 id="2-有包名的类的储存"><a href="#2-有包名的类的储存" class="headerlink" title="2.有包名的类的储存"></a>2.有包名的类的储存</h4><p>如果我们显式地定义了包名，就不能再像之前那样在随意的位置存放了，需要遵守一定的规则，否则虚拟机将无法加载这样的类。<br>程序如果使用了包语句，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x1ao.lin;</span><br></pre></td></tr></table></figure></p><p>那么在存储文件的目录结构中必须包含如下结构: <code>.../x1ao/lin</code>（Windows下是\斜杠），并且要将源文件编译文件得到的字节码文件保存到该目录(源文件位置可任意)。</p><h4 id="3-运行有包名的主类"><a href="#3-运行有包名的主类" class="headerlink" title="3.运行有包名的主类"></a>3.运行有包名的主类</h4><p>如果主类的包名是x1ao.lin，那么主类的字节码一定一定要存放在<code>.../x1ao/lin</code>目录中，因此必须到<code>x1ao/lin</code>的上一层(即x1ao的父目录)目录中运行主类。举个栗子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/projects$ java x1ao.lin.主类名</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Notice:</strong> 运行时，必须写主类的全名。使用包名后主类的全名为“包名.主类名”。</p></blockquote><p>举个栗子:<br><strong>xueHao.java :</strong> 放在<code>~/projects/x1ao/lin</code>文件夹下(ubuntu系统)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x1ao.lin;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xueHao</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> xuehao;</span><br><span class="line">xueHao(<span class="keyword">long</span> xuehao)&#123; </span><br><span class="line"><span class="keyword">this</span>.xuehao = xuehao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"学号为: "</span>+xuehao);</span><br><span class="line">System.out.print(<span class="string">" xueHao类: package x1ao.lin"</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Exam2.java :</strong> 放在<code>~/projects/x1ao/lin</code>文件夹下(ubuntu系统)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x1ao.lin;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">xueHao number = <span class="keyword">new</span> xueHao(<span class="number">2018061366</span>);</span><br><span class="line">number.print();</span><br><span class="line">System.out.println(<span class="string">"主类: package x1ao.lin"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p>编译。将这两个文件放入上面所述的位置后(这只是提供一种可能)，然后进入到<code>/x1ao/lin</code>的上一层目录projects中编译两个源文件。如下图:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其实只需要运行第一条命令即可,因为他们的源文件都放在同一目录中.</span></span><br><span class="line"><span class="comment">//只需编译主类的源文件，Java系统会自动地编译其他的源文件。</span></span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/projects$ javac x1ao/lin/Exam2.java </span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/projects$ javac x1ao/lin/xueHao.java</span><br></pre></td></tr></table></figure></li><li><p>运行。在<code>x1ao/</code>的上一层目录运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/projects$ java x1ao.lin.Exam2  <span class="comment">//运行命令</span></span><br><span class="line">学号为: <span class="number">2018061366</span> xueHao类: <span class="keyword">package</span> x1ao.lin  <span class="comment">//运行结果</span></span><br><span class="line">主类: <span class="keyword">package</span> x1ao.lin</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注：java语言不允许用户使用java作为包名或者作为包名的一部分。</p></blockquote><h3 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h3><p>一个类可能需要另一个类声明的对象作为自己的成员或者作为方法中的局部变量。如果这两个类在同一个包中没问题，但是如果不再同一个包中，就需要import语句来进行引入了。</p><h4 id="1-引入类库中的类"><a href="#1-引入类库中的类" class="headerlink" title="1.引入类库中的类"></a>1.引入类库中的类</h4><p>在编写源文件的时候，用户除了自己编写类外，经常使用Java提供的许多类，这些类可能在不同的包中。为了使用Java提供的类，可以使用import语句引入包中类。<strong>import语句可以有多个，位置需要放在package语句</strong>(可省略)<strong>和源文件类的定义中间。</strong></p><ul><li><p>如果要引入一个包中的所有类，可以用通配符“ * ”来代替。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure></li><li><p>如果只是使用一个包中的某个类，就可以直接写明就可以了。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;  <span class="comment">//用于用户从控制台输入数据</span></span><br></pre></td></tr></table></figure></li></ul><p>举个详细的栗子给大家:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam3</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">Date date = <span class="keyword">new</span> Date();<span class="comment">//这是Data类的构造函数</span></span><br><span class="line">System.out.print(<span class="string">"本地机器时间为:"</span>);  <span class="comment">//不带空格</span></span><br><span class="line">System.out.println(date); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下，请大家自行体会:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x1aolin@x1aolin-E402NA:~/桌面/javaExample$ java Exam3</span><br><span class="line">本地机器时间为:Wed Jun <span class="number">13</span> <span class="number">13</span>:<span class="number">00</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br></pre></td></tr></table></figure></p><p>下面给出两点说明:   </p><ol><li>java.lang包是Java语言的核心类库，其中包含了运行Java程序必不可少的系统类，系统会自动引入，不需要再使用import语句。</li><li>如果使用import语句引入了整个包中的类，可能会增加编译时间，但是不会影响程序运行时的性能,因为运行和之和字节码有关。</li></ol><h4 id="2-引入自定义包中的类"><a href="#2-引入自定义包中的类" class="headerlink" title="2.引入自定义包中的类"></a>2.引入自定义包中的类</h4><p><strong>方法一:</strong> <del>修改更新classpath</del>，不推荐，此处也不再介绍，对此有兴趣的童鞋可自行百度。  </p><p><strong>方法二:</strong> <strong>在用户程序所在的目录下建立和包相对应的子目录结构。</strong>  </p><p>方法二该怎样理解呢？举个栗子，假定用户程序的某个类所在目录为<code>~/java</code>，该类想使用import语句x1ao.lin包中的类，那么根据包名建立如下目录结构： <code>~/java/x1ao/lin</code>即可。emmmm…我个人的理解就是你可以自定义一个目录，然后一切活动都在这个目录下进行。如果定义一个包，就将包名形成的目录放在这个目录下按照一定的规则进行编译运行，不太会表达，大家可忽略这句话。</p><h4 id="3-使用无包名的类"><a href="#3-使用无包名的类" class="headerlink" title="3.使用无包名的类"></a>3.使用无包名的类</h4><p>如果一个类想使用没有包名的类，只需要将这个无名包的类的字节码和当前类保存在同一目录下即可。(以前我们也是这么做的，有没有想起来呢^_^)。</p><h4 id="4-避免类名混淆"><a href="#4-避免类名混淆" class="headerlink" title="4.避免类名混淆"></a>4.避免类名混淆</h4><ul><li>如果一个源文件使用了一个无名包中的A类，同时又用import语句引入了某个有包名的同名类，比如<code>x1ao.lin</code>中的A类，这时候就会产生类名的混淆。</li><li><p>如果源文件明确引用该类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> x1ao.lin.A;</span><br></pre></td></tr></table></figure><p>当使用A类时，如果省略包名，那么源文件使用的是<code>x1ao.lin</code>包中的A类，也就是说源文件无法使用无名包中的A类。如果想要同时使用，就不能省略包名了。系统会自动检测，如果检测到包名，就会自动判定省略包名的代码是使用的无名包。<br>举个栗子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A x1 = <span class="keyword">new</span> A();  <span class="comment">//无名包创建的对象</span></span><br><span class="line">x1ao.lin.A x2 = <span class="keyword">new</span> x1ao.lin.A(); <span class="comment">//指定包创建的对象</span></span><br></pre></td></tr></table></figure></li><li><p>如果源文件不明确引用该类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> x1ao.lin.*;</span><br></pre></td></tr></table></figure><p>当使用A类时，如果省略包名，那么源文件使用的是无名包中的A类，而无法使用指定包中的A类。如果想要同时使用，就不应该省略。</p></li><li><p>如果一个源文件引入了两个包中同名的类，那么在使用类时，<em>不允许</em> 省略包名。</p></li></ul>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类与对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java之this关键字</title>
      <link href="/Java%E4%B9%8Bthis%E5%85%B3%E9%94%AE%E5%AD%97.html"/>
      <url>/Java%E4%B9%8Bthis%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
      <content type="html"><![CDATA[<blockquote><p>我以前写过<a href="http://x1aolin6.top/2018/05/17/Cpp%E4%B9%8BThis%E6%8C%87%E9%92%88/" target="_blank" rel="noopener">C++的this指针</a>，和Java的没有太大区别，大家可以点进去看看。</p></blockquote><p>this是Java的一个关键字，表示某个对象。this可以出现在实例方法和构造方法中，不可出现在类方法中<a href="因为类方法可以通过类名直接调用，这时，可能还没有任何对象产生。">^1</a>。(大家看看上篇博客<a href="http://x1aolin6.top/2018/06/11/Java%E4%B9%8Bstatic%E5%85%B3%E9%94%AE%E5%AD%97/" target="_blank" rel="noopener">实例方法与类方法的区别</a>应该能体会出来原因)。</p><h3 id="在构造方法中使用this"><a href="#在构造方法中使用this" class="headerlink" title="在构造方法中使用this"></a>在构造方法中使用this</h3><p>在构造方法中代表使用该构造方法所创建的对象。听起来有点绕，说白了就是代表哪个对象调用，this就代表谁，改变的数据也是当前对象所“拥有统领”的变量。</p><blockquote><p>如果没有要求就不给例子了哈。^_^</p></blockquote><a id="more"></a><h3 id="在实例方法中使用this"><a href="#在实例方法中使用this" class="headerlink" title="在实例方法中使用this"></a>在实例方法中使用this</h3><p>实例方法只能通过对象来调用，所以，当this关键字出现在实例方法中时，代表正在调用该方法的当前对象。  </p><h5 id="1-当实例成员变量在实例方法中出现时，默认格式如下"><a href="#1-当实例成员变量在实例方法中出现时，默认格式如下" class="headerlink" title="1.当实例成员变量在实例方法中出现时，默认格式如下:"></a>1.当实例成员变量在实例方法中出现时，默认格式如下:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量  <span class="comment">//通常情况下this可省略</span></span><br></pre></td></tr></table></figure><h5 id="2-当static成员变量在实例方法中出现时，默认格式如下"><a href="#2-当static成员变量在实例方法中出现时，默认格式如下" class="headerlink" title="2.当static成员变量在实例方法中出现时，默认格式如下:"></a>2.当static成员变量在实例方法中出现时，默认格式如下:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.成员变量 <span class="comment">//通常情况下类名可省略</span></span><br></pre></td></tr></table></figure><blockquote><p><em>不通常情况 : 当实例成员变量的名字和局部变量的名字相同时就不可省略了。</em></p></blockquote><h5 id="3-类的实例方法可以调用类的其他方法"><a href="#3-类的实例方法可以调用类的其他方法" class="headerlink" title="3.类的实例方法可以调用类的其他方法"></a>3.类的实例方法可以调用类的其他方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.方法  <span class="comment">//通常情况下this可省略</span></span><br></pre></td></tr></table></figure><h5 id="4-对于类方法调用的默认格式如下"><a href="#4-对于类方法调用的默认格式如下" class="headerlink" title="4.对于类方法调用的默认格式如下:"></a>4.对于类方法调用的默认格式如下:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.方法 <span class="comment">//通常情况下类名可省略</span></span><br></pre></td></tr></table></figure><p>举个栗子(代码不可单独运行)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">100</span>;  <span class="comment">//this可省略</span></span><br><span class="line">A.y = <span class="number">200</span>;     <span class="comment">//A可省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.c();   <span class="comment">//this可省略</span></span><br><span class="line">A.d();   <span class="comment">//A可省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"d"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类与对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java之static关键字</title>
      <link href="/Java%E4%B9%8Bstatic%E5%85%B3%E9%94%AE%E5%AD%97.html"/>
      <url>/Java%E4%B9%8Bstatic%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
      <content type="html"><![CDATA[<blockquote><p>类体的定义 –&gt; 成员变量的定义 + 方法的定义。<br>成员变量 –&gt; 实例变量 + 类变量(static) 。<br>方法 –&gt; 构造方法 + 类方法(static) + 实例方法。<br>类方法只能调用类方法，实例方法可调用类中的实例方法和类方法。</p></blockquote><h3 id="实例变量和类变量的区别"><a href="#实例变量和类变量的区别" class="headerlink" title="实例变量和类变量的区别"></a>实例变量和类变量的区别</h3><ol><li>一个类通过使用new运算符可以创建多个不同的对象，这些对象将被分配不同的内存空间。更准确的是，不同对象的实例变量将被分配不同的内存空间，但是所有对象的这个类变量都分配给相同的一处内存，改变其中一个对象的这个类变量会影响其他对象的这个类变量,即<strong>对象共享类变量</strong></li></ol><a id="more"></a><ol start="2"><li>当Java程序执行时，类的字节码文件被加载到内存，如果该类没有创建对象，类中的实例变量不会被分配到内存。但是类中的类变量是该类被加载到内存时，就分配了相应的内存空间。</li><li>如果该类创建对象，那么不同对象的实例变量互不相同，即分配不同的内存空间，而类变量不再重新分配内存，所有对象共享类变量，即所有对象的类变量是相同的一处内存空间，类变量的内存空间直到程序退出运行，才释放所占有的内存。</li><li>因为类变量的特殊性，它既可以通过某个对象访问，<strong>也可以直接通过类名访问</strong>；而实例变量只能通过对象访问。</li></ol><blockquote><p>道理比较浅显，我就不举例子啦。^_^</p></blockquote><h3 id="实例方法和类方法的区别"><a href="#实例方法和类方法的区别" class="headerlink" title="实例方法和类方法的区别"></a>实例方法和类方法的区别</h3><ol><li>方法的入口地址只分配一次，被所有对象共享，当所有的对象都不存在时，方法的入口地址才会取消。</li><li>当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址，在该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用。</li><li>对于类中的类方法，在该类被加载到内存时，就分配了相应的入口地址，所以类方法不仅可以被类创建的任何对象调用，也可以<strong>直接通过类名调用</strong>。类方法的入口地址直到程序退出才会被取消。</li><li>实例方法既能对类变量操作也能对实例变量进行操作，而类方法只能对类变量进行操作 </li><li><em>由于类方法的特性，如果一个方法不需要操作实例变量就可以实现某种功能，就优先考虑声明为类方法,这样可以节省空间。</em></li></ol><p>这此给大家举个栗子:(包含许多以前学过的知识)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getResult</span><span class="params">(<span class="keyword">int</span> ... x)</span></span>&#123;<span class="comment">//详情请看上篇blog可变参数部分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:x)&#123;</span><br><span class="line">sum+=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam1</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">Sum.getResult(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);<span class="comment">//45</span></span><br><span class="line">System.out.printf(<span class="string">"%d\n"</span>,Sum.sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下，自行体会:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ java Exam1</span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类与对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java参数传值</title>
      <link href="/Java%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC.html"/>
      <url>/Java%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC.html</url>
      <content type="html"><![CDATA[<blockquote><p>当方法被调用的时候，如果方法有参数，参数必须要实例化，即参数必须有具体的值。在Java中，方法的所有参数都是“传值”的，也就是说，方法中参数变量的值是调用者指定的一个副本。</p></blockquote><h4 id="基本数据类型参数传值"><a href="#基本数据类型参数传值" class="headerlink" title="基本数据类型参数传值"></a>基本数据类型参数传值</h4><p>对于基本类型的参数，向该参数传递的值的级别不可以高于该参数的级别，可以低于该参数的级别。如果传递值的级别比参数的级别低，则传递过程中会自动转化。</p><a id="more"></a><h4 id="引用类型参数的传值"><a href="#引用类型参数的传值" class="headerlink" title="引用类型参数的传值"></a>引用类型参数的传值</h4><p>这里先普及一下什么是<strong>引用类型:</strong> 对象，数组，接口等都是引用类型，关于引用类型的含义或者理解在上篇博客第三点有提到:<a href="http://x1aolin6.top/2018/06/04/Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%BA%8C/" target="_blank" rel="noopener">对象的引用和实体</a>。当参数是引用类型时，“传值”传递过去的是变量中存放的“引用”，而不是变量的实体。</p><p>所以对于两个同类型的引用型变量，如果具有同样的引用，就会有同样的实体，因此，如果改变参数变量所引用的实体，就会导致原变量的实体发生同样的变化。但是，改变参数的“引用”不会影响向其传值的变量中存放的“引用”。放个图加深理解:<br><img src="/1.png" alt="引用传值"></p><p><em>说明：</em> </p><ul><li>上面的意思是说当调用左右任何一个引用来改变实体后，另一个引用所指实体也会改变，它们本来就是一个嘛。当改变左右任何一个引用，就是该引用不再指向这个实体后，另一个应用不受影响，仍然指向这个实体</li><li>这个想想应该可以理解，就暂时不放代码示例了，如果大家有要求，我再把代码放上去。</li></ul><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><blockquote><p>这个是C++里面没有的，所以请大家多关注一下。</p></blockquote><p>可变参数是指在声明方法时不给出参数列表中从某项直至最后一项参数的名字和个数，但这些参数的类型应该相同。可变参数使用”…”表示若干个参数，最后一个参数必须是参数列表中的最后一个参数。例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aaa</span><span class="params">(<span class="keyword">double</span> h,<span class="keyword">int</span> ... x)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这里的x是方法aaa的参数列表中可变参数的<strong>参数代表</strong>。参数代表可以通过下标运算来表示参数列表中的具体参数，即x[0]，x[1]，… ，x[m-1]来表示x所代表的参数。对于一个参数代表，<code>参数代表.length</code>等于参数代表所代表的个数。<br>举个栗子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">int</span> ... x)</span></span>&#123;  <span class="comment">// !!!</span></span><br><span class="line"><span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ss:x)&#123; <span class="comment">//下面会给解释</span></span><br><span class="line">sum +=ss;</span><br><span class="line">&#125;</span><br><span class="line">result = a*sum;</span><br><span class="line">System.out.println(<span class="string">"x代表了"</span>+x.length+<span class="string">"个数"</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">Computer comp = <span class="keyword">new</span> Computer();</span><br><span class="line"><span class="keyword">double</span> result = comp.getResult(<span class="number">1.0</span>/<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);<span class="comment">//x代表三个数</span></span><br><span class="line">System.out.println(<span class="string">"5,6,7的平均数:"</span>+result);</span><br><span class="line">result = comp.getResult(<span class="number">1.0</span>/<span class="number">5</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>);<span class="comment">//x代表五个数</span></span><br><span class="line">System.out.println(<span class="string">"11,22,33,44,55的平均数为:"</span>+result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码运行结果如下，请大家好好体会:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ vim Exam.java</span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ javac Exam.java </span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ java Exam</span><br><span class="line">x代表了<span class="number">3</span>个数</span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>的平均数:<span class="number">6.0</span></span><br><span class="line">x代表了<span class="number">5</span>个数</span><br><span class="line"><span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>的平均数为:<span class="number">33.0</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类与对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>有向面积</title>
      <link href="/%E6%9C%89%E5%90%91%E9%9D%A2%E7%A7%AF.html"/>
      <url>/%E6%9C%89%E5%90%91%E9%9D%A2%E7%A7%AF.html</url>
      <content type="html"><![CDATA[<p>此次介绍用有向面积的概念求(凹)多边形的面积，<a href="https://blog.csdn.net/tigercoder/article/details/70161646" target="_blank" rel="noopener">理论基础传送门</a>，大家可以点开超链接了解一下什么是有向面积，然后再来看此处的例题:</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h4><p>The input data consists of several figures. The first line of the input for each figure contains a<br>single integer n, the number of vertexes in the figure. (0≤n≤1000).<br>In the following n lines, each contain a pair of real numbers, which describes the coordinates of<br>the vertexes, (xi, yi). The figure in each test case starts from the first vertex to the second one,<br>then from the second to the third, …… and so on. At last, it closes from the nth vertex to the first<br>one.<br>The input ends with an empty figure (n = 0). And this figure not be processed.</p><a id="more"></a><h4 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h4><p>As shown below, the output of each figure should contain the figure number and a colon followed<br>by the area of the figure or the string “Impossible”.<br>If the figure is a polygon, compute its area (accurate to two fractional digits). According to the<br>input vertexes, if they cannot form a polygon (that is, one line intersects with another which<br>shouldn’t be adjoined with it, for example, in a figure with four lines, the first line intersects with<br>the third one), just display “Impossible”, indicating the figure can’t be a polygon. If the amount of<br>the vertexes is not enough to form a closed polygon, the output message should be “Impossible”<br>either.</p><h4 id="C-代码实现："><a href="#C-代码实现：" class="headerlink" title="C++代码实现："></a>C++代码实现：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; Point;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; poi,<span class="keyword">double</span> result[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> xuhao=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">xuhao++;</span><br><span class="line"><span class="keyword">int</span> num = n;  <span class="comment">//备份</span></span><br><span class="line"><span class="keyword">while</span>(n)&#123; <span class="comment">//输入</span></span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;y;</span><br><span class="line">poi.push_back(make_pair(x,y));</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> sum=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;  <span class="comment">//计算</span></span><br><span class="line">sum +=(poi[i].first*poi[(i+<span class="number">1</span>)%num].second)-(poi[(i+<span class="number">1</span>)%num].first*poi[i].second);</span><br><span class="line">&#125;</span><br><span class="line">result[xuhao<span class="number">-1</span>] = sum;</span><br><span class="line">poi.clear();<span class="comment">//清空元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> xuhao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; poi;</span><br><span class="line">poi.clear();<span class="comment">//清空元素</span></span><br><span class="line"><span class="keyword">double</span> result [<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> xuhao = input(poi,result);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xuhao;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(result[i]!=<span class="number">0.0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Figure "</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">": "</span>&lt;&lt;<span class="built_in">fabs</span>(result[i]*<span class="number">0.5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Figure "</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">": Impossible"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码如下，请自行体会:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x1aolin@x1aolin-E402NA:~/projects$ vim AREA.cpp </span><br><span class="line">x1aolin@x1aolin-E402NA:~/projects$ g++ AREA.cpp </span><br><span class="line">x1aolin@x1aolin-E402NA:~/projects$ ./a.out </span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0.5</span> <span class="number">0.5</span>   </span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">Figure <span class="number">1</span>: <span class="number">0.75</span></span><br><span class="line">Figure <span class="number">2</span>: Impossible</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法与程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算几何之寻找凸包</title>
      <link href="/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B9%8B%E5%AF%BB%E6%89%BE%E5%87%B8%E5%8C%85.html"/>
      <url>/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B9%8B%E5%AF%BB%E6%89%BE%E5%87%B8%E5%8C%85.html</url>
      <content type="html"><![CDATA[<p>首先我们先看一个例子:  </p><p><img src="/11.png" alt="地主圈地"></p><p>这个问题就是典型的凸包问题。先讲一下什么是<strong>凸包</strong>:<br><em>凸包是一组点集中的子集,这一子集形成的凸多边形可以将点集中所有的点都围住,并且这一凸多边形的面积是最小的。</em></p><a id="more"></a><p>显而易见，上述问题的求解就是<strong>把最外面的一圈点用折线圈起来</strong>，这样就是最好的结果。那么，怎么把这种思想体现到计算机算法中呢？其实有很多种解决方法，其中这里讲一个比较容易理解实现的算法:<strong>打包法</strong><br>具体算法如下:</p><ul><li>找出点集中最下方的点，如果这样的点不止一个，就选用最左边的点。</li><li>设想在该点处拴住了一根橡皮筋的一端，另一端放在和该点成水平位置的右侧。</li><li>将皮筋沿逆时针方向转动,直到碰到第一个点，然后第二个，第三个…直到形成一个闭合的凸包。</li></ul><p>具体而言:<br>就是第一次找到一点(如P0)，以P0为每个矢量的起点，其他的点为矢量的终点，比较任意两个矢量的转角，就可以对余下的点进行按极角排序。如下图:  </p><p><img src="/22.png" alt="极角"></p><p>对于右图这种极角相同的情况，可以判定哪个点在中间，哪个点在两边(下面代码实现中on_segment()函数)。</p><p>C++代码实现如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;   //pair所在头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;    //vector容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //提供大量基于迭代器的非成员模板函数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; POINT;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">direction</span><span class="params">(POINT p,POINT p1,POINT p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">POINT v1,v2;  <span class="comment">//定义两个向量，用于后续比较</span></span><br><span class="line">v1.first = p2.first - p.first;</span><br><span class="line">v1.second = p2.second - p.second;</span><br><span class="line">v2.first = p1.first - p.first;</span><br><span class="line">v2.second = p1.second - p.second;</span><br><span class="line"><span class="keyword">double</span> k = v1.first*v2.second - v1.second*v2.first;<span class="comment">//类似z轴单位向量</span></span><br><span class="line"><span class="keyword">return</span> k;<span class="comment">//k为正值,p2逆时针旋转得到p1，p2极角小,等于0时p1,p2共线</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_segment</span><span class="params">(POINT p,POINT p1,POINT p2)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//判断p是不是在以p1p2线段为对角线的边平行于x,y轴的矩形中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> min_x = p1.first &lt;p2.first ?p1.first :p2.first;</span><br><span class="line"><span class="keyword">double</span> max_x = p1.first &gt;p2.first ?p1.first :p2.first;</span><br><span class="line"><span class="keyword">double</span> min_y = p1.second&lt;p2.second?p1.second:p2.second;</span><br><span class="line"><span class="keyword">double</span> max_y = p1.second&gt;p2.second?p1.second:p2.second;</span><br><span class="line"><span class="keyword">if</span>(p.first &gt;= min_x &amp;&amp; p.first &lt;=max_x </span><br><span class="line">&amp;&amp; p.second&gt;= min_y &amp;&amp; p.second&gt;=max_y)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">POINT startPoint;<span class="comment">//定义一个起始点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sortByPolorAngle</span><span class="params">(<span class="keyword">const</span> POINT &amp;p1,<span class="keyword">const</span> POINT &amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> d = direction(startPoint,p1,p2);</span><br><span class="line"><span class="keyword">if</span>(d&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//默认p1为下一个正确点</span></span><br><span class="line"><span class="keyword">if</span>(d&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(d=<span class="number">0</span> &amp;&amp; on_segment(startPoint,p1,p2))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//感觉这种方式不会用到(???)</span></span><br><span class="line"><span class="keyword">if</span>(d=<span class="number">0</span> &amp;&amp; on_segment(p1,startPoint,p2))<span class="comment">//共线的两种方式</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//以上条件都不符合 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_convex_hull</span><span class="params">(<span class="built_in">vector</span>&lt;POINT&gt; &amp; point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">POINT p0 = point[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;point.size();i++)&#123; <span class="comment">//找起始点，具体算法中的第一点</span></span><br><span class="line"><span class="keyword">if</span>(point[i].second &lt;p0.second ||</span><br><span class="line">point[i].second == p0.second &amp;&amp; point[i].first&lt;p0.first)&#123;</span><br><span class="line"> p0 = point[i];</span><br><span class="line"> k = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">point.erase(point.begin()+k);<span class="comment">//删除那个已经选出的点</span></span><br><span class="line">point.insert(point.begin(),p0);<span class="comment">//把p0插入到point的最前面</span></span><br><span class="line"><span class="built_in">vector</span>&lt;POINT&gt; convex_hull;    <span class="comment">//凸包容器</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">convex_hull.push_back(point[<span class="number">0</span>]);  <span class="comment">//在最后插入选出的点</span></span><br><span class="line">startPoint = point[<span class="number">0</span>];</span><br><span class="line">point.erase(point.begin());    <span class="comment">//删除已经选出的点,方便进行排序。</span></span><br><span class="line">sort(point.begin(),point.end(),sortByPolorAngle);</span><br><span class="line"><span class="keyword">if</span>(point[<span class="number">0</span>] == convex_hull[<span class="number">0</span>]) <span class="keyword">break</span>;  <span class="comment">//出口,形成了一个凸包</span></span><br><span class="line">point.push_back(convex_hull[convex_hull.size()<span class="number">-1</span>]); </span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;convex_hull.size();i++)<span class="comment">//打印凸包</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">'('</span>&lt;&lt;convex_hull[i].first&lt;&lt;<span class="string">','</span>&lt;&lt;convex_hull[i].second&lt;&lt;<span class="string">')'</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面给出验证main函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;POINT&gt; point;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入所有的点，我们将找出其对应的凸包:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> s = <span class="string">'Y'</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(s == <span class="string">'Y'</span>)&#123;</span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"x坐标:"</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"y坐标:"</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;y;</span><br><span class="line">point.push_back(make_pair(x,y));</span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"你还要继续输入吗？(Y/N):"</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"输入结束，对应凸包为:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">find_convex_hull(point);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面给出一些解释或补充，以便于更好理解代码:</p><ul><li><a href="https://blog.csdn.net/keng_s/article/details/52131034" target="_blank" rel="noopener">数学基础—向量运算(叉乘)</a>，<a href="http://blog.163.com/danshiming@126/blog/static/109412748201693133916831/" target="_blank" rel="noopener">三维向量叉乘推导</a>,给那些有强迫症的一定要打破砂锅问到底的孩子们。</li><li>STL容器对应的几个函数用法: <a href="https://blog.csdn.net/qingtianweichong/article/details/9531919" target="_blank" rel="noopener">C++学习之容器—erase()函数</a>,<a href="https://blog.csdn.net/hzw05103020/article/details/51785727" target="_blank" rel="noopener">insert()函数</a>,<a href="https://blog.csdn.net/sjpz0124/article/details/45191095" target="_blank" rel="noopener">push_back()使用方法</a>,<a href="https://www.cnblogs.com/AlvinZH/p/6784862.html?utm_source=itdadao&amp;utm_medium=referral#_label0" target="_blank" rel="noopener">sort()用法</a>。</li></ul>]]></content>
      
      <categories>
          
          <category> 算法与程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java对象基础</title>
      <link href="/Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%BA%8C.html"/>
      <url>/Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%BA%8C.html</url>
      <content type="html"><![CDATA[<blockquote><p>类是面向对象语言中最为重要的一种数据类型，类声明的变量称为对象。类是创建对象的模板，当使用一个类创建一个对象时，也称给出了这个类的一个实例。</p></blockquote><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p><em>创建对象包括<code>对象的声明</code>和<code>为声明的对象分配内存</code>两个步骤:</em>  </p><h5 id="对象的声明"><a href="#对象的声明" class="headerlink" title="对象的声明"></a>对象的声明</h5><p>类的名字  对象名字;      //声明之后，就可以分配内存了</p><h5 id="为声明的对象分配内存"><a href="#为声明的对象分配内存" class="headerlink" title="为声明的对象分配内存"></a>为声明的对象分配内存</h5><a id="more"></a><p>使用new运算符和类的构造方法为声明的对象分配内存，即调用构造方法为其分配内存。如果类中没有构造方法，系统会调用默认的构造方法(默认构造方法:无参无语句)。<strong>如果类中定义了一个或多个构造方法，那么Java不提供默认的构造方法。</strong><br>举个栗子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xiyoujiRenwu</span></span>&#123;</span><br><span class="line"><span class="keyword">float</span> height,weight;</span><br><span class="line">String head,ear,hand,foot,mouth;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example4_1</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span></span>&#123;</span><br><span class="line">xiyoujiRenwu zhubajie;    <span class="comment">//声明对象</span></span><br><span class="line">zhubajie = <span class="keyword">new</span> xiyoujiRenwu();  <span class="comment">//为对象分配内存，默认构造方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自建构造方法此处不再给出，在以后的讲述中会有提到。</span></span><br></pre></td></tr></table></figure></p><p><em>Notice:</em> 如果类中定义了一个或者多个构造方法，那么Java不提供默认的构造方法！！！</p><h5 id="对象的内存模型"><a href="#对象的内存模型" class="headerlink" title="对象的内存模型"></a>对象的内存模型</h5><p>接上面的代码给大家介绍一下对象的内存模型，以便于更好的理解对象这一概念：  </p><ul><li>声明对象zhubajie后，zhubajie的内存中还没有任何数据，也就是<strong>空对象</strong>。空对象不能使用，因为它还没有得到任何“实体”，必须再进行为**为对象分配内存的步骤，即为对象分配实体。</li><li><p>当系统见到:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhubajie = new xiyoujiRenwu();</span><br></pre></td></tr></table></figure><p>  时，就会做两件事。</p><ol><li>为xiyoujiRenwu类中的成员变量height, weight, head, ear, mouth, hand, foot分配内存，即类中的成员变量<strong>被分配内存空间</strong>，然后<strong>执行构造方法</strong>进行数据的初始化。(如果成员变量在声明时没有指定初值，并且所使用的构造方法也没有对成员变量进行初始化，那么，整型变量默认初值为0，浮点型变量默认初值0.0，boolean型变量默认false，引用型变量默认初值为NULL)。</li><li>给出一个信号，保证这些变量是属于对象zhubajie的。即new运算符为这些变量分配完内存后，会返回一个引用给zhubajie对象。(这样也就不难理解一个类使用new创建不同的对象(实例变量等)不会相互影响了，因为他们被分配不同的内存)。如下图所示:<br><img src="/1.png" alt="zhubajie"></li></ol></li></ul><h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><p>抽象的目的时产生类，而类的目的是创建具有属性和行为的对象。对象不仅可以操作自己的变量改变状态，而且还能调用类中的方法产生一定的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象.变量; //调用变量</span><br><span class="line">对象.方法; //调用方法</span><br></pre></td></tr></table></figure></p><p><strong>体现封装:</strong> 当对象调用方法时，方法中出现的成员变量就是分配给该对象的变量。当对象调用方法时，方法中的局部变量被分配内存空间，方法执行完毕，局部变量即可释放内存。<br><strong>Notice: 局部变量在声明时如果没有初始化，那么它就没有默认值</strong>。</p><h3 id="对象的引用和实体"><a href="#对象的引用和实体" class="headerlink" title="对象的引用和实体"></a>对象的引用和实体</h3><p>当用类创建一个对象时，类中的成员变量在堆(一种运行时的数据结构，支持动态内存管理) 中分配内存空间，这些内存空间成为该对象的实体或对象的变量，而上文所提到的对象中存放的引用在栈中分配内存，以确保实体由该对象使用。</p><p>由上面的解释大家可以知道，引用 和 实体 是分开的，即大家可以改变引用来相应改变它所能调用的实体。<br>这么说大家可能还是不清楚，举个栗子给大家:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x1aoPoint</span></span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span> a,b; <span class="comment">//public表示权限，后面会提到</span></span><br><span class="line"> x1aoPoint(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123; <span class="comment">//自定义构造方法(又复习了一下)</span></span><br><span class="line"><span class="keyword">this</span>.a = a;</span><br><span class="line"><span class="keyword">this</span>.b = b;  <span class="comment">//关于this会在后面的博客中提到哦</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lin</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">x1aoPoint p1,p2;</span><br><span class="line">p1 = <span class="keyword">new</span> x1aoPoint(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">p2 = <span class="keyword">new</span> x1aoPoint(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//下面是重点！！！</span></span><br><span class="line">System.out.println(<span class="string">"("</span>+p1.a+<span class="string">","</span>+p1.b+<span class="string">")"</span>);</span><br><span class="line">System.out.println(p1+<span class="string">"\n"</span>+p2);</span><br><span class="line">p1 = p2; <span class="comment">//改变引用，使p1也指向此前为p2分配的变量</span></span><br><span class="line">System.out.println(<span class="string">"("</span>+p1.a+<span class="string">","</span>+p1.b+<span class="string">")"</span>);</span><br><span class="line">System.out.println(p1+<span class="string">"\n"</span>+p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下，其余请自己体会:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面/javaExample$ vim Lin.java</span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面/javaExample$ javac Lin.java </span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面/javaExample$ java Lin</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">x1aoPoint@<span class="number">233</span>c0b17</span><br><span class="line">x1aoPoint@<span class="number">61</span>a52fbd</span><br><span class="line">(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">x1aoPoint@<span class="number">61</span>a52fbd</span><br><span class="line">x1aoPoint@<span class="number">61</span>a52fbd</span><br></pre></td></tr></table></figure></p><p><strong>最后补充一点:</strong> Java有所谓的“垃圾回收”机制：周期性的检测某个实体是否已经不再被任何对象所拥有，如果发现这样的实体，就会自动释放掉实体所占有的内存。所以，上面代码中，当p2的引用赋给p1时，最初分配给p1的实体就会被释放掉。</p>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类与对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java类基础知识</title>
      <link href="/Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B8%80.html"/>
      <url>/Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B8%80.html</url>
      <content type="html"><![CDATA[<h3 id="面向对象语言特性"><a href="#面向对象语言特性" class="headerlink" title="面向对象语言特性"></a>面向对象语言特性</h3><p>众所周知，Java是一门面向对象的编程语言，它的源程序由若干个类组成，源文件时拓展名为.java的文本文件。下面给出面向对象编程的特性:  </p><ul><li>1.封装性。即将数据和对数据的操作封装在一起，通过抽象，从具体的实例中抽取共同的性质形成一般的概念。比如类的概念。</li><li>2.继承性。子类可以继承父类的属性和功能，既继承了父类所有的数据和数据上的操作，同时又可以添加子类独有的数据和数据上的操作。</li><li>3.多态性。一种是操作名称的多态，既有多个操作具有相同的名字，但这些操作所接受的信息类型必须不同。另一种多态是和继承有关的多态，是指同一个操作被不同的类型对象调用时可能产生不同的行为。</li></ul><a id="more"></a><h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><p>类是组成Java程 序的基本要素，类封装了一类对象的状态与方法，类是用来定义对象的模板。类的实现包括两个部分，即类的声明和类体，基本格式如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span>&#123; <span class="comment">//类的声明</span></span><br><span class="line">类体的内容 <span class="comment">//类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>类的声明注意事项</em> :<br>1.类的名字要符合<a href="http://x1aolin6.top/2018/05/23/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">标识符的规定</a>。(语法要求)<br>2.如果类名使用拉丁字母，那么类名的首字母使用大写字母。(不是语法要求但需要遵守)<br>3.类名最好容易识别，见名知意。(不是语法要求但需要遵守)  </p><p><em>类体说明</em> :<br>1.类声明后的一对大括号{  }以及它们之间的内容成为类体，大括号之间的内容称为类体的内容。<br>2.类体由两个部分构成:一部分是<strong>变量的声明</strong>，用来<strong>刻画属性</strong>;另一部分是<strong>方法的定义</strong>，用来<strong>刻画功能</strong>。<br>举个栗子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trapezoid</span></span>&#123;</span><br><span class="line"><span class="keyword">float</span> 上底,下底,高,laderArea;  <span class="comment">//变量声明，刻画属性</span></span><br><span class="line"><span class="keyword">float</span> 计算面积()&#123;              <span class="comment">//方法定义，刻画功能</span></span><br><span class="line">laderArea = (上底+下底)*高/<span class="number">2.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 修改高(<span class="keyword">float</span> h)&#123;</span><br><span class="line"> 高 = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><h4 id="变量的有效范围"><a href="#变量的有效范围" class="headerlink" title="变量的有效范围"></a>变量的有效范围</h4><blockquote><p>在变量声明部分<strong>声明的变量</strong>被称为类的成员变量，在方法体中<strong>声明的变量</strong>和<strong>方法的参数</strong>被称为局部变量。当然，成员变量和局部变量的类型可以时Java中的任何一种数据类型。</p></blockquote><ul><li>成员变量在整个类内都有效，局部变量只在声明它的方法内有效。</li><li>方法参数在整个方法内有效，方法内的局部变量从声明他的位置之后开始有效。</li><li>如果局部变量的声明是在一个复合语句中，那么该有效范围的有效范围就是该复合语句，即仅在该复合语句中有效。</li><li>如果局部变量的声明是在一个循环语句中，那么该局部变量的有效范围是该循环语句，即仅在循环语句中有效。<br>举个栗子:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> m = <span class="number">10</span>,sum = <span class="number">0</span>;     <span class="comment">//成员变量，在整个类中有效</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(m&gt;<span class="number">9</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">10</span>;        <span class="comment">//z仅仅在该复合语句中有效</span></span><br><span class="line">z = <span class="number">2</span>*m + z;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">    sum += i;         <span class="comment">//i仅在该循环语句中有效</span></span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实例变量与类变量"><a href="#实例变量与类变量" class="headerlink" title="实例变量与类变量"></a>实例变量与类变量</h4><p>在声明成员变量前，用关键词static给予修饰的称作类变量(静态变量)，否则称之为实例变量(对象变量)。<br>类变量是所有对象共有，其中一个对象将它的值改变，其他对象得到的就是改变后的结果；而实例变量则属于对象私有，某一个对象将其值改变，不影响其他对象。<br>举个栗子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line"><span class="keyword">float</span> x = <span class="number">0</span>;    <span class="comment">//实例变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">0</span>;  <span class="comment">//类变量(静态变量)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Dog a1 = <span class="keyword">new</span> Dog();</span><br><span class="line">Dog a2 = <span class="keyword">new</span> Dog();</span><br><span class="line">a1.x = <span class="number">3.0f</span>;</span><br><span class="line">a1.y = <span class="number">4</span>;<span class="comment">//等同于 Dog.y = 4;</span></span><br><span class="line">System.out.println(a2.y); <span class="comment">//结果为4</span></span><br><span class="line">System.out.println(a2.x); <span class="comment">//结果为0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="成员的隐藏"><a href="#成员的隐藏" class="headerlink" title="成员的隐藏"></a>成员的隐藏</h4><p>如果局部变量的名字与成员变量的名字相同，则成员变量被隐藏，即这个成员变量在这个方法内失效。例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tom</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> x = <span class="number">99</span>,y;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"> y = x; <span class="comment">//y得到的值为3，而不是99</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果仍希望在该方法中使用隐藏的成员变量，需要用到关键词this,比如这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tom</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> x = <span class="number">99</span>,y;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"> y = <span class="keyword">this</span>.x; <span class="comment">//y得到的值为99,而不是3</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="变量书写风格"><a href="#变量书写风格" class="headerlink" title="变量书写风格"></a>变量书写风格</h4><p>虽然其中的一些要求不是语法要求，但是还是希望大家能够遵守，养成良好的变成习惯。</p><ul><li>一行只声明一个变量(便于给代码添加注释)。</li><li>变量的名字符合标识符的规定。</li><li>变量的名字见名知意，避免容易混淆的变量的名字，也尽量不要用a1,a2这种方式。</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>最基本的方法包括方法名和方法的返回类型，并且很多方法声明中都给出了方法的参数，例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">float</span> b,...)</span></span>&#123;<span class="comment">//参数可以省略，根据需要填写</span></span><br><span class="line">...<span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法的参数和返回类型可以是任意的Java数据类型，不需要返回类型时要用void。方法声明之后的一对大括号”{“、”}”以及之间的内容称为方法体。方法体内包括局部变量的声明和Java语句。写一个方法完全类似于C++里面的函数，只不过是面向对象语言中的称呼。</p><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>前面说过，Java中存在两种多态，即重载和重写，重写是和继承有关的多态，将在以后的博客中讨论。<br>方法重载是多态性的一种，所谓功能多态性，是指可以向功能传递不同的消息，以便让对象根据相应的消息产生相应的行为。<strong>方法重载</strong>的意思是，一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同(1.参数个数不同 2.参数类型不同)。<br>举个栗子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lin</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getArea</span><span class="params">(<span class="keyword">float</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14f</span>*r*r;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">(<span class="keyword">float</span> x,<span class="keyword">float</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getArea</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">float</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">(<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x*x+y*y+z*z)*<span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Notice:</strong> 方法的返回类型和参数的名字不参与比较，所以说，方法重载需要保证参数个数或者参数类型的不同！！！</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>和C++相同，当我们创建一个对象时，会调用构造方法进行初始化。构造方法也是一种特殊的方法， <em>它的名字必须与它所在类的名字完全相同</em> ,不需要写类型，也可以重载。<br>举个栗子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trapezoid</span></span>&#123;</span><br><span class="line"><span class="keyword">float</span> 上底，下底，高;</span><br><span class="line">Trapzoid()&#123;   <span class="comment">//构造方法</span></span><br><span class="line">上底 = <span class="number">60</span>;</span><br><span class="line">下底 = <span class="number">100</span>;</span><br><span class="line">高  = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">Trapzoid(<span class="keyword">float</span> x,<span class="keyword">int</span> y,<span class="keyword">float</span> z)&#123;   <span class="comment">//构造方法</span></span><br><span class="line">上底 = x;</span><br><span class="line">下底 = y;</span><br><span class="line">高 = z;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实例方法与类方法"><a href="#实例方法与类方法" class="headerlink" title="实例方法与类方法"></a>实例方法与类方法</h4><p>和实例变量和类变量一样，类中的方法也分为实例方法和类方法。在声明方法时，方法类型前面不加关键字static修饰的是实例方法，加static的是类方法(静态方法)。<br>举个例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">b</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">float</span> y)</span></span>&#123;<span class="comment">//实例方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(String s)</span></span>&#123;<span class="comment">//类方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>想了解实例方法和类方法的区别请点击：<a href="http://x1aolin6.top/2018/06/11/Java%E4%B9%8Bstatic%E5%85%B3%E9%94%AE%E5%AD%97/" target="_blank" rel="noopener">实例方法和类方法的区别传送门</a></p><h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice:"></a><em>Notice:</em></h3><ul><li>对成员变量的操作只能放在方法中，方法可以对成员变量和该方法体中声明的局部变量进行操作。当然，在声明类的成员变量时可以同时赋予初值。</li><li>实例方法既能对类变量操作也能对实例变量进行操作，而类方法只能对类变量进行操作。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a;   <span class="comment">//实例变量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> b;<span class="comment">//类变量</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//实例方法</span></span><br><span class="line">    a = x;<span class="comment">//true</span></span><br><span class="line">          b = y;<span class="comment">//true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">       b = <span class="number">23</span>; <span class="comment">//true</span></span><br><span class="line">      a = z; <span class="comment">//False</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>一个类中的方法可以相互调用，实例方法可以调用该类中的其他方法；类中的类方法只能调用该类的类方法，不能调用实例方法。</li></ul>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类与对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java语句基础</title>
      <link href="/Java%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5%E4%BA%8C.html"/>
      <url>/Java%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5%E4%BA%8C.html</url>
      <content type="html"><![CDATA[<h3 id="语句概述"><a href="#语句概述" class="headerlink" title="语句概述"></a>语句概述</h3><p>Java中的语句可分为以下六类。<br>(1)方法调用语句。例如<code>System.out.pritln(&quot;x1aolin&quot;)</code><br>(2)表达式语句。即由一个表达式构成的语句。<br>(3)复合语句。和C++一样，Java中也可以用{  }把一些语句括起来构成符合语句。<br>(4)空语句。由一个分号构成的语句。<br>(5)控制语句。条件分支语句，开关语句，和循环语句，下面会有简单介绍。<br>(6)package语句和import语句。它们和类，对象有关，将在后续的blog中进行介绍。  </p><a id="more"></a><h3 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h3><p>主要分为if语句，if-else语句，if-else if-else语句。和C++用法完全一致，此处仅给出其相应的格式。<br>语法格式如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)&#123;</span><br><span class="line">若干语句</span><br><span class="line">&#125;         <span class="comment">//if语句语法格式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(表达式)&#123;</span><br><span class="line">若干语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">若干语句</span><br><span class="line">&#125;         <span class="comment">//if-else语法格式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(表达式)&#123;</span><br><span class="line">若干语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(若干语句)&#123;</span><br><span class="line">若干语句</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">若干语句</span><br><span class="line">&#125;        <span class="comment">//if-else if-else语法格式</span></span><br></pre></td></tr></table></figure></p><h3 id="开关语句"><a href="#开关语句" class="headerlink" title="开关语句"></a>开关语句</h3><p>也就是switch case 语句，格式如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line"> 若干语句</span><br><span class="line">     <span class="keyword">break</span>;   <span class="comment">//可选，下面会讲述break的作用</span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line"> 若干语句</span><br><span class="line">     <span class="keyword">break</span>;   <span class="comment">//可选，下面会讲述break的作用</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量n:</span><br><span class="line"> 若干语句</span><br><span class="line">     <span class="keyword">break</span>;   <span class="comment">//可选，下面会讲述break的作用</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"> 若干语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>注意 :</em></p><ul><li>“表达式”的值必须为byte、short、int、char型或<a href="http://x1aolin6.top/2018/05/31/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">枚举类型</a>，他们当中的常量值也必须为上述类型且须各不相同。</li><li>switch语句首先计算表达式的值，计算结果对应case后面的变量值，并执行其后面对应的语句，直到碰到break为止，也就是说如果对应的case语句结尾没有break，那么程序就会执行紧随其后的一个case当中的内容。</li></ul><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="1-for循环语句"><a href="#1-for循环语句" class="headerlink" title="1.for循环语句"></a>1.for循环语句</h4><p>语法格式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)&#123;</span><br><span class="line">若干语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>说明 :</em><br>(1)“表达式1”负责完成变量的初始化。<br>(2)“表达式2”是boolean型的表达式，称为循环条件。<br>(3)“表达式3”用来修饰变量，改变循环条件。</p><h4 id="2-while语句和do-while语句不再多说"><a href="#2-while语句和do-while语句不再多说" class="headerlink" title="2.while语句和do-while语句不再多说"></a>2.while语句和do-while语句不再多说</h4><h3 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h3><p>(1)break和continue语句是用关键字break和continue加上分号构成的语句。<br>(2)如果在某次循环中执行了break语句，那么整个循环语句就结束。<br>(3)如果在某次循环中执行了continue语句，那么本次循环结束，不再执行continue后面的语句，转入进行下一次循环。</p><h3 id="数组和for语句"><a href="#数组和for语句" class="headerlink" title="数组和for语句"></a>数组和for语句</h3><p>Java的JDK1.5版本对for语句的功能给予扩充、增强，以便更好的遍历数组。其语法格式如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明循环变量:数组的名字)&#123;</span><br><span class="line">...  </span><br><span class="line">&#125;</span><br><span class="line">!!! 注意声明的循环变量类型必须和数组的类型相同</span><br></pre></td></tr></table></figure></p><p>举例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">x1ao</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> b[] = &#123;<span class="string">'l'</span>,<span class="string">'i'</span>,<span class="string">'n'</span>,<span class="string">'r'</span>&#125;;</span><br><span class="line">  <span class="comment">//传统打印方式</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">     System.out.print(a[i]+<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;++i)&#123;<span class="comment">//上面有提到++x和x++的区别</span></span><br><span class="line"> System.out.print(b[i]+<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(); <span class="comment">//美观换行</span></span><br><span class="line">  <span class="comment">//改进方式</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j:a)&#123;<span class="comment">//循环变量j依次取数组的每一个元素值</span></span><br><span class="line">System.out.print(j+<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">char</span> ch:b)&#123;</span><br><span class="line">System.out.print(ch+<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(); <span class="comment">//美观换行</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下，有问题请在评论区留言:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面/javaExample$ vim x1ao.java</span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面/javaExample$ javac x1ao.java </span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面/javaExample$ java x1ao</span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> l i n r </span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> l i n r</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java运算符、表达式和语句 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java运算符相关</title>
      <link href="/Java%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5%E4%B8%80.html"/>
      <url>/Java%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5%E4%B8%80.html</url>
      <content type="html"><![CDATA[<blockquote><p>说明： 因为这一块和C语言的规则相差无几，所以此处不会重点描述，只说明一下其中的重点和与C不同的部分。</p></blockquote><h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><p>该运算符为二目运算符，左边的操作单元是一个对象，右边的是一个类。当左边的对象时右边的类或者子类创建的对象时，该运算符运算的结果时true,否则为false。</p><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>此处仅以（++X）和（X++）为例。粗略的看，<code>++x</code> 和 <code>x++</code> 的作用都是使x+1。<br>但是<code>++x</code>是先执行<code>x=x+1</code>，然后再使用x的值，而<code>x++</code>是先使用x的值然后再执行<code>x=x+1</code>。举个栗子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span>;  <span class="comment">//仅给出部分代码显示其功能</span></span><br><span class="line">y = ++x;  <span class="comment">// y的值为6</span></span><br><span class="line">z = x++;  <span class="comment">// z的值为5</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="运算符优先级与结合性"><a href="#运算符优先级与结合性" class="headerlink" title="运算符优先级与结合性"></a>运算符优先级与结合性</h3><table><thead><tr><th style="text-align:center">优先级</th><th style="text-align:left">描述</th><th style="text-align:left">运算符</th><th style="text-align:center">结合性</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">分隔符</td><td style="text-align:left">[  ] (  ) . , ;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">对象归类，自增，自减函数，逻辑非</td><td style="text-align:left">instanceof, ++, –, !</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">算数乘除运算</td><td style="text-align:left">*, /, %</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">算数加减运算</td><td style="text-align:left">+, -</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">移位运算</td><td style="text-align:left">&gt;&gt;, &lt;&lt;, &gt;&gt;&gt;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">大小关系运算</td><td style="text-align:left">&lt;, &lt;=, &gt;, &gt;=</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">相等关系运算</td><td style="text-align:left">==, !=</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">8</td><td style="text-align:left">按位与运算</td><td style="text-align:left">&amp;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">9</td><td style="text-align:left">按位异或运算</td><td style="text-align:left">^</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">10</td><td style="text-align:left">按位或运算</td><td style="text-align:left">&#124;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">11</td><td style="text-align:left">逻辑与运算</td><td style="text-align:left">&amp;&amp;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">12</td><td style="text-align:left">逻辑或运算</td><td style="text-align:left">&#x7C;&#x7C;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">13</td><td style="text-align:left">三木条件运算</td><td style="text-align:left">表达式?语句1:语句2</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">14</td><td style="text-align:left">赋值运算</td><td style="text-align:left">=</td><td style="text-align:center">从右到左</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java运算符、表达式和语句 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java枚举类型</title>
      <link href="/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B.html"/>
      <url>/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B.html</url>
      <content type="html"><![CDATA[<h3 id="声明枚举类型"><a href="#声明枚举类型" class="headerlink" title="声明枚举类型"></a>声明枚举类型</h3><p>java使用关键字 enum 声明枚举类型，语法格式如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名</span><br><span class="line">&#123; 常量列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中的“常量列表”是用逗号分隔的字符序列，称为枚举类型的常量(需符合<a href="http://x1aolin6.top/2018/05/23/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">标识符规定</a>)。例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> x1ao</span><br><span class="line">&#123; one,two,three,four</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="声明枚举变量"><a href="#声明枚举变量" class="headerlink" title="声明枚举变量"></a>声明枚举变量</h3><p> 声明了一个枚举类型后，就可以用该枚举类型的枚举声明一个枚举变量了。例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x1ao x; <span class="comment">//用到了上面的声明</span></span><br></pre></td></tr></table></figure></p><p>这样，枚举类型就可以使用枚举名和”,”运算符获得枚举类型中的常量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x1ao.one; <span class="comment">//这时候使用System.out.println(x)就可以显示one字符串</span></span><br></pre></td></tr></table></figure></p><h3 id="说明与举例"><a href="#说明与举例" class="headerlink" title="说明与举例"></a>说明与举例</h3><p>可以在一个Java源文件中声明、定义枚举类型，然后保存源文件，最后单独编译源文件得到枚举类型的字节码文件，那么该字节码就可以被其他源文件中的类使用。下面给出示例:  </p><p><strong>Weekday.java文件</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Weekday&#123;</span><br><span class="line"> 星期一,星期二,星期三,星期四,星期五,星期六,星期日</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Example7.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example7</span></span>&#123;<span class="comment">//文件名随便起，限制条件请分类查找java第一篇博客</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">  Weekday x = Weekday.星期日;</span><br><span class="line">  <span class="keyword">if</span>(x==Weekday.星期日)&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">    System.out.println(<span class="string">"今天我休息！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面给出运行结果，大家可以自己运行试试,<strong>复制代码后将中文逗号等字符改成英文状态！！！</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ javac Example7.java </span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ java Example7</span><br><span class="line">星期日</span><br><span class="line">今天我休息！</span><br></pre></td></tr></table></figure></p><hr><h3 id="补充-枚举类型与for，switch数组"><a href="#补充-枚举类型与for，switch数组" class="headerlink" title="补充:枚举类型与for，switch数组"></a>补充:枚举类型与for，switch数组</h3><ul><li>除了上面所说，枚举类型可以用<code>枚举类型的名字.values()</code>返回一个数组，该数组的值与该枚举类型中的常量一一对应。</li><li>jdk1.5后的版本允许<a href="http://x1aolin6.top/2018/06/01/Java%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5%E4%BA%8C/" target="_blank" rel="noopener">switch语句中表达式</a>的值是枚举类型。</li></ul>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java从命令行输入和输出数据</title>
      <link href="/Java%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE.html"/>
      <url>/Java%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE.html</url>
      <content type="html"><![CDATA[<h3 id="输入基本型数据"><a href="#输入基本型数据" class="headerlink" title="输入基本型数据"></a>输入基本型数据</h3><blockquote><p>在<a href="http://x1aolin6.top/2018/05/23/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">Java基本类型介绍</a> 一节中提到，Java程序都是由若干个类组成的，所以输入也是一个类。</p></blockquote><h4 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h4><p>Scanner类用与创建一个对象:<code>Scanner reader = new Scanner(System.in)</code> </p><p>然后reader对象可通过以下函数对应读取用户在命令行输入的各种基本类型:<br><code>nextBoolean()</code>,<code>nextByte()</code>,<code>nexyShort()</code>,<code>nextInt()</code>,<code>nextLong()</code>,<code>nextFloat()</code>,<code>nextDouble()</code></p><p><em>注意：上述方法在执行时都会发生堵塞，程序等待用户在命令行输入数据并按Enter确认。</em></p><a id="more"></a><p>下面通过一个实例加深以下理解:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example2</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"请输入若干个数，每输入一个数回车确认"</span>);</span><br><span class="line">      System.out.println(<span class="string">"最后输入数字-9999结束输入操作"</span>);</span><br><span class="line">  Scanner lll = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> x = lll.nextDouble();</span><br><span class="line">  <span class="keyword">while</span>(x!=-<span class="number">9999</span>)&#123;</span><br><span class="line">      m+=<span class="number">1</span>;    <span class="comment">// m = m + 1;</span></span><br><span class="line">  sum+=x;  <span class="comment">// sum = sum + x;</span></span><br><span class="line">  x = lll.nextDouble();</span><br><span class="line">  &#125;</span><br><span class="line">      System.out.println(m+<span class="string">"个数的和为"</span>+sum);</span><br><span class="line">      System.out.println(m+<span class="string">"个数的平均值为"</span>+sum/m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下，其余自行体会：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ java Example2</span><br><span class="line">请输入若干个数，每输入一个数回车确认</span><br><span class="line">最后输入数字-<span class="number">9999</span>结束输入操作</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">-<span class="number">9999</span></span><br><span class="line"><span class="number">4</span>个数的和为<span class="number">18.0</span></span><br><span class="line"><span class="number">4</span>个数的平均值为<span class="number">4.5</span></span><br></pre></td></tr></table></figure></p><h3 id="输入基本型数据-1"><a href="#输入基本型数据-1" class="headerlink" title="输入基本型数据"></a>输入基本型数据</h3><p>三种类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println() <span class="comment">//1</span></span><br><span class="line">System.out.print()   <span class="comment">//2 二者的区别是1号代码输出数据后换行，2号不换行</span></span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">"格式控制部分"</span>，表达式<span class="number">1</span>，表达式<span class="number">2</span>，...,表达式n)<span class="comment">//类似c语言</span></span><br></pre></td></tr></table></figure></p><p>注意事项:</p><ul><li><p>使用时不可以采取回车操作 </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"你好，</span></span><br><span class="line"><span class="string">                    很高兴认识你"</span>); <span class="comment">// !!! 错误示范</span></span><br><span class="line">System.out.println(<span class="string">"你好,"</span> +</span><br><span class="line">                   <span class="string">"很高兴认识你"</span>); <span class="comment">// !!! 正确示范</span></span><br><span class="line">字符串过长时用并置符号 + 将其首尾相连</span><br></pre></td></tr></table></figure></li><li><p>在java中，允许使用并置符号 + 将变量、表达式或一个常数值与一个字符串并置在一起输出</p></li><li>对于上述第三种输出方法，有以下格式：<br>(1)%d: int型数据<br>(2)%f: 浮点型数据，<strong>小数部分最多保留6位。</strong><br>(3)%c: char型数据<br>(4)%s: 字符串数据<br>(5)<strong>%md:输出的int数据占据m列</strong><br>(6)<strong>%m.nf:输出的浮点型数据占据m列，小数点保留n位</strong>(小数点也会占一列)<br>例如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"%d %f"</span>,<span class="number">12</span>,<span class="number">23.78</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java数组的用法</title>
      <link href="/Java%E6%95%B0%E7%BB%84.html"/>
      <url>/Java%E6%95%B0%E7%BB%84.html</url>
      <content type="html"><![CDATA[<h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><hr><p><em>一维数组声明格式：</em><br>(1) 数组的元素类型 数组名称[  ];<br>(2) 数组的元素类型[  ] 数组名称;  </p><p><em>二维数组声明格式：</em><br>(1) 数组的元素类型 数组名称[  ][  ];<br>(2) 数组的元素类型[  ][  ] 数组名称;<br>举例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> boy[];   <span class="comment">// 等价于 float[] boy;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> cat[][];  <span class="comment">// 等价于 char[][] cat;</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p><em>注意 :</em><br>(1) 数组boy的元素类型可以是Java中的任何一种类型。假如已经声明了一个Hello类型，那么就可以声明一个数组: <code>Hello hh[]</code>;<br>(2) 与C不同，Java<strong>不允许</strong>在声明数组的方括号内指定数组的方括号内指定数组元素个数。<code>int a[6]</code>或<code>int[8] b</code>等都会导致语法错误。</p><h3 id="创建数组及初始化"><a href="#创建数组及初始化" class="headerlink" title="创建数组及初始化"></a>创建数组及初始化</h3><hr><blockquote><p>声明数组仅仅是给出了数组名字和元素的数据类型，如果想要使用还必须为它分配内存空间，即创建数组。</p></blockquote><ul><li><p>静态初始化: 即定义数组的同时对数组进行初始化。<br>举例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//这样就间接创建了一个拥有5个元素的数组</span></span><br></pre></td></tr></table></figure></li><li><p>动态初始化: 使用运算符new为数组分配空间。格式为：<code>数组名字 = new 数组元素的类型[数组元素的个数]</code><br>举例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[];   <span class="comment">//声明</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">//创建一个元素值为五个的数组</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>; a[<span class="number">1</span>]=<span class="number">2</span>; a[<span class="number">2</span>]=<span class="number">3</span>; a[<span class="number">3</span>]=<span class="number">4</span>; a[<span class="number">4</span>]=<span class="number">5</span>;  <span class="comment">//同上面静态初始化的值</span></span><br></pre></td></tr></table></figure></li><li><p>声明数组和创建数组可以一起完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> xiao[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">5</span>];  <span class="comment">//一维数组的创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lin[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];  <span class="comment">//当然也可以分开，先声明后创建</span></span><br></pre></td></tr></table></figure></li><li><p>Java采用“数组的数组”声明多维数组，即一个二维数组是由若干个一维数组组成的，<br>比如上述创建的二维数组lin就是由4个长度为3的一维数组<code>lin[0]</code>,<code>lin[1]</code>,<code>lin[2]</code>,<code>lin[3]</code>构成的。</p></li><li><p>!!! 构成二维数组的一维数组不必要有相同的长度，在创建二维数组时可以分别指定构成该二维数组的一维数组的长度。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lin[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][]; <span class="comment">//未完成创建数组，该数组还不能使用 </span></span><br><span class="line">lin[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">lin[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">lin[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">lin[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]; <span class="comment">//完成，一维数组大小我是随意定的</span></span><br><span class="line"><span class="comment">//也可以使用下面的方式</span></span><br><span class="line"><span class="keyword">int</span> lin[][] = &#123;&#123;<span class="number">9</span>&#125;,&#123;<span class="number">2</span>,<span class="number">5</span>&#125;,&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>&#125;&#125;;<span class="comment">//分配内存大小和上面相同</span></span><br></pre></td></tr></table></figure></li></ul><p>数组变量a中存放着这些内存单元的首地址，该地址称作数组的引用。</p><h3 id="数组元素的使用"><a href="#数组元素的使用" class="headerlink" title="数组元素的使用"></a>数组元素的使用</h3><hr><ul><li>一维数组通过索引符访问自己的元素。注意索引符从0开始，若数组有10个元素，那么索引为0~9。</li><li>二维数组也是如此。举个栗子给大家尝尝:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lin[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];  <span class="comment">//第一个索引为0~3，第二个索引为0~2</span></span><br><span class="line">lin[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">12</span>;  </span><br><span class="line">lin[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="length的使用"><a href="#length的使用" class="headerlink" title="length的使用"></a>length的使用</h3><hr><p><em>说明: 数组的元素个数称为数组的长度。</em></p><ul><li>对于一维数组，“数组名字.length”的值就是数组中元素的个数;</li><li>对于二维数组，“数组名字.length”的值为它含有的一维数组的个数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> xiao[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">5</span>];  <span class="comment">//xiao.length的值为5 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lin[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];  <span class="comment">//lin.length的值为4</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数组的引用"><a href="#数组的引用" class="headerlink" title="数组的引用"></a>数组的引用</h3><hr><blockquote><p>数组为引用型变量，因此，两个相同类型的数组如果具有相同的引用，它们就会有完全相同的元素。</p></blockquote><p>对于 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  </span><br><span class="line"><span class="keyword">int</span> b[] = [<span class="number">4</span>,<span class="number">5</span>];  </span><br><span class="line">a = b; <span class="comment">// a,b类型必须相同</span></span><br></pre></td></tr></table></figure></p><p>如果这么处理，a中存放的引用和b的相同，系统将释放最初分配给数组a的元素，使得a的元素和b的元素相同。<br><em>举个栗子做个小小的总结：</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;    <span class="comment">//输出数组，下面会讲到</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example3</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> b[] = &#123;<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  System.out.println(<span class="string">"数组a的元素个数 = "</span>+a.length);</span><br><span class="line">  System.out.println(<span class="string">"数组b的元素个数 = "</span>+b.length);</span><br><span class="line">  System.out.println(<span class="string">"数组a的引用 = "</span>+a);</span><br><span class="line">  System.out.println(<span class="string">"数组a的引用 = "</span>+b);</span><br><span class="line">  System.out.println(<span class="string">"a==b的结果为 "</span>+(a==b));</span><br><span class="line">  a = b;</span><br><span class="line">  System.out.println(<span class="string">"数组a的元素个数 = "</span>+a.length);</span><br><span class="line">  System.out.println(<span class="string">"数组b的元素个数 = "</span>+b.length);</span><br><span class="line">  System.out.println(<span class="string">"a==b的结果为 "</span>+(a==b));</span><br><span class="line">  System.out.println(<span class="string">"a数组:"</span>+Arrays.toString(a));</span><br><span class="line">  System.out.println(<span class="string">"b数组:"</span>+Arrays.toString(b));</span><br></pre></td></tr></table></figure></p><p>运行结果如下,其余自行体会:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ java Example3</span><br><span class="line">数组a的元素个数 = <span class="number">3</span></span><br><span class="line">数组b的元素个数 = <span class="number">2</span></span><br><span class="line">数组a的引用 = [I<span class="meta">@c</span>39f790</span><br><span class="line">数组a的引用 = [I@<span class="number">71e7</span>a66b</span><br><span class="line">a==b的结果为 <span class="keyword">false</span></span><br><span class="line">数组a的元素个数 = <span class="number">2</span></span><br><span class="line">数组b的元素个数 = <span class="number">2</span></span><br><span class="line">a==b的结果为 <span class="keyword">true</span></span><br><span class="line">a数组:[<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b数组:[<span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><hr><blockquote><p>通过上面的讲述我们知道，数组属于引用类型，所以在复制数组的时候不能简单的执行<code>b=a</code>这类代码。<br>因为此操作只能使他们指向相同的内存单元，此时改变a[1]也就是改变了b[1],并不是实际的复制了数组。</p></blockquote><p>下面介绍Java中三种复制方法，各有利弊，请自行评判。  </p><h4 id="1-arraycopy方法"><a href="#1-arraycopy方法" class="headerlink" title="1.arraycopy方法"></a>1.arraycopy方法</h4><p>利用循环把一个数组的元素的值赋给另一个数组中的元素。这里用System类调用方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(sourceArray,<span class="keyword">int</span> index1,copyArray,<span class="keyword">int</span> index2,<span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure></p><p>可以将数组sourceArray从索引index1开始的length个元素中的数据复制到数组copyArray中，copyArray数组从第index2元素开始存放这些数据，如果数组copyArray不能存放下复制的数据，程序运行将会发生异常。下面给出示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example4</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> a[] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span>[] b = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">6</span>];</span><br><span class="line">  b[<span class="number">0</span>]=<span class="string">'1'</span>;b[<span class="number">1</span>]=<span class="string">'2'</span>;b[<span class="number">2</span>]=<span class="string">'3'</span>;b[<span class="number">3</span>]=<span class="string">'4'</span>;b[<span class="number">4</span>]=<span class="string">'5'</span>;b[<span class="number">5</span>]=<span class="string">'6'</span>;</span><br><span class="line">  <span class="keyword">int</span>[] c;</span><br><span class="line">  c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">  c[<span class="number">0</span>]=<span class="number">1</span>;c[<span class="number">1</span>]=<span class="number">2</span>;c[<span class="number">2</span>]=<span class="number">3</span>;c[<span class="number">3</span>]=<span class="number">4</span>;c[<span class="number">4</span>]=<span class="number">5</span>;c[<span class="number">5</span>]=<span class="number">6</span>;</span><br><span class="line">  <span class="keyword">int</span> d[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;;</span><br><span class="line">  <span class="comment">//复习前面的内容</span></span><br><span class="line">  System.arraycopy(a,<span class="number">0</span>,b,<span class="number">0</span>,a.length);</span><br><span class="line">  System.arraycopy(c,<span class="number">2</span>,d,<span class="number">2</span>,(c.length-<span class="number">3</span>));</span><br><span class="line">  System.out.println(<span class="string">"数组a:"</span>+Arrays.toString(a));</span><br><span class="line">      System.out.println(<span class="string">"数组b:"</span>+Arrays.toString(b));</span><br><span class="line">  System.out.println(<span class="string">"数组c:"</span>+Arrays.toString(c));</span><br><span class="line">  System.out.println(<span class="string">"数组d:"</span>+Arrays.toString(d));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ vim Example4.java</span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ javac Example4.java </span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ java Example4</span><br><span class="line">数组a:[a, b, c, d, e, f]</span><br><span class="line">数组b:[a, b, c, d, e, f]</span><br><span class="line">数组c:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">数组d:[<span class="number">10</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">60</span>]</span><br></pre></td></tr></table></figure></p><p>缺点: 事先必须创建参数copyArray指定的数组。</p><h4 id="2-copyOf和copyOfRange方法"><a href="#2-copyOf和copyOfRange方法" class="headerlink" title="2.copyOf和copyOfRange方法"></a>2.copyOf和copyOfRange方法</h4><p>Array类用copyOf调用方法有:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] copyOf(<span class="keyword">double</span>[] original,<span class="keyword">int</span> newLength)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span>[] copyOf(<span class="keyword">float</span>[] original,<span class="keyword">int</span> newLength)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[]  copyOf(<span class="keyword">int</span>[] original,<span class="keyword">int</span> newLength)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[]  copyOf(<span class="keyword">char</span>[] original,<span class="keyword">int</span> newLength)</span><br></pre></td></tr></table></figure></p><p>可以把参数original指定的数组中从索引0开始的newLength个元素复制到一个新数组中，并返回这个新数组，且该新数组的长度为newLength。<br>如果newLength的值大于original的长度，则其余的用0补齐。</p><p>Array类用copyOfRange调用方法有:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] copyOfRange(<span class="keyword">double</span>[] original,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span>[] copyOfRange(<span class="keyword">float</span>[] original,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[]  copyOfRange(<span class="keyword">int</span>[] original,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[]  copyOfRange(<span class="keyword">char</span>[] original,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span><br></pre></td></tr></table></figure></p><p>复制部分值。把参数original指定的数组中从索引from至to-1的元素复制到一个新数组中，并返回这个新数组，即新数组的长度为to-from。当然，如果新数组比原数组长，则多的那个部分补0。示例如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example5</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] a = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;,b,c,d;</span><br><span class="line">  b = Arrays.copyOf(a,<span class="number">10</span>);</span><br><span class="line">  System.out.println(<span class="string">"数组a:"</span>+Arrays.toString(a));</span><br><span class="line">      System.out.println(<span class="string">"数组b:"</span>+Arrays.toString(b));</span><br><span class="line">      c = Arrays.copyOfRange(a,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">      System.out.println(<span class="string">"数组c:"</span>+Arrays.toString(c));</span><br><span class="line">      d = Arrays.copyOfRange(a,<span class="number">3</span>,<span class="number">9</span>);</span><br><span class="line">      System.out.println(<span class="string">"数组d:"</span>+Arrays.toString(d));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下,其余自行体会:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ vim Example5.java   <span class="comment">//ubuntu命令行的操作</span></span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ javac Example5.java </span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ java Example5</span><br><span class="line">数组a:[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line">数组b:[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">数组c:[<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line">数组d:[<span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><hr><h3 id="补充1-数组的表示格式"><a href="#补充1-数组的表示格式" class="headerlink" title="补充1:数组的表示格式"></a>补充1:数组的表示格式</h3><blockquote><p><em>前提</em>: 引用 <code>import java.util.Arrays</code>，以后的博客中会讲到。  </p></blockquote><p>除了向C/C++中一样用循环输出数组的值外，JDK1.5版本提供了一个简单的<br>输出元素值的放大。<br>让Arrays类调用:<code>public static String toString(int[] a)</code>方法，<br>可以得到参数指定的一维数组a的数据，格式如下:<code>[a[0],a[1],a[2], ... ,a[a.length-1]]</code><br>示例在上面“数组的引用”模块已经给出，此处不再示例。</p><h3 id="补充2-Java数组排序"><a href="#补充2-Java数组排序" class="headerlink" title="补充2:Java数组排序"></a>补充2:Java数组排序</h3><p>这里重点说明Arrays类调用方法实现对数组的快速排序。两种调用方法:<br><code>public static void sort(double a[])</code><br><code>public static void sort(double a[],int start,int end)</code>  </p><h3 id="补充3-对已排序数组进行二分查找"><a href="#补充3-对已排序数组进行二分查找" class="headerlink" title="补充3:对已排序数组进行二分查找"></a>补充3:对已排序数组进行二分查找</h3><p><code>public static int binarySearch(double[] a,double number)</code><br>判断参数number指定的数是否在参数a指定的数组中，如果number在数组中，返回<strong>该元素的索引</strong>，如果找不到便返回一个负数。示例如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example6</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> []a = &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>&#125;;</span><br><span class="line">  Arrays.sort(a);</span><br><span class="line">  System.out.println(Arrays.toString(a));</span><br><span class="line">      <span class="keyword">int</span> number = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">int</span> index = Arrays.binarySearch(a,number);</span><br><span class="line">  <span class="keyword">if</span>(index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">      System.out.println(number+<span class="string">"和数组中的索引为"</span>+index+<span class="string">"的元素值相同"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(number+<span class="string">"不与数组中的任何元素值相同"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下，其余自行体会<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ vim Example6.java</span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ javac Example6.java </span><br><span class="line">x1aolin<span class="meta">@x</span>1aolin-E402NA:~/桌面$ java Example6</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="number">6</span>和数组中的索引为<span class="number">5</span>的元素值相同</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基本类型介绍</title>
      <link href="/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.html"/>
      <url>/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.html</url>
      <content type="html"><![CDATA[<blockquote><p>说明: <em>关于编译环境，安装相应的IDE等相关知识本文不会介绍，请自行百度</em></p></blockquote><h3 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h3><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p><em>定义</em> : 用来标识类名、变量名、方法名、类型名、数组名、文件名的有效字符序列。</p><p><em>语法规则</em> :<br>(1) 由字母、下划线、美元符号$、数字构成，长度无限制。<br>(2) 第一个字符不可以是数字字符。<br>(3) 不可以是关键字(关键字会在后续说明)。<br>(4) 不可以是true、false、null这三个字符。<br>(5) Java为强类型语言，所以<strong>严格区分大小写</strong>。<br>(6) 使用比ASCII码更广泛的Unicode字符集，所以在(1)中所说的“字母”包含部分简体中文。  </p><a id="more"></a><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><em>说明</em> : 关键字就是Java中被赋予特定意义的单词。下面给出部分示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span>; <span class="keyword">assert</span>; <span class="keyword">boolean</span>; <span class="keyword">break</span>; <span class="keyword">byte</span>; <span class="keyword">case</span>; <span class="keyword">catch</span>;  </span><br><span class="line"><span class="keyword">char</span>; <span class="class"><span class="keyword">class</span></span>; <span class="keyword">const</span>; <span class="keyword">continue</span> <span class="keyword">default</span>; <span class="keyword">do</span>; <span class="keyword">double</span>; <span class="keyword">else</span>;  </span><br><span class="line"><span class="keyword">enum</span>; extends; <span class="keyword">final</span>; ...  <span class="comment">//分号表示间隔</span></span><br></pre></td></tr></table></figure></p><h4 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h4><p><em>1.注释符</em> :<br>(1)// 单行注释(以双斜杠开始，终止于行尾，注释一行，可放在语句后面)<br>(2)<code>/*</code> <code>*/</code> 多行注释( <code>/*</code>开始，<code>*/</code>结束，中间可写多行)<br>(3)<code>/**</code>开始，<code>*/</code>结束，这种注释主要是为了支持JDK工具javadoc而采用的。</p><p><em>2.空白符</em> :<br>空格，回车，换行，制表符tab等。 为增强代码的可读性而建立，系统编译时会忽略它。</p><p><em>3.普通分隔符</em> :<br>点号，分号，冒号，大括号，方括号，小括号。因为和C/C++用法相同，此处不再赘述。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java语言有八中基本数据类型，习惯上可以分为四大类:</p><ul><li>逻辑类型: boolean</li><li>整数类型: byte 、short 、int 、long</li><li>字符类型: char</li><li>浮点类型: float 、double</li></ul><h4 id="逻辑类型"><a href="#逻辑类型" class="headerlink" title="逻辑类型"></a>逻辑类型</h4><p>常量: true 、false<br>变量: 使用关键字<code>boolean</code>来声明。</p><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><blockquote><p>十进制用数字1~9开头，八进制用数字0开头，十六机制用0x开头。</p></blockquote><p>因为基本上和C语言差不多，稍微有点编程基础就可以理解，此处就不再赘述。<br>重点讲一下和C语言不同的地方:<br>(1)Java中不存在byte和short的常量表示法，但是可以把一定范围内的int型常量赋值给byte或short型变量。<br>(2)long型常量用后缀L来表示，如108L。<br>(3)这四个不同的类型区别：只是声明时系统分配予其内存的大小和其所能表示数的范围大小。</p><table><thead><tr><th style="text-align:center">整数类型</th><th style="text-align:center">所占字节数</th><th style="text-align:center">所占位数</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">int型</td><td style="text-align:center">4 byte</td><td style="text-align:center">32 bit</td><td style="text-align:center">-2<sup>31</sup>~2<sup>^31</sup>-1</td></tr><tr><td style="text-align:center">byte型</td><td style="text-align:center">1 byte</td><td style="text-align:center">8 bit</td><td style="text-align:center">-2<sup>7</sup>~2<sup>7</sup>-1</td></tr><tr><td style="text-align:center">short型</td><td style="text-align:center">2 byte</td><td style="text-align:center">16 bit</td><td style="text-align:center">-2<sup>15</sup>~2<sup>15</sup>-1</td></tr><tr><td style="text-align:center">long型</td><td style="text-align:center">8 byte</td><td style="text-align:center">64 bit</td><td style="text-align:center">-2<sup>63</sup>~2<sup>63</sup>-1</td></tr></tbody></table><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p>这里的char是相对Unicode来说的，所以 申请时系统分配给两个字节，占16位，最高位不是符号位，没有负数的char。char类型的取值范围是0~65535。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  情况 1</span></span><br><span class="line"><span class="keyword">char</span> x = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> x = <span class="number">97</span>;   <span class="comment">//两者是等价的，因为97就是a字符在Unicode表当中的位置</span></span><br><span class="line"><span class="comment">//  情况 2 </span></span><br><span class="line"><span class="keyword">char</span> ch1 = <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">char</span> ch2 = <span class="string">'\"'</span>;</span><br><span class="line"><span class="keyword">char</span> ch3 = <span class="string">'\\'</span>;  <span class="comment">//有些字符只能通过转义字符进行输入</span></span><br></pre></td></tr></table></figure></p><p><em>说明</em> : 要观察一个字符在Unicode表中的顺序位置，可以使用int型显式转换，如<code>(int)&#39;a&#39;</code>或<code>int p = &#39;a&#39;</code>。如果要得到一个0~65536的数所代表的Unicode表中相应位置上的字符，需使用char显式转换，示例如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = <span class="string">'w'</span>,ch2 = <span class="string">'好'</span>;</span><br><span class="line"><span class="keyword">int</span> p1 = <span class="number">32831</span>,p2 = <span class="number">30452</span>;</span><br><span class="line">System.out.printIn(<span class="string">"\""</span>+ch1+<span class="string">"\"的位置:"</span>+(<span class="keyword">int</span>)ch1);</span><br><span class="line">System.out.printIn(<span class="string">"\""</span>+ch2+<span class="string">"\"的位置:"</span>+(<span class="keyword">int</span>)ch2);</span><br><span class="line">System.out.printIn(<span class="string">"第"</span>+p1+<span class="string">"个位置上的字符是:"</span>+(<span class="keyword">char</span>)p1);</span><br><span class="line">System.out.printIn(<span class="string">"第"</span>+p2+<span class="string">"个位置上的字符是:"</span>+(<span class="keyword">char</span>)p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有兴趣的同学可以在自己的编译器下跑跑试试。</p><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><h5 id="float型"><a href="#float型" class="headerlink" title="float型"></a>float型</h5><p>(1) float定义常量时，常量后面必须要有后缀f或F。<br>(2) float变量在存储float类型数据时保留8位有效数字，实际精度取决于具体数值。  </p><h5 id="double型"><a href="#double型" class="headerlink" title="double型"></a>double型</h5><p>保留16位有效数字，实际精度取决于具体数值。其与float的比较如下:  </p><table><thead><tr><th style="text-align:center">浮点类型</th><th style="text-align:center">所占字节数</th><th style="text-align:center">所占位数</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">float型</td><td style="text-align:center">4</td><td style="text-align:center">32</td><td style="text-align:center">10<sup>-38</sup>~10<sup>38</sup>和-10<sup>38</sup>~10<sup>-38</sup></td></tr><tr><td style="text-align:center">double型</td><td style="text-align:center">8</td><td style="text-align:center">64</td><td style="text-align:center">将上面38换成308</td></tr></tbody></table><h4 id="基本数据类型的转换"><a href="#基本数据类型的转换" class="headerlink" title="基本数据类型的转换"></a>基本数据类型的转换</h4><ul><li>将上述类型按照精度从低到高排序为 byte,short,char,int,long,float,double</li><li>当把级别低的变量的值=&gt;级别高的变量时，系统会自动完成数据类型的转换。</li><li>当把级别高的变量的值=&gt;级别低的变量时，需要用到强制转换,即显式类型转换运算，格式为: <em>(类型名)要转换的值</em>。</li><li>强制转换会造成“精度损失”或“数据溢出”。例如:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> i = <span class="number">10.1</span>;</span><br><span class="line"><span class="keyword">double</span> l = i;  <span class="comment">//自动转换</span></span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;   <span class="comment">//强制转换,精度损失 b = 10</span></span><br><span class="line"><span class="keyword">byte</span> c = (<span class="keyword">byte</span>)<span class="number">128</span>; <span class="comment">//数据溢出，c = -128</span></span><br></pre></td></tr></table></figure></li></ul><p><em>常见错误: 把一个double型常量赋值给float常量时未进行强制转换.</em><br>错误示范: <code>float x = 12.4</code><br>正确做法: <code>float x = (float)12.4</code> 或者 <code>float x = 12.4f</code></p><p><strong>下面用一段代码总结一下上面所讲的内容:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> c = <span class="number">128</span>;</span><br><span class="line">      <span class="keyword">long</span> d = <span class="number">77777</span>;</span><br><span class="line">      <span class="keyword">float</span> f = <span class="number">2e3f</span>;</span><br><span class="line">      <span class="keyword">double</span> g = <span class="number">3.14e-300</span>;    <span class="comment">//指数表示法</span></span><br><span class="line">      <span class="keyword">double</span> result = f*g;</span><br><span class="line">      System.out.println(<span class="string">"f= "</span>+f);</span><br><span class="line">      System.out.println(<span class="string">"g= "</span>+g);</span><br><span class="line">      System.out.println(<span class="string">"result= "</span>+result);</span><br><span class="line">      g = <span class="number">1234.12345678</span>;</span><br><span class="line">      c = (<span class="keyword">int</span>)d;</span><br><span class="line">      f = (<span class="keyword">float</span>)g;</span><br><span class="line">      System.out.println(<span class="string">"c= "</span>+c);</span><br><span class="line">      System.out.println(<span class="string">"d= "</span>+d);</span><br><span class="line">      System.out.println(<span class="string">"f= "</span>+f);</span><br><span class="line">      System.out.println(<span class="string">"g= "</span>+g);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x1aolin@x1aolin-E402NA:~/桌面$ java Example</span><br><span class="line">f= <span class="number">2000.0</span></span><br><span class="line">g= <span class="number">3.14E-300</span></span><br><span class="line">result= <span class="number">6.28E-297</span></span><br><span class="line">c= <span class="number">77777</span></span><br><span class="line">d= <span class="number">77777</span></span><br><span class="line">f= <span class="number">1234.1234</span></span><br><span class="line">g= <span class="number">1234.12345678</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java程序开发步骤</title>
      <link href="/Java%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4.html"/>
      <url>/Java%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4.html</url>
      <content type="html"><![CDATA[<blockquote><p>从今天开始，我们进入到Java的基础课学习，这个教程的前提时有一点编程基础，比如C/C++，请大家做好心理准备。</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=412175360&auto=1&height=66"></iframe><h3 id="编写源文件"><a href="#编写源文件" class="headerlink" title="编写源文件"></a>编写源文件</h3><p>可以使用IDE，现今存在的IDE也有很多，大家可以根据自己的喜好去选择不同的IDE。<br>但是本文主要时说明开发步骤，所以本文使用Liunx系统的vim进行编辑。Windows系统的小伙伴也可以使用记事本等文本文件进行源文件的编写。<br><em>注意 : 在对文件进行命名的时候，源文件的拓展名必须为.java</em>。  </p><h3 id="编译源文件"><a href="#编译源文件" class="headerlink" title="编译源文件"></a>编译源文件</h3><p>定义： 使用Java编译器(javac.exe)编译源文件，得到字节码文件。<br>格式： javac 文件名.java</p><a id="more"></a><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>使用Java平台中的Java解释器(java.exe)来解释、执行字节码文件。<br>格式： java 文件名  //注意不要有添加后缀  </p><h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><ul><li>在Java源程序中，语句所涉及的小括号以及标点符号都是在英文状态下输入的，而字符串里面的符号不受限制。</li><li>如果源程序中有多个类，那么只能有一个public类; 如果有一个类是public类，那么源文件的名字必须与这个类的名字完全相同，拓展名为.java; 如果源文件没有public类，那么源文件的名字只要和某个类的名字相同，并且拓展名时.java就可以了。</li><li>如果源文件中包含多个类，编译源文件将生成多个拓展名为.class的文件，在每个拓展名为.class的文件中只存放一个类的字节码，其文件名与该类的名字相同，这些字节码文件被存放在与源文件相同的目录中。</li><li>！！！一个Java应用程序必须有一个类含有 <code>public static void main(String args[])</code>方法，称这个类为应用程序的主类。</li><li>运行Java程序的时候注意：Java应用程序总是从主类的main方法开始执行，因此，需要进入主类字节码所在的目录(主类名.class)。</li><li><strong>一个Java应用程序(也称为一个工程)是由若干个类组成的，这些类可以在一个源文件中，也可以分布在若干个源文件中。</strong></li><li>如果应用程序的主类源文件和其他源文件在同一目录中，也可以只编译主类的源文件，Java系统会自动编译主类需要的其他源文件。</li><li>Java程序以类为“基本单位”，即一个java源程序是由若干个类所构成的。 一个Java程序可以将它使用的各个类分别存放在不同的源文件当中，也可以将它使用的类存放在一个源文件当中。</li><li>如果需要编译某个目录下的多个Java文件，在使用javac时，也可以将javac要编译的多个源文件用空格分离。例如:<code>javac Car.java Person.java</code>。</li></ul>]]></content>
      
      <categories>
          
          <category> Java入门教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cpp之const的用法</title>
      <link href="/Cpp%E4%B9%8Bconst%E7%9A%84%E7%94%A8%E6%B3%95.html"/>
      <url>/Cpp%E4%B9%8Bconst%E7%9A%84%E7%94%A8%E6%B3%95.html</url>
      <content type="html"><![CDATA[<blockquote><p>关于const的有关知识今天先讲这些，等日后再进行补充……<br>Tips:<em>最后有视频推荐链接</em>，不喜欢读文章可以看看视频。</p></blockquote><h3 id="控制变化的const"><a href="#控制变化的const" class="headerlink" title="控制变化的const"></a>控制变化的const</h3><hr><h4 id="1-const与基本的数据类型"><a href="#1-const与基本的数据类型" class="headerlink" title="1.const与基本的数据类型"></a>1.const与基本的数据类型</h4><p>如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span> <span class="comment">//常量</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">储存地址</th><th style="text-align:center">存储内容</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">&amp;x</td><td style="text-align:center"><code>3</code>  固定不变</td></tr></tbody></table><a id="more"></a><h4 id="2-const与指针类型"><a href="#2-const与指针类型" class="headerlink" title="2.const与指针类型"></a>2.const与指针类型</h4><p>五种定义形式:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">NULL</span>;    <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p = <span class="literal">NULL</span>;    <span class="comment">//2  1和2完全等价</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = <span class="literal">NULL</span>;    <span class="comment">//3  另外一种情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = <span class="literal">NULL</span>;  <span class="comment">//4 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p = <span class="literal">NULL</span>;  <span class="comment">//5  4和5完全等价</span></span><br></pre></td></tr></table></figure></p><p>下面我们通过例子来说明问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;x;    <span class="comment">/*</span></span><br><span class="line"><span class="comment">p = &amp;y; 正确,即允许让指针p再指向另外的一个地址。</span></span><br><span class="line"><span class="comment">*p = 4; 错误，因为我们的const此时修饰的是*p    */</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">存储地址</th><th style="text-align:center">存储内容</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">&amp;x</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">&amp;p</td><td style="text-align:center">&amp;x</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;x;    <span class="comment">//p = &amp;y; 错误，因为我们的const此时修饰的是指针p</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">存储地址</th><th style="text-align:center">存储内容</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">&amp;x</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">&amp;p</td><td style="text-align:center"><code>&amp;x</code>  固定不变</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;x;    <span class="comment">//p = &amp;y; *p = 4;都是错误的</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">存储地址</th><th style="text-align:center">存储内容</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">&amp;x</td><td style="text-align:center"><code>3</code>   固定不变</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">&amp;p</td><td style="text-align:center"><code>&amp;x</code>  固定不变</td></tr></tbody></table><h4 id="3-const与引用"><a href="#3-const与引用" class="headerlink" title="3.const与引用"></a>3.const与引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;y = x;    <span class="comment">//x = 10;True //y = 20;False,因为y被const修饰。</span></span><br><span class="line"><span class="comment">//y是x的别名，他们的值始终相同。所以修改x的值后y的值也被其改变。</span></span><br></pre></td></tr></table></figure><h4 id="4-总结一下"><a href="#4-总结一下" class="headerlink" title="4.总结一下"></a>4.总结一下</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span>;  x = <span class="number">5</span>; <span class="comment">//False 常量不可以被赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;  <span class="keyword">const</span> <span class="keyword">int</span> y = x; y = <span class="number">5</span>; <span class="comment">//False y为常量，不可被赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;  <span class="keyword">const</span> <span class="keyword">int</span> *y = &amp;x; *y = <span class="number">5</span>; <span class="comment">//False const修饰的是*y.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>, z = <span class="number">4</span>; <span class="keyword">int</span> *<span class="keyword">const</span> y = &amp;x; y = &amp;z; <span class="comment">//False const修饰的是指针y.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span>; <span class="keyword">const</span> <span class="keyword">int</span> &amp;y = x; y = <span class="number">5</span>; <span class="comment">//False 前面有提到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//!!! 下面看一个对比的例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span>; <span class="keyword">int</span> *y = &amp;x;  <span class="comment">//False x比y的权限小，x有被其指针改变的风险</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>; <span class="keyword">int</span> <span class="keyword">const</span> *y = &amp;x;  <span class="comment">//True x比y的权限大，可以通过</span></span><br><span class="line"></span><br><span class="line">!!! 指针指向<span class="keyword">const</span>修饰的变量时，应该是 <span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;x;<span class="comment">//限制其权限</span></span><br></pre></td></tr></table></figure><blockquote><p>推荐大家用const来定义常量，因为相比于宏定义#define来说，使用const编译器会检查语法错误。  </p></blockquote><h3 id="定义拷贝-构造函数"><a href="#定义拷贝-构造函数" class="headerlink" title="定义拷贝 构造函数"></a>定义拷贝 构造函数</h3><hr><p>拷贝构造函数定义格式: 类名(const 类名&amp; 变量名)，例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Student()&#123;m_strName = <span class="string">"x1aolin"</span>;&#125;</span><br><span class="line">   Student(<span class="keyword">const</span> Student&amp; stu)&#123;&#125;    <span class="comment">//!!!拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="built_in">string</span> m_strName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//拷贝构造函数在实例化对象复制初始化或直接初始化时调用</span></span><br></pre></td></tr></table></figure></p><h3 id="const重出江湖"><a href="#const重出江湖" class="headerlink" title="const重出江湖"></a>const重出江湖</h3><hr><p>先从一个大家比较熟悉的例子说起:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Coordinate(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_ix;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_iy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为成员变量是两个常成员，所以不能用一般的构造函数进行初始化，需要用初始化列表。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Coordinate::Coordinate(<span class="keyword">int</span> x,<span class="keyword">int</span> y):m_ix(x),m_iy(y)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这里可以看到，一般的对象成员是可以用const来修饰的，其实，对象成员也可以<br>用const来修饰，我们把这类成员称为常对象成员。</p><h4 id="1-常对象成员"><a href="#1-常对象成员" class="headerlink" title="1.常对象成员"></a>1.常对象成员</h4><p>如果想要在类中实现对象成员一旦初始化就不允许再修改，那么就可以用const常对象成员,例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Line(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">const</span> Coordinate m_coorA;</span><br><span class="line">   <span class="keyword">const</span> Coordinate m_coorB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化用实例化时传参+初始化列表进行操作。</p><h4 id="2-常成员函数"><a href="#2-常成员函数" class="headerlink" title="2.常成员函数"></a>2.常成员函数</h4><p>如果大家更加大胆些，就可能会想到一个问题:既然有了常对象成员，那么是否会有常成员函数？答案自然是肯定的，例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Coordinate(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">changeX</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// &lt;--- 常成员函数 1</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">changeX</span><span class="params">()</span></span>;    <span class="comment">// 2 1和2互为重载</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> m_ix;</span><br><span class="line">   <span class="keyword">int</span> m_iy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><em>常对象就只能调用常成员函数，而非常对象就都可以调用。但是类似重载的情况就只能实例化一个常对象来进行调用常成员函数了</em>。</p></blockquote><p>在重载情况下调用常对象成员示例:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Coordinate <span class="title">coor</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">// &lt;--- 常对象的定义方法</span></span><br><span class="line">coor.changeX();    <span class="comment">//此时调用的changeX()函数就是常成员函数了</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><em>!!! 常成员函数中不可以修改数据成员的值</em>。</p></blockquote><p>在上一次的<a href="http://x1aolin6.top/2018/05/17/Cpp-%E5%B0%81%E8%A3%85%E7%AF%87/" target="_blank" rel="noopener">博客:this的用法</a>中已经详细介绍了关于this应该如何运用，这里不在赘述。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Coordinate::changeX() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    m_ix = <span class="number">10</span>; <span class="comment">//False 这是不被允许的，原因下面有。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实上面的代码可以理解为:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeX</span><span class="params">(<span class="keyword">const</span> Coordinate *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_ix = <span class="number">10</span>; <span class="comment">//上面也提到常指针是不可以改变的，所以不被允许。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>定义常成员函数的方法</strong>:<br>在.h文件中，在普通成员函数声明后面加上 const ，然后在其对应的.cpp文件定义<br>中的对应定义函数后面加上 const 后面。注意在函数括号后面加一个小空格，防止编译错误。</p><blockquote><p><em>如果大家对常对象和常成员函数还是很模糊，点击<a href="http://www.jb51.net/article/84409.htm" target="_blank" rel="noopener">传送门</a>,深入理解</em>。</p></blockquote><h4 id="3-常指针与常引用"><a href="#3-常指针与常引用" class="headerlink" title="3.常指针与常引用"></a>3.常指针与常引用</h4><p>示例的前提条件:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Coordinate(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//注意这个是常成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> m_iX;</span><br><span class="line">   <span class="keyword">int</span> m_iY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>下面我们来看看对象的引用和对象的指针如何来定义:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Coordinate <span class="title">coor1</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">   Coordinate &amp;coor2 = coor1;  <span class="comment">//&lt;---对象的引用</span></span><br><span class="line">   Coordinate *pCoor = &amp;coor1; <span class="comment">//&lt;---对象的指针</span></span><br><span class="line">   coor1.printInfo();</span><br><span class="line">   coor2.printInfo();</span><br><span class="line">   pCoor-&gt;printInfo();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仿照上述代码即可实现对象的引用和指针，需要注意的是，使用对象的引用时，可将对象直接赋值给其”别名” ；使用对象的指针时，需要将对象取地址(即加取地址符号&amp;)进行赋值。<br>正如大家所想，如果我们在定义它们的指针和引用时，在其前面加上<code>const</code>就是常对象和常指针了,示例如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">Coordinate <span class="title">coor</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> Coordinate &amp;coor2 = coor1;  <span class="comment">//&lt;---对象的常引用</span></span><br><span class="line">    <span class="keyword">const</span> Coordinate *pCoor = &amp;coor1; <span class="comment">//&lt;---对象的常指针</span></span><br><span class="line">    coor1.printInfo();</span><br><span class="line">    coor2.printInfo();</span><br><span class="line">    pCoor-&gt;printInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><em>!!! 常引用和常指针只有读权限，没有写权限，只能调用它的常成员函数</em>。</p></blockquote><p>下面看一个更加复杂的例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Coordinate <span class="title">coor1</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Coordinate <span class="title">coor2</span><span class="params">(<span class="number">7</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">Coordinate * <span class="keyword">const</span> pCoor = &amp;coor1;</span><br><span class="line">pCoor-&gt;getY();       <span class="comment">//1  需要读写权限对象调用</span></span><br><span class="line">pCoor = coor2;       <span class="comment">//2</span></span><br><span class="line">pCoor-&gt;printInfo();  <span class="comment">//3  仅需要读权限的对象就可以调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们分析一下上面这几行代码,有哪个是错误的。首先看第三行定义代码，<em>所在的位置是在<code>const</code>后面，所以意味着这个pCoor指针不能再指向其他的对象，<br>但是它的权限时同时具备读和写的。所以<code>1</code>是对的,<code>2</code>是错的,<code>3</code>也是对的。  </em>const最重要的是可以使读写权限转变成只读权限*。</p><p><em>推荐视频</em>:  </p><ul><li>第一部分视频连接: <a href="https://www.imooc.com/video/7423" target="_blank" rel="noopener">控制变化的const</a></li><li>第三部分视频链接: <a href="https://www.imooc.com/video/8143" target="_blank" rel="noopener">常对象成员和常成员函数</a>,<a href="https://www.imooc.com/video/8161" target="_blank" rel="noopener">常指针与常引用</a><blockquote><p>tips:可能需要登录才可以看视频。</p></blockquote></li></ul>]]></content>
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小白如何在ubuntu上进行C++开发</title>
      <link href="/%E5%B0%8F%E7%99%BD%E5%A6%82%E4%BD%95%E5%9C%A8ubuntu%E4%B8%8A%E8%BF%9B%E8%A1%8CC-%E5%BC%80%E5%8F%91.html"/>
      <url>/%E5%B0%8F%E7%99%BD%E5%A6%82%E4%BD%95%E5%9C%A8ubuntu%E4%B8%8A%E8%BF%9B%E8%A1%8CC-%E5%BC%80%E5%8F%91.html</url>
      <content type="html"><![CDATA[<blockquote><p>对于初入ubuntu开发的小白来说，这的确是一个严峻的挑战。当然，在linux下的IDE也很多，但是既然想成为一个合格的开发者，最好是要理解开发的整个过程。本文也是在查阅了大量的资料后的一个小总结，仅供大家参考。</p></blockquote><h4 id="1-编写程序"><a href="#1-编写程序" class="headerlink" title="1.编写程序"></a>1.编写程序</h4><p>本文选用的是vim，当今比较主流的一个文本编辑器。</p><ul><li><a href="https://blog.csdn.net/doc_sgl/article/details/47205779" target="_blank" rel="noopener">把Vim打造成牛逼的C++ IDE</a></li><li><a href="https://blog.csdn.net/yinjiabin/article/details/8254609" target="_blank" rel="noopener">一步步将vim改造成C/C++开发环境(IDE)</a></li><li>其实都是大同小异啦。当然，如果你不想这么做，没人管你，不过对于那些刚刚从Windows转过来的童鞋还是很需要的。</li><li>如果你实在是想选取IDE的话，<a href="https://linux.cn/article-5078-weibo.html" target="_blank" rel="noopener">这里有很多的推荐</a>,<a href="https://linux.cn/article-5078-2.html" target="_blank" rel="noopener">推荐2</a>。</li></ul><a id="more"></a><h4 id="2-编译程序"><a href="#2-编译程序" class="headerlink" title="2.编译程序"></a>2.编译程序</h4><ul><li>说到这，就不得不提强大的gcc了，它的用法<a href="http://man.linuxde.net/gcc" target="_blank" rel="noopener">点这里</a>。</li><li>了解的多了，就会有人产生一些疑惑，比如<a href="https://www.cnblogs.com/zhouyinhui/archive/2010/02/01/1661078.html" target="_blank" rel="noopener">cc与gcc</a>或者<a href="http://www.cnblogs.com/xiedan/archive/2009/10/25/1589462.html" target="_blank" rel="noopener">gcc与g++</a>。</li><li>对于有个大型的C++工程来说，就不得不提<a href="https://blog.csdn.net/ruglcc/article/details/7814546/" target="_blank" rel="noopener">makefile</a>了，这个链接关于Makefile比较清晰。</li><li><p>支持原创请移步陈皓博客:<a href="https://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="noopener">https://blog.csdn.net/haoel/article/details/2886</a></p></li><li><p>当然我自己的博客也有写:<a href="http://x1aolin6.top/2018/05/17/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6%E5%86%99makefile/" target="_blank" rel="noopener">跟我一起学写makefile</a>。</p></li></ul><h4 id="3-运行程序"><a href="#3-运行程序" class="headerlink" title="3.运行程序"></a>3.运行程序</h4><ul><li>cd 到需要运行程序所在目录,运行命令 ./ xxx(文件名)即可。</li><li>自己编写成功的程序肯定是可以运行的，下载的程序可能会有权限问题。</li><li>权限问题解决请自己查阅资料解决。</li></ul>]]></content>
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>跟我一起学写makefile</title>
      <link href="/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6%E5%86%99makefile.html"/>
      <url>/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6%E5%86%99makefile.html</url>
      <content type="html"><![CDATA[<blockquote><p>未完待续……</p></blockquote><h5 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h5><p>作者在写本文时，着重参考了<a href="https://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="noopener">CSDN博客作者陈皓</a>的博客，在此表示十分感谢。</p><hr><p><em>对于大多数用Windows学编程的同学也许不知道makefile这个东西，因为Windows的IDE为你做了这个工作。最近打算转战Unix系统，所以在被逼无奈之下，了解了一下makefile，在此写出同大家一起分享</em>。</p><blockquote><p>Question：什么是makefile？</p></blockquote><p>makefile关系了整个工程的编译规则，在一个工程中，源文件不计其数，其按照类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定那个文件需要先编译，那个文件需要后编译，那些文件需要重新编译，甚至于更加复杂的功能操作，，这里的makefile就像是一个shell脚本一样，其中也可以执行操作的命令。</p><a id="more"></a><p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具。</p><h5 id="程序的编译和链接"><a href="#程序的编译和链接" class="headerlink" title="程序的编译和链接"></a>程序的编译和链接</h5><hr><p>一般来说，无论是C，C++，还是pas，首先要把源文件编译成中间代码文件，Windows下为.obj文件，Unix下是.o文件，即 Object File，这个动作叫做编译(compile)。<br>然后再把大量的Object File合成可执行文件，这个动作叫做链接（link）。  </p><p><strong>编译</strong>时，编译器需要的是语法的正确，函数与变量的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（这里的头文件只要声明），只要所有的语法正确，编译器就可以编译出中间文件。一般来说，每个源文件都应该对应于一个中间文件。</p><p><strong>链接</strong>时，主要是链接函数和全局变量。链接器并不管函数所在的源文件，只要函数的中间文件(Object File)，在大多数时候，由于源文件太多，对应编译生成的中间目标文件（.o）太多，而在连接时需要明显的指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”(Library File),即.lib文件，在UNIX下，是Archive File,也就是.a文件。</p><p><strong>总而言之</strong>,源文件首先会生成中间目标文件（.obj或.o），再由中间目标文件生成执行文件。编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），你需要指定函数的Object File。</p>]]></content>
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cpp之This指针</title>
      <link href="/Cpp%E4%B9%8BThis%E6%8C%87%E9%92%88.html"/>
      <url>/Cpp%E4%B9%8BThis%E6%8C%87%E9%92%88.html</url>
      <content type="html"><![CDATA[<h4 id="1-this指针-指向自身数据的指针"><a href="#1-this指针-指向自身数据的指针" class="headerlink" title="1.this指针: 指向自身数据的指针"></a>1.this指针: <em>指向自身数据的指针</em></h4><p>举例如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>          //代码1</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Array(<span class="keyword">int</span> _len)&#123;len = _len;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> len;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setlen</span><span class="params">(<span class="keyword">int</span> _len)</span></span>&#123;len = _len;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里数据成员和参数在表达相同意思时用的是不同的变量，<em>所以如果想用相同的变量就需要一个标记来区分该变量时数据成员还是参数</em>,即<strong>this指针</strong>。  </p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>          //代码2</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len)&#123;<span class="keyword">this</span>-&gt;len = len;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> len;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setlen</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;<span class="keyword">this</span>-&gt;len = len;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，用this指针指明了数据成员，就可以用相同的变量来进行表示了。</p><blockquote><p>Question：为什么成员函数可以直接访问数据成员？  </p></blockquote><p><strong>知识准备</strong>: 对象结构<br>在进行对多个对象实例化的时候，在内存中会定义对应多个数据成员，但是成员函数只有一份，储存在代码区。而且每个对象进行调用的时候，每个对象都能够准确无误的进行调用。大家有没有想过这是为什么呢？<br><em>其实这就是this指针的功劳。</em> 我们来看下面这个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>          //代码3</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(T *<span class="keyword">this</span>,<span class="keyword">int</span> _len)&#123;<span class="keyword">this</span>-&gt;len = _len;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">(T *<span class="keyword">this</span>)</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;len;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setlen</span><span class="params">(T *<span class="keyword">this</span>,<span class="keyword">int</span> _len)</span></span>&#123;<span class="keyword">this</span>-&gt;len = _len;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>大家是不是发现了和第一个例子的区别？显而易见，就是每个成员函数都加了一个this指针，这样上面所提到的问题就迎刃而解了。<br>我们设想一下，当我们去实例化一个对象并使用他们的成员函数时，<strong>this指针就代表这个对象本身的地址</strong>，也就是说当我们调用成员函数时,编译器会悄悄地把代码1转换成代码3，所以每次调用成员函数，都是改变对应对象的成员变量。  </p><p>上面说了，<em>编译器自动的为每个成员函数的参数列表都加了一个this指针</em>, Thus，我们只需要理解就可，没有必要自己显式的写出来。</p><hr><p><em>推荐视频</em>：<a href="https://www.imooc.com/video/8162" target="_blank" rel="noopener">如何理解this指针?</a></p><blockquote><p>Tips: 看视频需要注册账号，只有注册登录才可以看视频。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown简单用法</title>
      <link href="/markdown%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95.html"/>
      <url>/markdown%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95.html</url>
      <content type="html"><![CDATA[<blockquote><p>本文是作者第一篇hexo博客，排版等问题不足之处请见谅。</p></blockquote><h3 id="1-Markdown官方文档及其他参考"><a href="#1-Markdown官方文档及其他参考" class="headerlink" title="1.Markdown官方文档及其他参考"></a>1.Markdown官方文档及其他参考</h3><ul><li>特别感谢简书<a href="https://www.jianshu.com/p/0130ad32a08d" target="_blank" rel="noopener">刘邓诏初</a>的blog对本文的帮助</li><li><a href="https://www.cnblogs.com/yuxiuyan/p/6044682.html" target="_blank" rel="noopener">Markdown语法入门</a></li><li><a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">官方文档详细版</a>  </li></ul><h3 id="2-常用语法规则"><a href="#2-常用语法规则" class="headerlink" title="2.常用语法规则"></a>2.常用语法规则</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>共六级标题，用#的累计来进行区分，#号越少字号越大<br>下面给出相应代码，如图所示：</p><a id="more"></a><p><img src="/1.png" alt="lll"><br><img src="/9.png" alt="ll"></p><h4 id="换行和分段"><a href="#换行和分段" class="headerlink" title="换行和分段"></a>换行和分段</h4><ul><li>换行：只需要在行末加两个空格键和一个回车  </li><li>分段：段落之间空一行即可<br><img src="/2.png" alt="换行和分段">  </li></ul><h4 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h4><ul><li>加粗: <strong>加粗</strong></li><li>斜体: <em>斜体</em></li><li>删除线: <del>删除线</del></li><li>底纹: <code>底纹</code><br><img src="/3.png" alt="style">  </li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>只要将文本内容之前加[ &gt;(大于号) ]即可将文本变成引用文本。</p><blockquote><p>我是引用文本  </p></blockquote><p><img src="/4.png" alt="引用">  </p><h4 id="图片和链接"><a href="#图片和链接" class="headerlink" title="图片和链接"></a>图片和链接</h4><ul><li><strong>图片格式</strong>: ! [图片描述] (链接的地址)  </li><li><strong>链接</strong>:  [文本内容] (链接的地址)  </li><li>如果是本地的图片可以参考: <a href="https://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="noopener">hexo生成blog本地图片插入方法</a>  <blockquote><p><em>实际用时在 感叹号，中括号和小括号 之间不能有空格，这里只是为了展示效果</em></p></blockquote></li></ul><h4 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h4><p>三个[ - ]或者[ * ]都可以画出一条水平分割线 </p><hr><hr><p>实现方式: <img src="/5.png" alt="水平线">  </p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>在markdown制作表格非常麻烦，必须要画出来！！！  </p><p><img src="/6.png" alt="表格">  </p><h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><p>脚注成对出现，[^1]作为标记，可以点击调至末尾注解。[^1]填写注解，不论写在什么位置<br>，都会出现在文章的末尾。  </p><p><img src="/7.png" alt="脚注">  </p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注释是给自己看的，预览和发布时都不会出现。  </p><!-- hhh  -->  <p><img src="/8.png" alt="注释">  </p><blockquote><p>end: 暂时先总结这些，实现了最基础的一些功能,能满足大家的一定需要，对markdown有兴趣却还没有基础的小白可以看看，大神请绕道，等日后再慢慢更新…  </p></blockquote><hr><p>5月16日补充：  </p><h4 id="代码框的三种形式"><a href="#代码框的三种形式" class="headerlink" title="代码框的三种形式"></a>代码框的三种形式</h4><ul><li>两对’’’包裹  </li><li>代码前面加两个<strong>空格键</strong></li><li>代码前面加一个<strong>TAB键</strong><br><img src="/10.png" alt="代码框">  </li></ul><blockquote><p>让hexo代码高亮格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;```语言名 （比如cpp）  </span><br><span class="line">&gt;    #include &lt; iostream&gt;</span><br><span class="line">&gt;    using namespace std;</span><br><span class="line">&gt;    ...</span><br><span class="line">&gt;``` //第一行说明语言，下面是代码内容</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>点击这里可以查看<a href="http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html" target="_blank" rel="noopener">代码高亮支持格式和化名</a></p><hr><p>特别感谢：<a href="https://www.jianshu.com/p/0130ad32a08d" target="_blank" rel="noopener">https://www.jianshu.com/p/0130ad32a08d</a></p>]]></content>
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim+插件实现markdown功能</title>
      <link href="/vim-%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0markdown%E5%8A%9F%E8%83%BD.html"/>
      <url>/vim-%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0markdown%E5%8A%9F%E8%83%BD.html</url>
      <content type="html"><![CDATA[<h5 id="具体请参考：https-www-jianshu-com-p-44d31327f953"><a href="#具体请参考：https-www-jianshu-com-p-44d31327f953" class="headerlink" title="具体请参考：https://www.jianshu.com/p/44d31327f953"></a>具体请参考：<a href="https://www.jianshu.com/p/44d31327f953" target="_blank" rel="noopener">https://www.jianshu.com/p/44d31327f953</a></h5><p>里面实现了从小白到搭建好markdown的所有过程。</p>]]></content>
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> 示例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello World </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
