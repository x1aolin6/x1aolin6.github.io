<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基本类型、数组和枚举类型(一)]]></title>
    <url>%2F2018%2F05%2F23%2FJava%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[说明: 关于编译环境，安装相应的IDE等相关知识本文不会介绍，请自行百度 标识符和关键字标识符定义 : 用来标识类名、变量名、方法名、类型名、数组名、文件名的有效字符序列。 语法规则 :(1) 由字母、下划线、美元符号$、数字构成，长度无限制。(2) 第一个字符不可以是数字字符。(3) 不可以是关键字(关键字会在后续说明)。(4) 不可以是true、false、null这三个字符。(5) Java为强类型语言，所以严格区分大小写。(6) 使用比ASCII码更广泛的Unicode字符集，所以在(1)中所说的“字母”包含部分简体中文。 关键字说明 : 关键字就是Java中被赋予特定意义的单词。下面给出部分示例:123abstract; assert; boolean; break; byte; case; catch; char; class; const; continue default; do; double; else; enum; extends; final; ... //分号表示间隔 分隔符1.注释符 :(1)// 单行注释(以双斜杠开始，终止于行尾，注释一行，可放在语句后面)(2)/* */ 多行注释( /*开始，*/结束，中间可写多行)(3)/**开始，*/结束，这种注释主要是为了支持JDK工具javadoc而采用的。 2.空白符 :空格，回车，换行，制表符tab等。 为增强代码的可读性而建立，系统编译时会忽略它。 3.普通分隔符 :点号，分号，冒号，大括号，方括号，小括号。因为和C/C++用法相同，此处不再赘述。 基本数据类型Java语言有八中基本数据类型，习惯上可以分为四大类: 逻辑类型: boolean 整数类型: byte 、short 、int 、long 字符类型: char 浮点类型: float 、double 逻辑类型常量: true 、false变量: 使用关键字boolean来声明。 整数类型 十进制用数字1~9开头，八进制用数字0开头，十六机制用0x开头。因为基本上和C语言差不多，稍微有点编程基础就可以理解，此处就不再赘述。重点讲一下和C语言不同的地方:(1)Java中不存在byte和short的常量表示法，但是可以把一定范围内的int型常量赋值给byte或short型变量。(2)long型常量用后缀L来表示，如108L。(3)这四个不同的类型区别：只是声明时系统分配予其内存的大小和其所能表示数的范围大小。 整数类型 所占字节数 所占位数 取值范围 int型 4 byte 32 bit -231~2^31-1 byte型 1 byte 8 bit -27~27-1 short型 2 byte 16 bit -215~215-1 long型 8 byte 64 bit -263~263-1 字符类型这里的char是相对Unicode来说的，所以 申请时系统分配给两个字节，占16位，最高位不是符号位，没有负数的char。char类型的取值范围是0~65535。1234567// 情况 1char x = 'a';char x = 97; //两者是等价的，因为97就是a字符在Unicode表当中的位置// 情况 2 char ch1 = '\n';char ch2 = '\"';char ch3 = '\\'; //有些字符只能通过转义字符进行输入 说明 : 要观察一个字符在Unicode表中的顺序位置，可以使用int型显式转换，如(int)&#39;a&#39;或int p = &#39;a&#39;。如果要得到一个0~65536的数所代表的Unicode表中相应位置上的字符，需使用char显式转换，示例如下:12345678910public class Test&#123; public static void main(String args[])&#123; char ch1 = 'w',ch2 = '好'; int p1 = 32831,p2 = 30452; System.out.printIn("\""+ch1+"\"的位置:"+(int)ch1); System.out.printIn("\""+ch2+"\"的位置:"+(int)ch2); System.out.printIn("第"+p1+"个位置上的字符是:"+(char)p1); System.out.printIn("第"+p2+"个位置上的字符是:"+(char)p2); &#125;&#125; 有兴趣的同学可以在自己的编译器下跑跑试试。 浮点类型float型(1) float定义常量时，常量后面必须要有后缀f或F。(2) float变量在存储float类型数据时保留8为有效数字，实际精度取决于具体数值。 double型保留16位有效数字，实际精度取决于具体数值。其与float的比较如下:浮点类型|所占字节数|所占位数|取值范围:—:|:—:|:—:|:—–:float型|4|32|10-38~1038和-1038~10-38double型|8|64|将上面38换成308 基本数据类型的转换 将上述类型按照精度从低到高排序为 byte,short,char,int,long,float,double 当把级别低的变量的值=&gt;级别高的变量时，系统会自动完成数据类型的转换。 当把级别高的变量的值=&gt;级别低的变量时，需要用到强制转换,即显式类型转换运算，格式为: (类型名)要转换的值。 强制转换会造成“精度损失”或“数据溢出”。例如:1234float i = 10.1;double l = i; //自动转换byte b = (byte)i; //强制转换,精度损失 b = 10byte c = (byte)128; //数据溢出，c = -128 常见错误: 把一个double型常量赋值给float常量时未进行强制转换.错误示范: float x = 12.4正确做法: float x = (float)12.4 或者 float x = 12.4f]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序开发步骤]]></title>
    <url>%2F2018%2F05%2F21%2FJava%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[本文第四项注意事项比较多，有点枯燥，但是还是请小白们耐心看完，会收获很多。 编写源文件可以使用IDE，现今存在的IDE也有很多，大家可以根据自己的喜好去选择不同的IDE。但是本文主要时说明开发步骤，所以本文使用Liunx系统的vim进行编辑。Windows系统的小伙伴也可以使用记事本等文本文件进行源文件的编写。注意 : 在对文件进行命名的时候，源文件的拓展名必须为.java。 编译源文件定义： 使用Java编译器(javac.exe)编译源文件，得到字节码文件。格式： javac 文件名.java 运行程序使用Java平台中的Java解释器(java.exe)来解释、执行字节码文件。格式： java 文件名 //注意不要有添加后缀 一些注意事项 在Java源程序中，语句所涉及的小括号以及标点符号都是在英文状态下输入的，而字符串里面的符号不受限制。 如果源程序中有多个类，那么只能有一个public类; 如果与一个类时public类，那么源文件的名字必须与这个类的名字完全相同，拓展名为.java; 如果源文件没有public类，那么源文件的名字只要和某个类的名字相同，并且拓展名时.java就可以了。 如果源文件中包含多个类，编译源文件将生成多个拓展名为.class的文件，在每个拓展名为.class的文件中只存放一个类的字节码，其文件名与该类的名字相同，这些字节码文件被存放在与源文件相同的目录中。 ！！！一个Java应用程序必须有一个类含有 public static void main(String args[])方法，称这个类为用用程序的主类。 运行Java程序的时候注意：Java应用程序总是从主类的main方法开始执行，因此，需要进入主类字节码所在的目录(主类名.class)。 一个Java应用程序(也称为一个工程)是由若干个类组成的，这些类可以在一个源文件中，也可以分布在若干个源文件中。 如果应用程序的主类源文件和其他源文件在同一目录中，也可以只编译主类的源文件，Java系统会自动编译主类需要的其他源文件。 Java程序以类为“基本单位”，即一个java源程序是由若干个类所构成的。 一个Java程序可以将它使用的各个类分别存放在不同的源文件当中，也可以将它使用的类存放在一个源文件当中。 如果需要编译某个目录下的多个Java文件，在使用javac时，也可以将javac要编译的多个源文件用空格分离。例如:javac Car.java Person.java。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cpp之const的用法]]></title>
    <url>%2F2018%2F05%2F19%2FCpp%E4%B9%8Bconst%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[关于const的有关知识今天先讲这些，等日后再进行补充……Tips:最后有视频推荐链接，不喜欢读文章可以看看视频。 控制变化的const 1.const与基本的数据类型如:1const int x = 3 //常量 变量名 储存地址 存储内容 x &amp;x 3 固定不变 2.const与指针类型五种定义形式:123456789const int *p = NULL; //1int const *p = NULL; //2 1和2完全等价int *const p = NULL; //3 另外一种情况const int * const p = NULL; //4 int const * const p = NULL; //5 4和5完全等价 下面我们通过例子来说明问题：1234int x = 3;const int *p = &amp;x; /*p = &amp;y; 正确,即允许让指针p再指向另外的一个地址。*p = 4; 错误，因为我们的const此时修饰的是*p */ 变量名 存储地址 存储内容 x &amp;x 3 p &amp;p &amp;x 12int x = 3;int *const p = &amp;x; //p = &amp;y; 错误，因为我们的const此时修饰的是指针p 变量名 存储地址 存储内容 x &amp;x 3 p &amp;p &amp;x 固定不变 12const int x = 3;const int *const p = &amp;x; //p = &amp;y; *p = 4;都是错误的 变量名 存储地址 存储内容 x &amp;x 3 固定不变 p &amp;p &amp;x 固定不变 3.const与引用123int x = 3;const int &amp;y = x; //x = 10;True //y = 20;False,因为y被const修饰。//y是x的别名，他们的值始终相同。所以修改x的值后y的值也被其改变。 4.总结一下1234567891011121314151617const int x = 3; x = 5; //False 常量不可以被赋值int x = 3; const int y = x; y = 5; //False y为常量，不可被赋值int x = 3; const int *y = &amp;x; *y = 5; //False const修饰的是*y.int x = 3, z = 4; int *const y = &amp;x; y = &amp;z; //False const修饰的是指针y.const int x = 3; const int &amp;y = x; y = 5; //False 前面有提到//!!! 下面看一个对比的例子const int x = 3; int *y = &amp;x; //False x比y的权限小，x有被其指针改变的风险int x = 3; int const *y = &amp;x; //True x比y的权限大，可以通过!!! 指针指向const修饰的变量时，应该是 const int *const p = &amp;x;//限制其权限 推荐大家用const来定义常量，因为相比于宏定义#define来说，使用const编译器会检查语法错误。 定义拷贝 构造函数 拷贝构造函数定义格式: 类名(const 类名&amp; 变量名)，例如:123456789class Student&#123;public: Student()&#123;m_strName = "x1aolin";&#125; Student(const Student&amp; stu)&#123;&#125; //!!!拷贝构造函数private: string m_strName;&#125;;//拷贝构造函数在实例化对象复制初始化或直接初始化时调用 const重出江湖 先从一个大家比较熟悉的例子说起: 12345678class Coordinate&#123;public: Coordinate(int x,int y);private:const int m_ix;const int m_iy;&#125;; 因为成员变量是两个常成员，所以不能用一般的构造函数进行初始化，需要用初始化列表。123Coordinate::Coordinate(int x,int y):m_ix(x),m_iy(y)&#123;&#125; 从这里可以看到，一般的对象成员是可以用const来修饰的，其实，对象成员也可以用const来修饰，我们把这类成员称为常对象成员。 1.常对象成员如果想要在类中实现对象成员一旦初始化就不允许再修改，那么就可以用const常对象成员,例如:12345678class Line&#123;public: Line(int x1,int y1,int x2,int y2);private: const Coordinate m_coorA; const Coordinate m_coorB;&#125; 初始化用实例化时传参+初始化列表进行操作。 2.常成员函数如果大家更加大胆些，就可能会想到一个问题:既然有了常对象成员，那么是否会有常成员函数？答案自然是肯定的，例如:12345678910class Coordinate&#123;public: Coordinate(int x,int y); void changeX() const; // &lt;--- 常成员函数 1 void changeX(); // 2 1和2互为重载private: int m_ix; int m_iy;&#125; 常对象就只能调用常成员函数，而非常对象就都可以调用。但是类似重载的情况就只能实例化一个常对象来进行调用常成员函数了。 在重载情况下调用常对象成员示例:123456int main()&#123; const Coordinate coor(1,2);// &lt;--- 常对象的定义方法 coor.changeX(); //此时调用的changeX()函数就是常成员函数了 return 0;&#125; !!! 常成员函数中不可以修改数据成员的值。 在上一次的博客:this的用法中已经详细介绍了关于this应该如何运用，这里不在赘述。1234void Coordinate::changeX() const&#123; m_ix = 10; //False 这是不被允许的，原因下面有。&#125; 其实上面的代码可以理解为:1234void changeX(const Coordinate *this)&#123; this-&gt;m_ix = 10; //上面也提到常指针是不可以改变的，所以不被允许。&#125; 定义常成员函数的方法:在.h文件中，在普通成员函数声明后面加上 const ，然后在其对应的.cpp文件定义中的对应定义函数后面加上 const 后面。注意在函数括号后面加一个小空格，防止编译错误。 如果大家对常对象和常成员函数还是很模糊，点击传送门,深入理解。 3.常指针与常引用示例的前提条件:1234567891011class Coordinate&#123;public: Coordinate(int x,int y); int getX(); int getY(); void printInfo() const; //注意这个是常成员函数private: int m_iX; int m_iY;&#125;; 下面我们来看看对象的引用和对象的指针如何来定义:12345678910int main()&#123; Coordinate coor1(3,5); Coordinate &amp;coor2 = coor1; //&lt;---对象的引用 Coordinate *pCoor = &amp;coor1; //&lt;---对象的指针 coor1.printInfo(); coor2.printInfo(); pCoor-&gt;printInfo(); return 0;&#125; 仿照上述代码即可实现对象的引用和指针，需要注意的是，使用对象的引用时，可将对象直接赋值给其”别名” ；使用对象的指针时，需要将对象取地址(即加取地址符号&amp;)进行赋值。正如大家所想，如果我们在定义它们的指针和引用时，在其前面加上const就是常对象和常指针了,示例如下:12345678910int main()&#123; Coordinate coor(3,5); const Coordinate &amp;coor2 = coor1; //&lt;---对象的常引用 const Coordinate *pCoor = &amp;coor1; //&lt;---对象的常指针 coor1.printInfo(); coor2.printInfo(); pCoor-&gt;printInfo(); return 0;&#125; !!! 常引用和常指针只有读权限，没有写权限，只能调用它的常成员函数。 下面看一个更加复杂的例子:12345678910int main()&#123; Coordinate coor1(3,5); Coordinate coor2(7,9); Coordinate * const pCoor = &amp;coor1; pCoor-&gt;getY(); //1 需要读写权限对象调用 pCoor = coor2; //2 pCoor-&gt;printInfo(); //3 仅需要读权限的对象就可以调用 return 0;&#125; 下面我们分析一下上面这几行代码,有哪个是错误的。首先看第三行定义代码，所在的位置是在const后面，所以意味着这个pCoor指针不能再指向其他的对象，但是它的权限时同时具备读和写的。所以1是对的,2是错的,3也是对的。 const最重要的是可以使读写权限转变成只读权限*。 推荐视频: 第一部分视频连接: 控制变化的const 第三部分视频链接: 常对象成员和常成员函数,常指针与常引用 tips:可能需要登录才可以看视频。]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白如何在ubuntu上进行C++开发]]></title>
    <url>%2F2018%2F05%2F18%2F%E5%B0%8F%E7%99%BD%E5%A6%82%E4%BD%95%E5%9C%A8ubuntu%E4%B8%8A%E8%BF%9B%E8%A1%8CC-%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[对于初入ubuntu开发的小白来说，这的确是一个严峻的挑战。当然，在linux下的IDE也很多，但是既然想成为一个合格的开发者，最好是要理解开发的整个过程。本文也是在查阅了大量的资料后的一个小总结，仅供大家参考。 1.编写程序本文选用的是vim，当今比较主流的一个文本编辑器。 把Vim打造成牛逼的C++ IDE 一步步将vim改造成C/C++开发环境(IDE) 其实都是大同小异啦。当然，如果你不想这么做，没人管你，不过对于那些刚刚从Windows转过来的童鞋还是很需要的。 如果你实在是想选取IDE的话，这里有很多的推荐,推荐2。 2.编译程序 说到这，就不得不提强大的gcc了，它的用法点这里。 了解的多了，就会有人产生一些疑惑，比如cc与gcc或者gcc与g++。 对于有个大型的C++工程来说，就不得不提makefile了，这个链接关于Makefile比较清晰。 支持原创请移步陈皓博客:https://blog.csdn.net/haoel/article/details/2886 当然我自己的博客也有写:跟我一起学写makefile。 3.运行程序 cd 到需要运行程序所在目录,运行命令 ./ xxx(文件名)即可。 自己编写成功的程序肯定是可以运行的，下载的程序可能会有权限问题。 权限问题解决请自己查阅资料解决。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟我一起学写makefile]]></title>
    <url>%2F2018%2F05%2F17%2F%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6%E5%86%99makefile%2F</url>
    <content type="text"><![CDATA[未完待续…… 写在前面作者在写本文时，着重参考了CSDN博客作者陈皓的博客，在此表示十分感谢。 对于大多数用Windows学编程的同学也许不知道makefile这个东西，因为Windows的IDE为你做了这个工作。最近打算转战Unix系统，所以在被逼无奈之下，了解了一下makefile，在此写出同大家一起分享。 Question：什么是makefile？ makefile关系了整个工程的编译规则，在一个工程中，源文件不计其数，其按照类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定那个文件需要先编译，那个文件需要后编译，那些文件需要重新编译，甚至于更加复杂的功能操作，，这里的makefile就像是一个shell脚本一样，其中也可以执行操作的命令。 makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具。 程序的编译和链接 一般来说，无论是C，C++，还是pas，首先要把源文件编译成中间代码文件，Windows下为.obj文件，Unix下是.o文件，即 Object File，这个动作叫做编译(compile)。然后再把大量的Object File合成可执行文件，这个动作叫做链接（link）。 编译时，编译器需要的是语法的正确，函数与变量的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（这里的头文件只要声明），只要所有的语法正确，编译器就可以编译出中间文件。一般来说，每个源文件都应该对应于一个中间文件。 链接时，主要是链接函数和全局变量。链接器并不管函数所在的源文件，只要函数的中间文件(Object File)，在大多数时候，由于源文件太多，对应编译生成的中间目标文件（.o）太多，而在连接时需要明显的指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”(Library File),即.lib文件，在UNIX下，是Archive File,也就是.a文件。 总而言之,源文件首先会生成中间目标文件（.obj或.o），再由中间目标文件生成执行文件。编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），你需要指定函数的Object File。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cpp之This指针]]></title>
    <url>%2F2018%2F05%2F17%2FCpp%E4%B9%8BThis%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[1.this指针: 指向自身数据的指针举例如下：123456789class Array //代码1&#123;public: Array(int _len)&#123;len = _len;&#125; int getlen()&#123;return len;&#125; void setlen(int _len)&#123;len = _len;&#125;private: int len;&#125;; 这里数据成员和参数在表达相同意思时用的是不同的变量，所以如果想用相同的变量就需要一个标记来区分该变量时数据成员还是参数,即this指针。 123456789class Array //代码2&#123;public: Array(int len)&#123;this-&gt;len = len;&#125; int getlen()&#123;return len;&#125; void setlen(int len)&#123;this-&gt;len = len;&#125;private: int len;&#125;; 这样，用this指针指明了数据成员，就可以用相同的变量来进行表示了。 Question：为什么成员函数可以直接访问数据成员？ 知识准备: 对象结构在进行对多个对象实例化的时候，在内存中会定义对应多个数据成员，但是成员函数只有一份，储存在代码区。而且每个对象进行调用的时候，每个对象都能够准确无误的进行调用。大家有没有想过这是为什么呢？其实这就是this指针的功劳。 我们来看下面这个例子：123456789class Array //代码3&#123;public: Array(T *this,int _len)&#123;this-&gt;len = _len;&#125; int getlen(T *this)&#123;return this-&gt;len;&#125; void setlen(T *this,int _len)&#123;this-&gt;len = _len;&#125;private: int len;&#125;; 大家是不是发现了和第一个例子的区别？显而易见，就是每个成员函数都加了一个this指针，这样上面所提到的问题就迎刃而解了。我们设想一下，当我们去实例化一个对象并使用他们的成员函数时，this指针就代表这个对象本身的地址，也就是说当我们调用成员函数时,编译器会悄悄地把代码1转换成代码3，所以每次调用成员函数，都是改变对应对象的成员变量。 上面说了，编译器自动的为每个成员函数的参数列表都加了一个this指针, Thus，我们只需要理解就可，没有必要自己显式的写出来。 推荐视频：如何理解this指针? Tips: 看视频需要注册账号，只有注册登录才可以看视频。]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown简单用法]]></title>
    <url>%2F2018%2F05%2F11%2Fmarkdown%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文是作者第一篇hexo博客，排版等问题不足之处请见谅。 1.Markdown官方文档及其他参考 特别感谢简书刘邓诏初的blog对本文的帮助 Markdown语法入门 官方文档详细版 2.常用语法规则标题共六级标题，用#的累计来进行区分，#号越少字号越大下面给出相应代码，如图所示： 换行和分段 换行：只需要在行末加两个空格键和一个回车 分段：段落之间空一行即可 文本样式 加粗: 加粗 斜体: 斜体 删除线: 删除线 底纹: 底纹 引用只要将文本内容之前加[ &gt;(大于号) ]即可将文本变成引用文本。 我是引用文本 图片和链接 图片格式: ! [图片描述] (链接的地址) 链接: [文本内容] (链接的地址) 如果是本地的图片可以参考: hexo生成blog本地图片插入方法 实际用时在 感叹号，中括号和小括号 之间不能有空格，这里只是为了展示效果 水平线三个[ - ]或者[ * ]都可以画出一条水平分割线 实现方式: 表格在markdown制作表格非常麻烦，必须要画出来！！！ 脚注脚注成对出现，[^1]作为标记，可以点击调至末尾注解。[^1]填写注解，不论写在什么位置，都会出现在文章的末尾。 注释注释是给自己看的，预览和发布时都不会出现。 end: 暂时先总结这些，实现了最基础的一些功能,能满足大家的一定需要，对markdown有兴趣却还没有基础的小白可以看看，大神请绕道，等日后再慢慢更新… 5月16日补充： 代码框的三种形式 两对’’’包裹 代码前面加两个空格键 代码前面加一个TAB键 让hexo代码高亮格式：123456&gt;```语言名 （比如cpp） &gt; #include &lt; iostream&gt;&gt; using namespace std;&gt; ...&gt;``` //第一行说明语言，下面是代码内容&gt; 点击这里可以查看代码高亮支持格式和化名 特别感谢：https://www.jianshu.com/p/0130ad32a08d]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim+插件实现markdown功能]]></title>
    <url>%2F2018%2F05%2F11%2Fvim-%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0markdown%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[具体请参考：https://www.jianshu.com/p/44d31327f953里面实现了从小白到搭建好markdown的所有过程。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>示例</category>
      </categories>
      <tags>
        <tag>hello World</tag>
      </tags>
  </entry>
</search>
